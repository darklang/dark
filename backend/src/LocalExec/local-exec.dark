let listDirectoryRecursive (dir: String) : List<String> =
  let contents = Directory.list dir
  let (files, dirs) = contents |> List.partition (fun x -> File.isNormal x)
  let nested = dirs |> List.map (fun d -> listDirectoryRecursive d) |> List.flatten
  dirs |> List.append files |> List.append nested


// Packages
let listPackageFilesOnDisk (dir: String) : List<String> =
  dir
  |> listDirectoryRecursive
  |> List.filter (fun x -> x |> String.endsWith ".dark")


let saveFunctionToCanvas
  (p: PACKAGE.Darklang.Stdlib.ProgramTypes.PackageFn.T)
  : Unit =
  let reqBody =
    p
    |> Json.serialize<PACKAGE.Darklang.Stdlib.ProgramTypes.PackageFn.T>
    |> unwrap
    |> String.toBytes

  let _ =
    HttpClient.request
      "POST"
      ("http://dark-packages.dlio.localhost:11003/functions")
      []
      reqBody

  ()

let saveTypeToCanvas (p: PACKAGE.Darklang.Stdlib.ProgramTypes.PackageType.T) : Unit =
  let reqBody =
    p
    |> Json.serialize<PACKAGE.Darklang.Stdlib.ProgramTypes.PackageType.T>
    |> unwrap
    |> String.toBytes

  let _ =
    HttpClient.request
      "POST"
      ("http://dark-packages.dlio.localhost:11003/types")
      []
      reqBody

  ()

let loadPackageFile (filename: String) : Unit =
  filename
  |> LocalExec.File.read
  |> String.fromBytes
  |> LocalExec.Packages.parseAndSave filename


let loadPackageFileIntoDarkCanvas (filename: String) : Unit =
  let packages =
    filename
    |> File.read
    |> unwrap
    |> String.fromBytes
    |> LocalExec.Packages.parse filename
    |> unwrap

  let fns =
    packages.fns
    |> Json.parse<List<PACKAGE.Darklang.Stdlib.ProgramTypes.PackageFn.T>>
    |> unwrap

  let types =
    packages.types
    |> Json.parse<List<PACKAGE.Darklang.Stdlib.ProgramTypes.PackageType.T>>
    |> unwrap

  fns |> List.iter (fun fn -> saveFunctionToCanvas fn)
  types |> List.iter (fun t -> saveTypeToCanvas t)


let printPackageFunction (p: LocalExec.Packages.Function) : Unit =
  let modules = p.modules |> String.join "."

  print $"Package Function {p.owner}.{modules}.{p.name}_v{Int.toString_v0 p.version}"

let printPackageType (p: LocalExec.Packages.Type) : Unit =
  let modules = p.modules |> String.join "."
  print $"Package Type {p.owner}.{modules}.{p.name}_v{Int.toString_v0 p.version}"

let printAllPackages () : Unit =
  let functions = LocalExec.Packages.listFunctions ()
  functions |> List.iter (fun p -> printPackageFunction p)

  let types = LocalExec.Packages.listTypes ()
  types |> List.iter (fun p -> printPackageType p)


// Running scripts
let runScript (path: String) (args: List<String>) : Int =
  let script = (File.read path) |> unwrap |> String.fromBytes
  let result = (LocalExec.parseAndExecuteScript path script args) |> unwrap
  result


// parse args and execute
type CliOptions =
  | Help
  | LoadPackages
  | LoadPackagesIntoDarkCanvas
  | ListPackages
  | RunScript of path: String * args: List<String>
  | BadOption of String

let usage () : String =
  "Usage: LocalExec [options]

    Options:
      -h, --help          Show this help message and exit
      load-packages       Load packages from packages
      load-packages-dark  Load packages from dark packages canvas
      list-packages       List packages
      run-script          Parse and run .dark script
  "


let parseArgs (args: List<String>) : CliOptions =
  match args with
  | [] -> CliOptions.Help
  | [ "-h" ] -> CliOptions.Help
  | [ "--help" ] -> CliOptions.Help

  | [ "list-packages" ] -> CliOptions.ListPackages
  | [ "load-packages" ] -> CliOptions.LoadPackages
  | [ "load-packages-dark" ] -> CliOptions.LoadPackagesIntoDarkCanvas

  | [ "run-script" ] ->
    CliOptions.BadOption "Missing path to script after `run-script`"
  | "run-script" :: path :: args -> CliOptions.RunScript(path, args)
  | _ -> CliOptions.BadOption "Invalid arguments"



let main (args: List<String>) : Int =
  match parseArgs args with
  | Help ->
    print (usage ())
    0

  | ListPackages ->
    printAllPackages ()
    0

  | LoadPackages ->
    LocalExec.Packages.clear ()
    let files = listPackageFilesOnDisk "/home/dark/app/packages"

    do // can we get rid of this do?
      List.iter files (fun f ->
        print $"Loading {f}"
        loadPackageFile f)

    print "Done loading packages"
    0

  | RunScript(path, args) ->
    print $"Running script with LocalExec: {path}"
    runScript path args

  | LoadPackagesIntoDarkCanvas ->
    let files = listPackageFilesOnDisk "/home/dark/app/packages"

    do // can we get rid of this do?
      List.iter files (fun f ->
        print $"Loading {f}"
        loadPackageFileIntoDarkCanvas f)

    print "Done loading packages from dark packages canvas"
    printAllPackages ()
    0

  | BadOption msg ->
    print ("Error: " ++ msg)
    1

main args