open Core_kernel
open Lib
open Types.RuntimeT

let fns : Lib.shortfn list =
  [ { pns = ["DarkInternal::checkAccess"]
    ; ins = []
    ; p = []
    ; r = TNull
    ; d = "TODO"
    ; f = NotClientAvailable
    ; pr = None
    ; ps = false
    ; dep = false }
  ; { pns = ["DarkInternal::checkAllCanvases"]
    ; ins = []
    ; p = []
    ; r = TNull
    ; d = "TODO"
    ; f = NotClientAvailable
    ; pr = None
    ; ps = false
    ; dep = true }
  ; { pns = ["DarkInternal::migrateAllCanvases"]
    ; ins = []
    ; p = []
    ; r = TNull
    ; d = "TODO"
    ; f = NotClientAvailable
    ; pr = None
    ; ps = false
    ; dep = false }
  ; { pns = ["DarkInternal::cleanupOldTraces"]
    ; ins = []
    ; p = []
    ; r = TNull
    ; d = "Deprecated, use v1"
    ; f = NotClientAvailable
    ; pr = None
    ; ps = false
    ; dep = true }
  ; { pns = ["DarkInternal::cleanupOldTraces_v1"]
    ; ins = []
    ; p = [par "host" TStr]
    ; r = TNull
    ; d = "Cleanup the old traces from a canvas"
    ; f = NotClientAvailable
    ; pr = None
    ; ps = false
    ; dep = false }
  ; { pns = ["DarkInternal::checkCanvas"]
    ; ins = []
    ; p = [par "host" TStr]
    ; r = TBool
    ; d = "TODO"
    ; f = NotClientAvailable
    ; pr = None
    ; ps = false
    ; dep = false }
  ; { pns = ["DarkInternal::upsertUser"]
    ; ins = []
    ; p = [par "username" TStr; par "email" TStr; par "name" TStr]
    ; r = TStr
    ; d =
        "Add a user. Returns a password for the user, which was randomly generated. Usernames are unique: if you add the same username multiple times, it will overwrite the old settings (useful for changing password)."
    ; f = NotClientAvailable
    ; pr = None
    ; ps = false
    ; dep = false }
  ; { pns = ["DarkInternal::getUser"]
    ; ins = []
    ; p = [par "username" TStr]
    ; r = TOption
    ; d = "Return a user for the username. Does not include passwords."
    ; f = NotClientAvailable
    ; pr = None
    ; ps = false
    ; dep = false }
  ; { pns = ["DarkInternal::getUsers"]
    ; ins = []
    ; p = []
    ; r = TList
    ; d = "Return a list of username of all the accounts in Dark."
    ; f = NotClientAvailable
    ; pr = None
    ; ps = false
    ; dep = false }
  ; { pns = ["DarkInternal::getAllCanvases"]
    ; ins = []
    ; p = []
    ; r = TList
    ; d = "TODO"
    ; f = NotClientAvailable
    ; pr = None
    ; ps = false
    ; dep = false }
  ; { pns = ["DarkInternal::canvasAsText"]
    ; ins = []
    ; p = [par "host" TStr]
    ; r = TStr
    ; d = "TODO"
    ; f = NotClientAvailable
    ; pr = None
    ; ps = false
    ; dep = false }
  ; { pns = ["DarkInternal::handlers"]
    ; ins = []
    ; p = [par "host" TStr]
    ; r = TList
    ; d = "Returns a list of toplevel ids of handlers in `host`"
    ; f = NotClientAvailable
    ; pr = None
    ; ps = false
    ; dep = false }
  ; { pns = ["DarkInternal::canLoadTraces"]
    ; ins = []
    ; p = [par "host" TStr; par "tlid" TStr]
    ; r = TBool
    ; d =
        "Takes a `host` and a `tlid` and returns true iff. we can load+parse traces for the handler identified by `tlid`, and false otherwise"
    ; f = NotClientAvailable
    ; pr = None
    ; ps = false
    ; dep = false }
  ; { pns = ["DarkInternal::getCORSSetting"]
    ; ins = []
    ; p = [par "canvas" TStr]
    ; r = TOption
    ; d =
        "Given the full canvas name (including the username), get that canvas' global CORS setting."
    ; f = NotClientAvailable
    ; pr = None
    ; ps = false
    ; dep = false }
  ; { pns = ["DarkInternal::setCORSSetting"]
    ; ins = []
    ; p = [par "canvas" TStr; par "origins" TOption]
    ; r = TResult
    ; d =
        "Given the full canvas name (including the username) and an Option of either \"*\" or a list of string origins, set that value to that canvas' global CORS setting, so that it will be used in Access-Control-Allow-Origin response headers. Returns true if it worked and false if it didn't (likely meaning: the Dark value you passed in was invalid)."
    ; f = NotClientAvailable
    ; pr = None
    ; ps = false
    ; dep = false } ]
