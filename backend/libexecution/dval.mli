(* ------------------------- *)
(* Strings *)
(* ------------------------- *)

(* Given an OCaml string, turn it into a Dark string. Will return Nothing
 * if the OCaml string is not proper UTF-8. *)

val dstr_of_string : string -> 'expr_type Types.RuntimeT.dval option

(* Given an OCaml string, turn it into a Dark string. Will raise an exception
 * if the OCaml string is not proper UTF-8. *)

val dstr_of_string_exn : string -> 'expr_type Types.RuntimeT.dval

(* ------------------------- *)
(* Types *)
(* ------------------------- *)
val tipe_to_string : Types.tipe_ -> string

val tipe_of_string : Core_kernel.String.t -> Types.tipe_

val tipe_of : 'expr_type Types.RuntimeT.dval -> Types.tipe_

(** [tipename dval] produces a non-user-facing name for the type of the given [dval]. *)
val tipename : 'expr_type Types.RuntimeT.dval -> string

(** [pretty_tipename dval] produces a user-facing name for the type of the given [dval]. *)
val pretty_tipename : 'expr_type Types.RuntimeT.dval -> string

val unsafe_tipe_to_yojson : Types.RuntimeT.tipe -> Yojson.Safe.t

val unsafe_tipe_of_yojson :
  Yojson.Safe.t -> (Types.RuntimeT.tipe, 'a) Core_kernel._result

(* ------------------------- *)
(* Representations *)
(* ------------------------- *)

(* This is a format used for roundtripping dvals internally. v0 has bugs due to
 * a legacy of trying to make one function useful for everything. Does not
 * redact. *)
val to_internal_roundtrippable_v0 : 'expr_type Types.RuntimeT.dval -> string

(* This is a format used for roundtripping dvals internally. There are some
 * rare cases where it will parse incorrectly without error. Throws on Json
 * bugs. *)
val of_internal_roundtrippable_v0 :
  string -> Types.fluid_expr Types.RuntimeT.dval

val of_internal_roundtrippable_json_v0 :
     Yojson.Safe.t
  -> (Types.fluid_expr Types.RuntimeT.dval, string) Core_kernel._result

(* This is a format used for roundtripping dvals internally, while still being
 * queryable using jsonb in our DB. v0 has bugs due to a legacy of trying to
 * make one function useful for everything. Also roundtrippable. Does not
 * redact. *)
val to_internal_queryable_v0 : 'expr_type Types.RuntimeT.dval -> string

(* This is a format used for roundtripping dvals internally, while still being
 * queryable using jsonb in our DB. There are some rare cases where it will
 * parse incorrectly without error. Throws on Json bugs. *)
val of_internal_queryable_v0 : string -> Types.fluid_expr Types.RuntimeT.dval

(* This is a format used for roundtripping dvals internally, while still being
 * queryable using jsonb in our DB. This reduces some of the v0 bugs, but at
 * the cost of not supporting many typed that we'll want to put in it.  Also
 * roundtrippable. Does not redact. *)
val to_internal_queryable_v1 : 'expr_type Types.RuntimeT.dval_map -> string

(* to_internal_queryable_v1 (above) is how we serialize what we put in the user db
 * (a DObj);  to_internal_queryable_field_v1 lets us use the same serializers
 * for fields so we can query safely from sql_compiler.ml *)
val to_internal_queryable_field_v1 : 'expr_type Types.RuntimeT.dval -> string

(* This is a format used for roundtripping dvals internally, while still being
 * queryable using jsonb in our DB. There are some rare cases where it will
 * parse incorrectly without error. Throws on Json bugs. *)

val of_internal_queryable_v1 : string -> 'expr_type Types.RuntimeT.dval

(* When printing to grand-users (our users' users) using text/plain, print a
 * human-readable format. TODO: this should probably be part of the functions
 * generating the responses. Redacts passwords. *)
val to_enduser_readable_text_v0 : 'expr_type Types.RuntimeT.dval -> string

(* When printing to grand-users (our users' users) using text/html, attempt to
 * extract a html-like string. Redacts passwords. TODO: this should probably be
 * part of the functions generating the responses. *)
val to_enduser_readable_html_v0 : 'expr_type Types.RuntimeT.dval -> string

(* For printing something for the developer to read, as a live-value, error
 * message, etc. This will faithfully represent the code, textually. Redacts
 * passwords. Customers should not come to rely on this format. *)
val to_developer_repr_v0 : 'expr_type Types.RuntimeT.dval -> string

(* For printing types for the developer to read, in live-values, error
 * messages, etc. Customers should not come to rely on this format. *)
val tipe_to_developer_repr_v0 : Types.tipe_ -> string

(* For passing to Dark functions that operate on JSON, such as the JWT fns.
 * This turns Option and Result into plain values, or null/error. String-like
 * values are rendered as string. Redacts passwords. *)
val to_pretty_machine_yojson_v1 :
  'expr_type Types.RuntimeT.dval -> Yojson.Safe.t

(* When sending json back to the user, or via a HTTP API, attempt to convert
 * everything into reasonable json, in the absence of a schema. This turns
 * Option and Result into plain values, or null/error. String-like values are
 * rendered as string. Redacts passwords. *)
val to_pretty_machine_json_v1 : 'expr_type Types.RuntimeT.dval -> string

(* When receiving unknown json from the user, or via a HTTP API, attempt to
 * convert everything into reasonable types, in the absense of a schema.
 * This does type conversion, which it shouldn't and should be avoided for new code. *)
val of_unknown_json_v0 : string -> Types.RuntimeT.fluid_dval

(* When receiving unknown json from the user, or via a HTTP API, attempt to
 * convert everything into reasonable types, in the absense of a schema. *)
val of_unknown_json_v1 : string -> Types.RuntimeT.fluid_dval

(* For debugging internally, redacts passwords. Never throws. *)
val show : 'expr_type Types.RuntimeT.dval -> string

(* JSON coming in from the user as part of a known API should have a type which
 * can act as a schema to reconstruct the data perfectly. Redacts passwords. *)
(* type schema  *)
(* val of_json_with_schema : schema: schema -> Yojson.Safe.t -> 'expr_type Types.RuntimeT.dval *)
(* val to_json_with_schema : schema: schema -> 'expr_type Types.RuntimeT.dval -> Yojson.Safe.t  *)

(* Parse our internal literal strings (eg AST Values) *)
val parse_literal : string -> 'expr_type Types.RuntimeT.dval option

(* ------------------------- *)
(* Conversion Functions *)
(* ------------------------- *)

(* queries *)
val query_to_dval :
  (string * string list) list -> 'expr_type Types.RuntimeT.dval

val dval_to_query :
  'expr_type Types.RuntimeT.dval -> (string * string list) list

(* forms *)
val to_form_encoding : 'expr_type Types.RuntimeT.dval -> string

val of_form_encoding : string -> 'expr_type Types.RuntimeT.dval

(* If a DCharacter, returns `Some char`, as a string (Dark characters are EGCs,
 * and can be longer than a byte. *)
val to_char : 'expr_type Types.RuntimeT.dval -> string option

val to_int : 'expr_type Types.RuntimeT.dval -> Dint.t option

val to_float : 'expr_type Types.RuntimeT.dval -> Base.Float.t option

val dint : int -> 'expr_type Types.RuntimeT.dval

(* Converts a Dark String to an OCaml string. *)
val to_string_opt : 'expr_type Types.RuntimeT.dval -> string option

(* Converts a Dark String to an OCaml string. Raises an Exception if not a
 * string. *)
val to_string_exn : 'expr_type Types.RuntimeT.dval -> string

(* Converts an object to (string,string) pairs. Raises an exception if not an
 * object. *)
val to_string_pairs_exn :
  'expr_type Types.RuntimeT.dval -> (string * string) list

(* Converts an object to (string,dval) pairs. Raises an exception if not an
 * object. *)
val to_dval_pairs_exn :
     'expr_type Types.RuntimeT.dval
  -> (string * 'expr_type Types.RuntimeT.dval) list

(* For putting into URLs as query params  *)
val to_url_string_exn : 'expr_type Types.RuntimeT.dval -> string

(* Errors if the values in the list are not strings, or if any key is
 * duplicated. *)
val to_dobj_exn :
     (string * 'expr_type Types.RuntimeT.dval) list
  -> 'expr_type Types.RuntimeT.dval

val exception_to_dval :
     Core_kernel.Exn.t
  -> Types.RuntimeT.dval_source
  -> 'expr_type Types.RuntimeT.dval

(* ------------------------- *)
(* ErrorRail Functions *)
(* ------------------------- *)
val is_errorrail : 'expr_type Types.RuntimeT.dval -> bool

val unwrap_from_errorrail :
  'expr_type Types.RuntimeT.dval -> 'expr_type Types.RuntimeT.dval

val to_list :
  'expr_type Types.RuntimeT.dval list -> 'expr_type Types.RuntimeT.dval

val to_opt_just :
  'expr_type Types.RuntimeT.dval -> 'expr_type Types.RuntimeT.dval

val dopt_of_option :
  'expr_type Types.RuntimeT.dval option -> 'expr_type Types.RuntimeT.dval

val to_res_ok : 'expr_type Types.RuntimeT.dval -> 'expr_type Types.RuntimeT.dval

val to_res_err :
  'expr_type Types.RuntimeT.dval -> 'expr_type Types.RuntimeT.dval

val is_fake_marker_dval : 'expr_type Types.RuntimeT.dval -> bool

(* ------------------------- *)
(* Object Functions *)
(* ------------------------- *)
val obj_merge :
     'expr_type Types.RuntimeT.dval
  -> 'expr_type Types.RuntimeT.dval
  -> 'expr_type Types.RuntimeT.dval

val empty_dobj : 'expr_type Types.RuntimeT.dval

(* ------------------------- *)
(* Misc *)
(* ------------------------- *)
val supported_hash_versions : int list

val current_hash_version : int

val hash : int -> 'expr_type Types.RuntimeT.dval list -> string
