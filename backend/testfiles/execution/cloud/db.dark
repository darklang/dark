// really simple data stores of Records
type X = { x: String }

[<DB>]
type XDB = X


type Z = { x: Char }

[<DB>]
type ZDB = Z


type XY = { x: String; y: String }

[<DB>]
type XYDB = XY


type SortedX = { x: String; sortBy: Int64 }

[<DB>]
type SortedXDB = SortedX

// simple data stores of Enums
// , and Records containing Enums

type MyEnum =
  | A
  | B
  | C

type MyEnum2 =
  | D
  | E
  | F of MyEnum

type EnumTestRecord = { x: String; y: MyEnum }

[<DB>]
type TestEnumDB = EnumTestRecord

[<DB>]
type TestEnumDB2 = MyEnum

[<DB>]
type TestEnumDB3 = MyEnum2


// Nested field accessing
type VeryInnerRecord = { age: Int64 }
type AliasOfVeryInnerRecord = VeryInnerRecord
type InnerRecord = { numbers: AliasOfVeryInnerRecord }
type OuterRecord = { name: String; details: InnerRecord }
type AliasOfRecord = OuterRecord

[<DB>]
type TestNestedRecord = OuterRecord

[<DB>]
type TestNestedAliasRecord = AliasOfRecord


// We're mostly ready to start uncommenting these tests that reference DBs
// -- the DBs are getting set up appropriately, we have the basic get/set builtins
// , etc.
// The bit that _isn't_ working here is that references _to_ those DBs are being
// parsed as EVariables. In the old interpreter, we dealt with this
// we could ad


module SetDoesUpsert =
  (let old = Stdlib.DB.set (X { x = "hello" }) "hello" XDB
   let newval = Stdlib.DB.set (X { x = "goodbye" }) "hello" XDB
   Stdlib.DB.getAllWithKeys XDB) = Dict { hello = X { x = "goodbye" } }

module SetCharUpserts =
  (let old = Stdlib.DB.set (Z { x = 'a' }) "a" ZDB
   let newval = Stdlib.DB.set (Z { x = 'b' }) "a" ZDB
   Stdlib.DB.getAllWithKeys ZDB) = Dict { a = Z { x = 'b' } }



module Get =
  // return none for empty store
  (Stdlib.DB.get "lol" XDB) = Stdlib.Option.Option.None

  // return none for invalid key
  (let _ = Stdlib.DB.set (X { x = "hello" }) "key" XDB in Stdlib.DB.get "lol" XDB) = Stdlib.Option.Option.None

  // returns single value
  (let _ = Stdlib.DB.set (X { x = "hello" }) "key" XDB in Stdlib.DB.get "key" XDB) = Stdlib
    .Option
    .Option
    .Some(X { x = "hello" })

  // returns correct value given reassigned entry
  (let _ = Stdlib.DB.set (X { x = "hello" }) "key" XDB
   let _ = Stdlib.DB.set (X { x = "goodbye" }) "key" XDB
   Stdlib.DB.get "key" XDB) = Stdlib.Option.Option.Some(X { x = "goodbye" })

  // returns value given multiple entries
  (let _ = Stdlib.DB.set (X { x = "pancake" }) "key1" XDB
   let _ = Stdlib.DB.set (X { x = "waffle" }) "key2" XDB
   let _ = Stdlib.DB.set (X { x = "scone" }) "key3" XDB
   Stdlib.DB.get "key2" XDB) = Stdlib.Option.Option.Some(X { x = "waffle" })



module NestedRecordFieldAccess =
  // can use lambda like (fun p -> p.details.numbers.age)
  (Stdlib.DB.set
    (OuterRecord { name = "joe"; details = InnerRecord { numbers = AliasOfVeryInnerRecord { age = 41L } } })
    "jjj"
    TestNestedRecord

   Stdlib.DB.set
     (OuterRecord { name = "frank"; details = InnerRecord { numbers = VeryInnerRecord { age = 22L } } })
     "fff"
     TestNestedRecord

   let shouldBeJustJoe =
     Stdlib.DB.query TestNestedRecord (fun p -> p.details.numbers.age == 41L)

   Stdlib.List.length shouldBeJustJoe) = 1L

  // same as above, but with aliases
  (Stdlib.DB.set
    (AliasOfRecord { name = "jeremy"; details = InnerRecord { numbers = VeryInnerRecord { age = 38L } } })
    "ignored"
    TestNestedAliasRecord

   Stdlib.DB.set
     (AliasOfRecord { name = "josephine"; details = InnerRecord { numbers = AliasOfVeryInnerRecord { age = 29L } } })
     "alsoIgnored"
     TestNestedAliasRecord

   let shouldBeJustJeremy =
     Stdlib.DB.query TestNestedAliasRecord (fun p -> p.details.numbers.age == 38L)

   Stdlib.List.length shouldBeJustJeremy) = 1L



// Query data from a type with generics
type GenericThing<'thing> = { name: 'thing }
type RecordWithGenericThing = GenericThing<String>

[<DB>]
type TestRecordWithGenericThing = RecordWithGenericThing

module AccessDataInGenericField =
  (Stdlib.DB.set
    (RecordWithGenericThing { name = "joe" })
    "jjj"
    TestRecordWithGenericThing

   Stdlib.DB.set
     (RecordWithGenericThing { name = "frank" })
     "fff"
     TestRecordWithGenericThing

   Stdlib.DB.query TestRecordWithGenericThing (fun p -> p.name == "joe")) = [ RecordWithGenericThing
                                                                                 { name =
                                                                                     "joe" } ]

module AccessRecordInGenericField =
  type RecordThing = { nested: String }

  [<DB>]
  type TestDB = GenericThing<RecordThing>


  (Stdlib.DB.set
    (GenericThing { name = RecordThing { nested = "joe" } })
    "jjj"
    TestDB

   Stdlib.DB.set
     (GenericThing { name = RecordThing { nested = "frank" } })
     "fff"
     TestDB

   let nestedValue = RecordThing { nested = "joe" }

   Stdlib.DB.query TestDB (fun p -> p.name == nestedValue)) = [ GenericThing
                                                                  { name =
                                                                      RecordThing
                                                                        { nested =
                                                                            "joe" } } ]

module AccessEnumInGenericField =
  type EnumThing = A of String

  [<DB>]
  type EnumThingDB = GenericThing<EnumThing>


  (Stdlib.DB.set (GenericThing { name = EnumThing.A "joe" }) "jjj" EnumThingDB
   Stdlib.DB.set (GenericThing { name = EnumThing.A "frank" }) "fff" EnumThingDB

   let nestedValue = EnumThing.A "joe"

   Stdlib.DB.query EnumThingDB (fun p -> p.name == nestedValue)) = [ GenericThing
                                                                       { name =
                                                                           EnumThing.A
                                                                             "joe" } ]


module AddToTestEnumDBs =
  (let _ =
    Stdlib.DB.set (EnumTestRecord { x = "hello"; y = MyEnum.A }) "test1" TestEnumDB

   let _ =
     Stdlib.DB.set
       (EnumTestRecord { x = "goodbye"; y = MyEnum.B })
       "test2"
       TestEnumDB

   (Stdlib.DB.getAll TestEnumDB) |> Stdlib.List.sort) = [ EnumTestRecord
                                                            { x = "goodbye"
                                                              y = MyEnum.B }
                                                          EnumTestRecord
                                                            { x = "hello"
                                                              y = MyEnum.A } ]

  (let _ =
    Stdlib.DB.set (EnumTestRecord { x = "hello"; y = MyEnum.A }) "test1" TestEnumDB

   let _ =
     Stdlib.DB.set
       (EnumTestRecord { x = "goodbye"; y = MyEnum.B })
       "test2"
       TestEnumDB

   (Stdlib.DB.get "test1" TestEnumDB)) = Stdlib.Option.Option.Some(
    EnumTestRecord { x = "hello"; y = MyEnum.A }
  )

  (let test1 = Stdlib.DB.set MyEnum.A "test1" TestEnumDB2
   let test2 = Stdlib.DB.set MyEnum.B "test2" TestEnumDB2
   (Stdlib.DB.getAll TestEnumDB2) |> Stdlib.List.sort) = [ MyEnum.A; MyEnum.B ]

  (let test1 = Stdlib.DB.set MyEnum.C "test1" TestEnumDB2
   let test2 = Stdlib.DB.set MyEnum.B "test2" TestEnumDB2
   (Stdlib.DB.get "test1" TestEnumDB2)) = Stdlib.Option.Option.Some(MyEnum.C)

  (let test1 = Stdlib.DB.set MyEnum2.D "test1" TestEnumDB3
   let test2 = Stdlib.DB.set MyEnum2.E "test2" TestEnumDB3
   let test3 = Stdlib.DB.set (MyEnum2.F MyEnum.A) "test3" TestEnumDB3
   (Stdlib.DB.getAll TestEnumDB3) |> Stdlib.List.sort) = [ MyEnum2.D
                                                           MyEnum2.E
                                                           MyEnum2.F MyEnum.A ]

  // Query by string field
  (let _ = Stdlib.DB.set (EnumTestRecord { x = "hello"; y = MyEnum.A }) "test1" TestEnumDB
   (Stdlib.DB.query TestEnumDB (fun p -> p.x == "hello"))) = [ EnumTestRecord
                                                                  { x = "hello"
                                                                    y = MyEnum.A } ]

  // Query by enum field
  (let _ = Stdlib.DB.set (EnumTestRecord { x = "hello"; y = MyEnum.A }) "test1" TestEnumDB
   (Stdlib.DB.query TestEnumDB (fun p -> p.y == MyEnum.A))) = [ EnumTestRecord
                                                                   { x = "hello"
                                                                     y = MyEnum.A } ]



type MyTlid =
  { mytlid: Darklang.LanguageTools.TLID }

[<DB>]
type MyTlidDB = MyTlid

module AddToTest =
  (let test = Stdlib.DB.set (MyTlid { mytlid = 1234UL }) "test" MyTlidDB
   (Stdlib.DB.getAll MyTlidDB)) = [ MyTlid { mytlid = 1234UL } ]


module Roundtrip =
  type Sample =
    { iNsEnSiTiVe: String
      ``ALLCAPS``: Int64
      int: Int64
      uint64: UInt64
      int8: Int8
      uint8: UInt8
      int16: Int16
      uint16: UInt16
      int32: Int32
      uint32: UInt32
      int128: Int128
      uint128: UInt128
      float: Float
      negZero: Float
      nan: Float
      infinity: Float
      negInfinity: Float
      ``true``: Bool
      ``false``: Bool
      char: Char
      emojiChar: Char
      uuid: Uuid
      resultOk: Stdlib.Result.Result<Int64, String>
      resultError: Stdlib.Result.Result<Int64, String>
      option: Stdlib.Option.Option<Int64>
      tuple: (Int64 * String)
      record: MyTlid
      list: List<Int64>
      datetime: DateTime
      unit: Unit }

  [<DB>]
  type SampleDB = Sample

  let sample () : Sample =
    Sample
      { iNsEnSiTiVe = "iNsEnSiTiVe"
        ``ALLCAPS`` = 1L
        int = 2L
        uint64 = 2UL
        int8 = 2y
        uint8 = 2uy
        int16 = 2s
        uint16 = 2us
        int32 = 2l
        uint32 = 2ul
        int128 = 170141183460469231731687303715884105727Q
        uint128 = 340282366920938463463374607431768211455Z
        float = 3.0
        negZero = -0.0
        nan = Builtin.testNan
        infinity = Builtin.testInfinity
        negInfinity = Builtin.testNegativeInfinity
        ``true`` = true
        ``false`` = false
        list = [ 1L; 2L; 3L ]
        char = 'c'
        resultOk = Stdlib.Result.Result.Ok 5L
        resultError = Stdlib.Result.Result.Error "test"
        option = Stdlib.Option.Option.Some 5L
        record = MyTlid { mytlid = 1234UL }
        tuple = (1L, "hello")
        emojiChar = (Builtin.testToChar "ðŸ‘") |> Builtin.unwrap
        uuid =
          (Stdlib.Uuid.parse "00000050-0000-0000-0000-000000000000")
          |> Builtin.unwrap
        datetime = (Stdlib.DateTime.parse "2020-01-01T00:00:00Z") |> Builtin.unwrap
        unit = () }

  let otherSample () : Sample =
    Sample
      { iNsEnSiTiVe = "normal"
        ``ALLCAPS`` = 2L
        int = 3L
        uint64 = 3UL
        int8 = 3y
        uint8 = 3uy
        int16 = 4s
        uint16 = 4us
        int32 = 4l
        uint32 = 4ul
        int128 = -170141183460469231731687303715884105728Q
        uint128 = 0Z
        float = 4.0
        negZero = -1.0
        nan = 0.0
        infinity = 5.4
        negInfinity = -385.33
        ``true`` = false
        ``false`` = true
        list = [ 1L; 3L; 45L ]
        char = 'd'
        resultOk = Stdlib.Result.Result.Ok 6L
        resultError = Stdlib.Result.Result.Error "other test"
        option = Stdlib.Option.Option.None
        record = MyTlid { mytlid = 1235UL }
        tuple = (2L, "goodbye")
        emojiChar = 'e'
        uuid =
          (Stdlib.Uuid.parse "55555555-5555-5555-5555-555555555555")
          |> Builtin.unwrap
        datetime = (Stdlib.DateTime.parse "2011-11-11T11:11:11Z") |> Builtin.unwrap
        unit = () }

  // TODO: Add roundtrip for bytes (Bytes values not supported yet)
  (let v = sample ()
   let z = Stdlib.DB.set v "all" SampleDB
   (z, Stdlib.DB.get "all" SampleDB)) =
    (sample (), Stdlib.Option.Option.Some(sample ()))

  // QueryEquality tests - moved inside Roundtrip module to access sample() and SampleDB

  // Query by String field
  (let _ = Stdlib.DB.set (sample ()) "s1" SampleDB
   let _ = Stdlib.DB.set (otherSample ()) "s2" SampleDB
   (Stdlib.DB.query SampleDB (fun p -> p.iNsEnSiTiVe == "iNsEnSiTiVe"))
   |> Stdlib.List.map (fun p -> p.iNsEnSiTiVe)) = [ "iNsEnSiTiVe" ]

  // Query by Int64 field
  (let _ = Stdlib.DB.set (sample ()) "s1" SampleDB
   let _ = Stdlib.DB.set (otherSample ()) "s2" SampleDB
   (Stdlib.DB.query SampleDB (fun p -> p.int == 2L))
   |> Stdlib.List.map (fun p -> p.int)) = [ 2L ]

  // Query by Bool field
  (let _ = Stdlib.DB.set (sample ()) "s1" SampleDB
   let _ = Stdlib.DB.set (otherSample ()) "s2" SampleDB
   (Stdlib.DB.query SampleDB (fun p -> p.``true`` == true))
   |> Stdlib.List.map (fun p -> p.iNsEnSiTiVe)) = [ "iNsEnSiTiVe" ]

  // Query by Float field
  (let _ = Stdlib.DB.set (sample ()) "s1" SampleDB
   let _ = Stdlib.DB.set (otherSample ()) "s2" SampleDB
   (Stdlib.DB.query SampleDB (fun p -> p.float == 3.0))
   |> Stdlib.List.map (fun p -> p.iNsEnSiTiVe)) = [ "iNsEnSiTiVe" ]

  // Query by Int64 comparison
  (let _ = Stdlib.DB.set (sample ()) "s1" SampleDB
   let _ = Stdlib.DB.set (otherSample ()) "s2" SampleDB
   (Stdlib.DB.query SampleDB (fun p -> p.int > 2L))
   |> Stdlib.List.map (fun p -> p.iNsEnSiTiVe)) = [ "normal" ]

  // Query by DateTime field (using partial evaluation of outer let)
  (let _ = Stdlib.DB.set (sample ()) "s1" SampleDB
   let _ = Stdlib.DB.set (otherSample ()) "s2" SampleDB
   let targetDate = (Stdlib.DateTime.parse "2020-01-01T00:00:00Z") |> Builtin.unwrap
   (Stdlib.DB.query SampleDB (fun p -> p.datetime == targetDate))
   |> Stdlib.List.map (fun p -> p.iNsEnSiTiVe)) = [ "iNsEnSiTiVe" ]

  // Query by Char field
  (let _ = Stdlib.DB.set (sample ()) "s1" SampleDB
   let _ = Stdlib.DB.set (otherSample ()) "s2" SampleDB
   (Stdlib.DB.query SampleDB (fun p -> p.char == 'c'))
   |> Stdlib.List.map (fun p -> p.iNsEnSiTiVe)) = [ "iNsEnSiTiVe" ]


// // module QueryEquality - tests moved to Roundtrip module above



// CLEANUP test ``ALL CAPS``
// CLEANUP test partial evaluation of lists and tuples


// // module ValueMissingColumnGivesGoodError =
// //   // TYPESCLEANUP: can we test a missing column against the DB anymore?
// //   // (Stdlib.DB.set (XY { x = "x"; y = "v" }) "i" XDB) = Builtin.Test.runtimeError "Found but did not expect: [y]"

// //   (Stdlib.DB.set (XY { x = "x"; y = "v" }) "i" XDB) =
// //     Builtin.testDerrorMessage "DB XDB's value should be a X. However, a XY (XY {  x: ...) was passed instead.\n\nExpected: X\nActual: a XY: XY {\n  x: \"x\",\n  y: \"v\"\n}"




module Params =
  type Param<'a> = { x: 'a; b: Int64 }

  [<DB>]
  type ParamDB = Param<String>

  (let _ = Stdlib.DB.set (Param { x = "hello"; b = 5L }) "key" ParamDB
   Stdlib.DB.get "key" ParamDB) =
    Stdlib.Option.Option.Some(Param { x = "hello"; b = 5L })



module GetAll =
  (let _ = Stdlib.DB.set (SortedX { x = "hello"; sortBy = 0L }) "one" SortedXDB
   let _ = Stdlib.DB.set (SortedX { x = "goodbye"; sortBy = 1L }) "two" SortedXDB
   let _ = Stdlib.DB.set (SortedX { x = "howdy"; sortBy = 2L }) "three" SortedXDB
   (Stdlib.DB.getAll SortedXDB) |> Stdlib.List.sortBy_v0 (fun x -> x.sortBy)) =
    [ SortedX { x = "hello";  sortBy = 0L }
      SortedX { x = "goodbye"; sortBy = 1L }
      SortedX { x = "howdy"; sortBy = 2L } ]


module GetAllKeys =
  (let one = Stdlib.DB.set (X { x = "hello" }) "one" XDB
   let two = Stdlib.DB.set (X { x = "goodbye" }) "two" XDB
   (Stdlib.DB.keys XDB) |> Stdlib.List.sort_v0) = [ "one"; "two" ]


module GetAllWithKeys =
  (let one = Stdlib.DB.set (X { x = "hello" }) "one" XDB
   let two = Stdlib.DB.set (X { x = "goodbye" }) "two" XDB
   Stdlib.DB.getAllWithKeys XDB) =
    Dict { one = X { x = "hello" }; two = X { x = "goodbye" } }


module GetManyWithKeys =
  (let one = Stdlib.DB.set (X { x = "hello" }) "one" XDB
   let two = Stdlib.DB.set (X { x = "goodbye" }) "two" XDB
   Stdlib.DB.getManyWithKeys [ "one"; "two" ] XDB) =
    Dict
      { one = (X { x = "hello" })
        two = (X { x = "goodbye" }) }


module GetExisting =
  (let one = Stdlib.DB.set (X { x = "hello" }) "one" XDB
   let two = Stdlib.DB.set (X { x = "goodbye" }) "two" XDB
   Stdlib.DB.getExisting [ "three"; "two" ] XDB) = [ (X { x = "goodbye" }) ]


module GetMany =
  (let one = Stdlib.DB.set (X { x = "hello" }) "one" XDB
   let two = Stdlib.DB.set (X { x = "goodbye" }) "two" XDB
   Stdlib.DB.getMany [ "three"; "two" ] XDB) = Stdlib.Option.Option.None

  (let one = Stdlib.DB.set (X { x = "hello" }) "one" XDB
   let two = Stdlib.DB.set (X { x = "goodbye" }) "two" XDB

   (Stdlib.DB.getMany [ "one"; "two" ] XDB)
   |> Builtin.unwrap
   |> Stdlib.List.sortBy (fun v -> v.x)) =
    [ (X { x = "goodbye" })
      (X { x = "hello" }) ]


module Delete =
  (let _ = Stdlib.DB.set (X { x = "hello" }) "one" XDB
   let _ = Stdlib.DB.delete "one" XDB
   Stdlib.DB.getAllWithKeys XDB) = Dict { }

  // delete nothing
  (let _ = Stdlib.DB.set (X { x = "hello" }) "one" XDB
   let _ = Stdlib.DB.delete "two" XDB
   Stdlib.DB.getAllWithKeys XDB) = Dict { one = (X { x = "hello" }) }

  // deletes only one
  (let _ = Stdlib.DB.set (X { x = "hello" }) "one" XDB
   let _ = Stdlib.DB.set (X { x = "goodbye" }) "two" XDB
   let _ = Stdlib.DB.delete "one" XDB
   Stdlib.DB.getAllWithKeys XDB) = Dict { two = (X { x = "goodbye" }) }

module DeleteAll =
  (let _ = Stdlib.DB.set (X { x = "hello" }) "one" XDB
   let _ = Stdlib.DB.deleteAll XDB
   Stdlib.DB.getAll XDB) = []

  // deletes all
  (let _ = Stdlib.DB.set (X { x = "hello" }) "one" XDB
   let _ = Stdlib.DB.set (X { x = "goodbye" }) "two" XDB
   let _ = Stdlib.DB.deleteAll XDB
   Stdlib.DB.getAll XDB) = []

  // when empty
  (let delete = Stdlib.DB.deleteAll XDB in Stdlib.DB.getAll XDB) = []

module Count =
  // empty
  Stdlib.DB.count XDB = 0L

  // one entries
  (let _ = Stdlib.DB.set (X { x = "hello" }) "one" XDB in Stdlib.DB.count XDB) = 1L

  // multiple entries
  (let _ = Stdlib.DB.set (X { x = "hello" }) "one" XDB
   let _ = Stdlib.DB.set (X { x = "goodbye" }) "two" XDB
   let _ = Stdlib.DB.set (X { x = "howdy" }) "three" XDB
   let _ = Stdlib.DB.set (X { x = "cheers" }) "four" XDB
   Stdlib.DB.count XDB) = 4L

// ------------
// SqlCompiler queries
// ------------
type Person =
  { name: String
    human: Bool
    height: Int64
    income: Float
    dob: DateTime
    age: Int64 }

[<DB>]
type PersonDB = Person

let addFriend
  (key: String)
  (name: String)
  (height: Int64)
  (human: Bool)
  (dob: String)
  (income: Float)
  (age: Int64)
  : Person =
  let dob = (Stdlib.DateTime.parse dob) |> Builtin.unwrap

  let obj =
    Person
      { height = height
        name = name
        human = human
        dob = dob
        income = income
        age = age }

  Stdlib.DB.set obj key PersonDB

let prepFriends () : Unit =
  (let _ = addFriend "ross" "Ross" 73L true "1967-05-12T00:00:00Z" 100.0 33L
   let _ = addFriend "rachel" "Rachel" 65L true "1969-05-05T00:00:00Z" 82.0 27L
   // Note spaces around Chandler, that's to test trim functions
   let _ = addFriend "chandler" " Chandler " 72L true "1969-08-19T10:13:42Z" 83.0 45L
   let _ = addFriend "cat" "GrumpyCat" 10L false "2012-04-04T00:00:00Z" 0.0 9L
   ())

let d (datestr: String) : DateTime =
  (Stdlib.DateTime.parse datestr) |> Builtin.unwrap

let rossDOB () : DateTime = d "1967-05-12T00:00:00Z"

let friendsError (lambda: (Person -> Bool)) : List<Person> =
  let _ = prepFriends ()
  Stdlib.DB.query PersonDB lambda

let friends (lambda: (Person -> Bool)) : List<String> =
  let _ = prepFriends ()

  (Stdlib.DB.query PersonDB lambda)
  |> Stdlib.List.map (fun p -> p.name)
  |> Stdlib.List.sort


// Test standard language features
module FindAll =
  type T2 = { field2: Int64 }
  type T1 = { field1: T2 }

  (friends (fun p -> true)) = [ " Chandler "; "GrumpyCat"; "Rachel"; "Ross" ]

  // equality
  (friends (fun p -> p.name == "Ross")) = [ "Ross" ]
  (friends (fun p -> p.height == 73L)) = [ "Ross" ]
  (friends (fun p -> p.human == false)) = [ "GrumpyCat" ]
  (friends (fun p -> p.income == 100.0)) = [ "Ross" ]
  // rossDOB() is partially evaluated before SQL compilation
  (friends (fun p -> p.dob == (rossDOB ()))) = [ "Ross" ]

  // with condition
  (friends (fun p -> p.height > 3L)) = [ " Chandler "; "GrumpyCat"; "Rachel"; "Ross" ]

  // boolean queries
  (friends (fun p -> p.human)) = [ " Chandler "; "Rachel"; "Ross" ]

  // string inequality works
  (friends (fun p -> p.name != "")) = [ " Chandler "; "GrumpyCat"; "Rachel"; "Ross" ]

  // &&
  (friends (fun p -> p.human && p.height > 66L)) = [ " Chandler "; "Ross" ]

  // ||
  (friends (fun p -> p.human || p.height > 66L)) = [ " Chandler "; "Rachel"; "Ross" ]

  // inlining
  (friends (fun p -> let x = 32L in p.height > x && true)) = [ " Chandler "; "Rachel"; "Ross" ]

  // inlining field access
  (friends (fun p -> let x = p.height in true && x > 32L)) = [ " Chandler "; "Rachel"; "Ross" ]

  // inlining package functions
  (friends (fun p -> let x = p.height in true && Stdlib.Int64.greaterThan x 32L)) = [ " Chandler "; "Rachel"; "Ross" ]

  // inlining user functions
  let userAnd (a: Bool) (b: Bool) : Bool = Stdlib.Bool.``and`` a b

  let userStringContains (user: Person) (str: String) : Bool =
    Stdlib.String.contains user.name str

  let userLessThan (a: Int64) (b: Int64) : Bool =
    Stdlib.Int64.lessThan a b

  let userAdd (a: Int64) (b: Int64) : Int64 = a + b

  (friends (fun p -> userAnd (true || false) (p.height > 66L))) = [ " Chandler "; "Ross" ]

  (friends (fun p -> let a = true in (userAnd (a && a) (p.height > 66L)))) = [ " Chandler "; "Ross" ]

  (friends (fun p -> userAnd p.human true)) = [ " Chandler "; "Rachel"; "Ross" ]

  (friends (fun p -> userStringContains p "Chandler")) = [ " Chandler " ]

  (friends (fun p -> userLessThan p.height 65L)) = [ "GrumpyCat" ]

  (friends (fun p ->
    let a = 1L
    let b = 9L
    (p.height == (userAdd 1L b) && (p.age == b)))) = [ "GrumpyCat" ]

  (friends (fun p ->
    let a = 1L
    let b = 9L
    (p.height == (userAdd (b - 8L) b) && (p.age == b)))) = [ "GrumpyCat" ]

  (friends (fun p ->
    let a = 1L
    let b = 9L
    (p.height == userAdd 6L (b - 5L)))) = [ "GrumpyCat" ]

  (friends (fun p ->
    let a = 1L
    let b = 9L
    (p.height == (userAdd (b - 5L) b) && (p.age == b)))) = []

  (friends (fun p ->
    let a = 1L
    let b = 9L
    let c = userAdd 6L 4L
    (p.height == c) && (p.age == b))) = [ "GrumpyCat" ]


  // Tests for functions that are inlined 2-3 functions deep
  let nestedUserFn (user: Person) (height: Int64) : Bool =
    userAnd user.human (userLessThan user.height height)

  let anotherNestedUserFn (user: Person) (height: Int64) : Bool =
    userAnd
      user.human
      (Stdlib.Int64.lessThan user.height (Stdlib.Int64.add height 1L))


  (friends (fun p -> nestedUserFn p 68L)) = [ "Rachel" ]

  (friends (fun p -> anotherNestedUserFn p 68L)) = [ "Rachel" ]


  // pipes with operators
  (friends (fun p -> p.height |> (*) 2L |> (<) 40L)) = [ "GrumpyCat" ]

  // [test.db query with external variable] with DB Person
  (let x = 11L in friends (fun p -> p.height < x)) = ["GrumpyCat"]

  // fieldaccess
  type IntField = { x: Int64 }

  (friends (fun p -> let obj = IntField { x = 42L } in p.height > obj.x)) = [ " Chandler "; "Rachel"; "Ross" ]

  // nested fieldaccess
  (friends (fun p ->
    let obj = T1 { field1 = T2 { field2 = 42L } } in p.height > obj.field1.field2)) = [ " Chandler "; "Rachel"; "Ross" ]

  // wrong type error
  // TODO: Re-enable once RTQueryCompiler supports type checking.
  // This requires passing DB schema info to validate that variables have
  // compatible types when compared with DB fields.
  // (let x = "not int"
  //  friends (fun p -> p.height > x)) = Builtin.testDerrorSqlMessage
  //   "Variable `x` should be an Int64. However, a String (\"not int\") was passed instead.\n\nExpected: (x: Int64)\nActual: a String: \"not int\""

  // lambda doesnt return a bool
  friendsError (fun p -> "x") = Builtin.testDerrorSqlMessage
    "Incorrect type in String \"x\", expected Bool, but got a String"

  // bad variable name
  friendsError (fun p -> let x = 32L in true && p.height > y) = Builtin.testDerrorSqlMessage
    "This variable is not defined: y"

  // sql injection
  (friendsError (fun p -> "; select * from users;" == p.name)) = []


module CompiledFunctions =
  (friends (fun p -> Stdlib.Float.lessThan 90.0 p.income)) = [ "Ross" ]

  (friends (fun p -> Stdlib.Float.lessThanOrEqualTo p.income 82.10)) = [ "GrumpyCat"
                                                                         "Rachel" ]

  (friends (fun p -> Stdlib.Float.greaterThan p.income 90.0)) = [ "Ross" ]


  (friends (fun p -> Stdlib.Float.divide p.income 2.0 == 50.0)) = [ "Ross" ]

  (friends (fun p -> Stdlib.Float.multiply p.income 2.0 == 200.0)) = [ "Ross" ]

  (friends (fun p -> Stdlib.Float.power p.income 2.0 == 10000.0)) = [ "Ross" ]

  (friends (fun p -> Stdlib.Float.add p.income 0.0 == 0.0)) = [ "GrumpyCat" ]

  (friends (fun p -> Stdlib.Float.subtract p.income 3.0 == 80.0)) = [ " Chandler " ]


  (friends (fun p -> Stdlib.Float.greaterThanOrEqualTo 82.10 p.income)) = [ "GrumpyCat"
                                                                            "Rachel" ]

  (friends (fun p -> Stdlib.Int64.lessThanOrEqualTo p.height 65L)) = [ "GrumpyCat"
                                                                       "Rachel" ]

  (friends (fun p -> Stdlib.Int64.lessThan p.height 65L)) = [ "GrumpyCat" ]

  (friends (fun p -> Stdlib.Int64.greaterThanOrEqualTo p.height 65L)) = [ " Chandler "
                                                                          "Rachel"
                                                                          "Ross" ]

  (friends (fun p -> Stdlib.Int64.greaterThan p.height 65L)) = [ " Chandler "
                                                                 "Ross" ]

  (friends (fun p -> Stdlib.Int64.add p.height 1L == 11L)) = [ "GrumpyCat" ]

  (friends (fun p -> Stdlib.Int64.subtract p.height 3L == 69L)) = [ " Chandler " ]

  (friends (fun p -> Stdlib.Int64.multiply p.height 2L == 146L)) = [ "Ross" ]

  (friends (fun p -> Stdlib.Int64.divide p.height 2L == 5L)) = [ "GrumpyCat" ]

  (friends (fun p -> Stdlib.Int64.power p.height 2L == 100L)) = [ "GrumpyCat" ]

  (friends (fun p -> Stdlib.String.toLowercase p.name == "rachel")) = [ "Rachel" ]
  (friends (fun p -> Stdlib.String.toUppercase p.name == "RACHEL")) = [ "Rachel" ]
  // TODO: SQLite doesn't have a REVERSE function
  // (friends (fun p -> Stdlib.String.reverse p.name == "lehcaR")) = [ "Rachel" ]

  // TODO: SQLite's LENGTH counts characters, not EGCs so we made it non queriable for now
  // (friends (fun p -> Stdlib.String.length p.name > 5L)) = [ " Chandler "
  //                                                           "GrumpyCat"
  //                                                           "Rachel" ]
  (friends (fun p -> Stdlib.String.contains p.name "ROSS")) = []

  (friends (fun p -> Stdlib.String.contains p.name "R")) = [ "Rachel"; "Ross" ]

  (friends (fun p -> Stdlib.String.contains p.name "ZZZ")) = []

  (friends (fun p -> Stdlib.String.contains p.name "")) = [ " Chandler "
                                                            "GrumpyCat"
                                                            "Rachel"
                                                            "Ross" ]

  (friends (fun p -> Stdlib.String.replaceAll p.name "handle" "he" == " Cher ")) = [ " Chandler " ]

  (friends (fun p -> Stdlib.String.replaceAll p.name " " "Xx" == "XxChandlerXx")) = [ " Chandler " ]

  (friends (fun p ->
    Stdlib.String.replaceAll p.name "xxx" "notUsed" == " Chandler ")) = [ " Chandler " ]

  (friends (fun p -> Stdlib.String.trim p.name == "Chandler")) = [ " Chandler " ]

  (friends (fun p -> Stdlib.String.trimStart p.name == "Chandler ")) = [ " Chandler " ]

  (friends (fun p -> Stdlib.String.trimEnd p.name == " Chandler")) = [ " Chandler " ]
  (friends (fun p -> Stdlib.Bool.not p.human)) = [ "GrumpyCat" ]

  (friends (fun p -> Stdlib.Bool.``and`` p.human p.human)) = [ " Chandler "
                                                               "Rachel"
                                                               "Ross" ]

  (friends (fun p -> Stdlib.Bool.``or`` p.human p.human)) = [ " Chandler "
                                                              "Rachel"
                                                              "Ross" ]

  (friends (fun p -> Stdlib.Bool.not (Stdlib.Bool.``and`` p.human p.human))) = [ "GrumpyCat" ]

  (friends (fun p -> Stdlib.Bool.``and`` p.human (Stdlib.Bool.not p.human))) = []

  (friends (fun p -> Stdlib.Bool.``or`` p.human (Stdlib.Bool.not p.human))) = [ " Chandler "
                                                                                "GrumpyCat"
                                                                                "Rachel"
                                                                                "Ross" ]

  // TODO: SQLite doesn't have a REVERSE function
  // (friends (fun p -> Stdlib.String.reverse p.name == "lehcaR")) = [ "Rachel" ]

  // (friends (fun p ->
  //   Stdlib.String.reverse (
  //     (Stdlib.String.toLowercase p.name) |> Stdlib.String.toUppercase
  //   )
  //   == "LEHCAR")) = [ "Rachel" ]

  (friends (fun p ->
    Stdlib.DateTime.lessThanOrEqualTo p.dob (d "2000-01-01T01:02:03Z"))) = [ " Chandler "
                                                                             "Rachel"
                                                                             "Ross" ]

  (friends (fun p -> Stdlib.DateTime.lessThanOrEqualTo p.dob (rossDOB ()))) = [ "Ross" ]

  (friends (fun p -> Stdlib.DateTime.lessThan p.dob (rossDOB ()))) = []

  (friends (fun p ->
    Stdlib.DateTime.greaterThanOrEqualTo p.dob (d "2000-01-01T01:02:03Z"))) = [ "GrumpyCat" ]

  (friends (fun p -> Stdlib.DateTime.greaterThanOrEqualTo p.dob (rossDOB ()))) = [ " Chandler "
                                                                                   "GrumpyCat"
                                                                                   "Rachel"
                                                                                   "Ross" ]

  (friends (fun p -> Stdlib.DateTime.greaterThan p.dob (rossDOB ()))) = [ " Chandler "
                                                                          "GrumpyCat"
                                                                          "Rachel" ]

  (friends (fun p ->
    Stdlib.DateTime.lessThanOrEqualTo
      p.dob
      (Stdlib.DateTime.addSeconds (Stdlib.DateTime.now ()) 1L))) = [ " Chandler "
                                                                     "GrumpyCat"
                                                                     "Rachel"
                                                                     "Ross" ]

  (friends (fun p ->
    Stdlib.DateTime.lessThanOrEqualTo
      p.dob
      (Stdlib.DateTime.subtractSeconds (Stdlib.DateTime.now ()) 1L))) = [ " Chandler "
                                                                          "GrumpyCat"
                                                                          "Rachel"
                                                                          "Ross" ]

  // TODO: These use Postgres-specific date_part/date_trunc functions - not supported in SQLite
  // (friends (fun p ->
  //   Stdlib.DateTime.atStartOfDay p.dob == (d "1969-08-19T00:00:00Z"))) = [ " Chandler " ]

  // (friends (fun p -> Stdlib.DateTime.hour p.dob == 10L)) = [ " Chandler " ]
  // (friends (fun p -> Stdlib.DateTime.day p.dob == 19L)) = [ " Chandler " ]
  // (friends (fun p -> Stdlib.DateTime.minute p.dob == 13L)) = [ " Chandler " ]
  // (friends (fun p -> Stdlib.DateTime.month p.dob == 8L)) = [ " Chandler " ]
  // (friends (fun p -> Stdlib.DateTime.second p.dob == 42L)) = [ " Chandler " ]

  // (friends (fun p -> Stdlib.DateTime.year p.dob == 1969L)) = [ " Chandler "
  //                                                              "Rachel" ]

  // Test package constants
  // Bool
  (friends (fun p ->
    Stdlib.Bool.``and`` p.human Darklang.Test.Values.boolValue)) = [ " Chandler "
                                                                     "Rachel"
                                                                     "Ross" ]

  // Float
  (friends (fun p ->
    Stdlib.Float.lessThanOrEqualTo
      p.income
      Darklang.Test.Values.floatValue)) = [ "GrumpyCat" ]

  // Int64
  (friends (fun p ->
    Stdlib.Int64.greaterThanOrEqualTo
      p.height
      Darklang.Test.Values.intValue)) = [ " Chandler "
                                          "GrumpyCat"
                                          "Rachel"
                                          "Ross" ]

  // String
  (friends (fun p ->
    Stdlib.String.contains p.name Darklang.Test.Values.stringValue)) = []


module PartialEvaluation =
  type A = { a: Int64 }
  type Z = { z: A }
  type Y = { y: Z }
  type AL = { a: List<Int64> }
  type ZL = { z: AL }
  type YL = { y: ZL }

  // fieldAccesses outside query
  (let _ = prepFriends ()
   let x = Y { y = Z { z = A { a = 5L } } }

   ((Stdlib.DB.query PersonDB (fun p -> x.y.z.a < p.height))
    |> Stdlib.List.map (fun p -> p.name)
    |> Stdlib.List.sort)) = [ " Chandler "; "GrumpyCat"; "Rachel"; "Ross" ]

  // fieldAccesses inside query
  (friends (fun p -> let x = Y { y = Z { z = A { a = 5L } } } in x.y.z.a < p.height)) = [ " Chandler "
                                                                                          "GrumpyCat"
                                                                                          "Rachel"
                                                                                          "Ross" ]

  (friends (fun p ->
    let x = YL { y = ZL { z = AL { a = [ 1L; 2L; 3L; 4L; 5L ] } } }
    (Stdlib.List.length x.y.z.a) < p.height)) = [ " Chandler "; "GrumpyCat"; "Rachel"; "Ross" ]

  // tuple destructuring inside query - requires tuple pattern support
  (friends (fun p ->
    let (a0, a1, a2, a3, ((b, c), d)) = (0L, 1L, 2L, 3L, ((5L, "aa"), 'a'))
    b < p.height)) = [ " Chandler "; "GrumpyCat"; "Rachel"; "Ross" ]


module QueryOne =
  (let _ = prepFriends () in Stdlib.DB.queryOne PersonDB (fun p -> p.name == "bob")) = Stdlib.Option.Option.None

  ((let _ = prepFriends ()
    Stdlib.DB.queryOne PersonDB (fun p -> p.name == "Rachel"))
   |> Stdlib.Option.map (fun v -> v.name)) = Stdlib.Option.Option.Some "Rachel"


  // interpolated - outer let binding is partially evaluated
  ((let _ = prepFriends ()
    let test = "ache"
    Stdlib.DB.queryOne PersonDB (fun p -> p.name == $"R{test}l"))
   |> Stdlib.Option.map (fun v -> v.name)) = Stdlib.Option.Option.Some "Rachel"


module QueryWithKey =
  // none
  (let _ = prepFriends ()
   Stdlib.DB.queryWithKey PersonDB (fun p -> p.name == "bob")) = Dict { }

  // one
  ((let _ = prepFriends ()
    Stdlib.DB.queryWithKey PersonDB (fun p -> p.name == "Rachel"))
   |> Stdlib.Dict.toList
   |> Stdlib.List.map (fun v -> (Stdlib.Tuple2.second v).name)) = [ "Rachel" ]

module QueryCount =
  // none
  (let _ = prepFriends ()
   Stdlib.DB.queryCount PersonDB (fun p -> p.name == "bob")) = 0L

  // one
  (let _ = prepFriends ()
   Stdlib.DB.queryCount PersonDB (fun p -> p.height > 3L)) = 4L


((Stdlib.DB.generateKey ()) |> Stdlib.String.length) = 36L