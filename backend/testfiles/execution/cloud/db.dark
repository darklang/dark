// really simple data stores of Records
type X = { x: String }

[<DB>]
type XDB = X


type Z = { x: Char }

[<DB>]
type ZDB = Z


type XY = { x: String; y: String }

[<DB>]
type XYDB = XY


type SortedX = { x: String; sortBy: Int64 }

[<DB>]
type SortedXDB = SortedX

// simple data stores of Enums
// , and Records containing Enums

type MyEnum =
  | A
  | B
  | C

type MyEnum2 =
  | D
  | E
  | F of MyEnum

type EnumTestRecord = { x: String; y: MyEnum }

[<DB>]
type TestEnumDB = EnumTestRecord

[<DB>]
type TestEnumDB2 = MyEnum

[<DB>]
type TestEnumDB3 = MyEnum2


// Nested field accessing
type VeryInnerRecord = { age: Int64 }
type AliasOfVeryInnerRecord = VeryInnerRecord
type InnerRecord = { numbers: AliasOfVeryInnerRecord }
type OuterRecord = { name: String; details: InnerRecord }
type AliasOfRecord = OuterRecord

[<DB>]
type TestNestedRecord = OuterRecord

[<DB>]
type TestNestedAliasRecord = AliasOfRecord

module NestedRecordFieldAccess =
  // can use lambda like (fun p -> p.details.numbers.age)
  (let _ =
    Stdlib.DB.set
      (OuterRecord
        { name = "joe"
          details = InnerRecord { numbers = AliasOfVeryInnerRecord { age = 41L } } }
      )
      "jjj"
      TestNestedRecord

   let _ =
     Stdlib.DB.set
        (OuterRecord
          { name = "frank"
            details = InnerRecord { numbers = VeryInnerRecord { age = 22L } } }
        )
        "fff"
        TestNestedRecord

   let shouldBeJustJoe =
     Stdlib.DB.query TestNestedRecord (fun p -> p.details.numbers.age == 41L)

   Stdlib.List.length shouldBeJustJoe)
  == 1L


  // same as above, but with aliases
  (let _ =
    Stdlib.DB.set
      (AliasOfRecord
        { name = "jeremy"
          details = InnerRecord { numbers = VeryInnerRecord { age = 38L } } }
      )
      "ignored"
      TestNestedAliasRecord

   let _ =
     Stdlib.DB.set
        (AliasOfRecord
          { name = "josephine"
            details = InnerRecord { numbers = AliasOfVeryInnerRecord { age = 29L } } }
        )
       "alsoIgnored"
       TestNestedAliasRecord

   let shouldBeJustJeremy =
     Stdlib.DB.query TestNestedAliasRecord (fun p -> p.details.numbers.age == 38L)

   Stdlib.List.length shouldBeJustJeremy)
  == 1L


// Query data from a type with generics
type GenericThing<'thing> = { name: 'thing }
type RecordWithGenericThing = GenericThing<String>

[<DB>]
type TestRecordWithGenericThing = RecordWithGenericThing

module AccessDataInGenericField =
  (let _ =
    Stdlib.DB.set
      (RecordWithGenericThing { name = "joe" })
      "jjj"
      TestRecordWithGenericThing

   let _ =
     Stdlib.DB.set
       (RecordWithGenericThing { name = "frank" })
       "fff"
       TestRecordWithGenericThing

   Stdlib.DB.query TestRecordWithGenericThing (fun p -> p.name == "joe"))
  == [ RecordWithGenericThing { name = "joe" } ]

module AccessRecordInGenericField =
  type RecordThing = { nested: String }

  [<DB>]
  type TestDB = GenericThing<RecordThing>

  (let _ =
    Stdlib.DB.set
      (GenericThing { name = RecordThing { nested = "joe" } })
      "jjj"
      TestDB

   let _ =
     Stdlib.DB.set
       (GenericThing { name = RecordThing { nested = "frank" } })
       "fff"
       TestDB

   let nestedValue = RecordThing { nested = "joe" }

   Stdlib.DB.query TestDB (fun p -> p.name == nestedValue))
  == [ GenericThing { name = RecordThing { nested = "joe" } } ]


module AccessEnumInGenericField =
  type EnumThing =
    | A of String

  [<DB>]
  type TestDB = GenericThing<EnumThing>

  (let _ = Stdlib.DB.set (GenericThing { name = EnumThing.A("joe") }) "jjj" TestDB
   let _ = Stdlib.DB.set (GenericThing { name = EnumThing.A("frank") }) "fff" TestDB

   let nestedValue = EnumThing.A("joe")

   Stdlib.DB.query TestDB (fun p -> p.name == nestedValue))
  == [ GenericThing { name = EnumThing.A("joe") } ]


module AddToTestEnumDBs =
  (let test1 =
    Stdlib.DB.set (EnumTestRecord { x = "hello"; y = MyEnum.A() }) "test1" TestEnumDB

   let test2 =
     Stdlib.DB.set
       (EnumTestRecord { x = "goodbye"; y = MyEnum.B() })
       "test2"
       TestEnumDB

   (Stdlib.DB.getAll TestEnumDB) |> Stdlib.List.sort
  ) == [ EnumTestRecord{ x = "goodbye"; y = MyEnum.B() }; EnumTestRecord { x = "hello"; y = MyEnum.A() } ]

  (let test1 =
    Stdlib.DB.set (EnumTestRecord { x = "hello"; y = MyEnum.A() }) "test1" TestEnumDB

   let test2 =
     Stdlib.DB.set
       (EnumTestRecord { x = "goodbye"; y = MyEnum.B() })
       "test2"
       TestEnumDB

   (Stdlib.DB.get "test1" TestEnumDB)
  ) == Stdlib.Option.Option.Some(EnumTestRecord { x = "hello"; y = MyEnum.A() })

  (let test1 = Stdlib.DB.set MyEnum.A() "test1" TestEnumDB2
   let test2 = Stdlib.DB.set MyEnum.B() "test2" TestEnumDB2
   (Stdlib.DB.getAll TestEnumDB2) |> Stdlib.List.sort
  ) == [ MyEnum.A(); MyEnum.B() ]

  (let test1 = Stdlib.DB.set MyEnum.C() "test1" TestEnumDB2
   let test2 = Stdlib.DB.set MyEnum.B() "test2" TestEnumDB2
   (Stdlib.DB.get "test1" TestEnumDB2)
  ) == Stdlib.Option.Option.Some(MyEnum.C())

  (let test1 = Stdlib.DB.set MyEnum2.D() "test1" TestEnumDB3
   let test2 = Stdlib.DB.set MyEnum2.E() "test2" TestEnumDB3
   let test3 = Stdlib.DB.set (MyEnum2.F(MyEnum.A())) "test3" TestEnumDB3
   (Stdlib.DB.getAll TestEnumDB3) |> Stdlib.List.sort
  ) == [ MyEnum2.D(); MyEnum2.E(); MyEnum2.F(MyEnum.A()) ]

  (let testQuery =
    Stdlib.DB.set (EnumTestRecord { x = "hello"; y = MyEnum.A() }) "test1" TestEnumDB

   (Stdlib.DB.query TestEnumDB (fun p -> p.x == "hello"))
  ) == [ EnumTestRecord { x = "hello"; y = MyEnum.A() } ]

  (let testQuery =
    Stdlib.DB.set (EnumTestRecord { x = "hello"; y = MyEnum.A() }) "test1" TestEnumDB

   (Stdlib.DB.query TestEnumDB (fun p -> p.y == MyEnum.A()))
  ) == [ EnumTestRecord { x = "hello"; y = MyEnum.A() } ]



type MyTlid =
  { mytlid: PACKAGE.Darklang.LanguageTools.TLID }

[<DB>]
type MyTlidDB = MyTlid

module AddToTest =
  (let test = Stdlib.DB.set (MyTlid { mytlid = 1234UL }) "test" MyTlidDB
   (Stdlib.DB.getAll MyTlidDB)) == [ MyTlid { mytlid = 1234UL } ]

module Roundtrip =
  type Sample =
    { iNsEnSiTiVe: String
      // ``ALLCAPS``: Int64
      int: Int64
      uint64: UInt64
      int8: Int8
      uint8: UInt8
      int16: Int16
      uint16: UInt16
      int32: Int32
      uint32: UInt32
      int128: Int128
      uint128: UInt128
      float: Float
      negZero: Float
      nan: Float
      infinity: Float
      negInfinity: Float
      true: Bool
      false: Bool
      char: Char
      emojiChar: Char
      uuid: Uuid
      resultOk: Stdlib.Result.Result<Int64, String>
      resultError: Stdlib.Result.Result<Int64, String>
      option: Stdlib.Option.Option<Int64>
      tuple: (Int64 * String)
      record: MyTlid
      list: List<Int64>
      datetime: DateTime
      unit: Unit }

  [<DB>]
  type SampleDB = Sample

  let sample () : Sample =
    Sample {
      iNsEnSiTiVe = "iNsEnSiTiVe"
      // ``ALLCAPS`` = 1L
      int = 2L
      uint64 = 2UL
      int8 = 2y
      uint8 = 2uy
      int16 = 2s
      uint16 = 2us
      int32 = 2l
      uint32 = 2ul
      int128 = 170141183460469231731687303715884105727Q
      uint128 = 340282366920938463463374607431768211455Z
      float = 3.0
      negZero = -0.0
      nan = (Builtin.testNan)
      infinity = (Builtin.testInfinity)
      negInfinity = (Builtin.testNegativeInfinity)
      true = true
      false = false
      list = [ 1L; 2L; 3L ]
      char = 'c'
      resultOk = Stdlib.Result.Result.Ok(5L)
      resultError = Stdlib.Result.Result.Error("test")
      option = Stdlib.Option.Option.Some(5L)
      record = MyTlid { mytlid = 1234UL }
      tuple = (1L, "hello")
      emojiChar = ((Builtin.testToChar "👍") |> Builtin.unwrap)
      uuid = ((Stdlib.Uuid.parse "00000050-0000-0000-0000-000000000000") |> Builtin.unwrap)
      datetime = ((Stdlib.DateTime.parse "2020-01-01T00:00:00Z") |> Builtin.unwrap)
      unit = ()
    }

  let otherSample () : Sample =
    Sample{
      iNsEnSiTiVe = "normal"
      // ``ALLCAPS`` = 2L
      int = 3L
      uint64 = 3UL
      int8 = 3y
      uint8 = 3uy
      int16 = 4s
      uint16 = 4us
      int32 = 4l
      uint32 = 4ul
      int128 = -170141183460469231731687303715884105728Q
      uint128 = 0Z
      float = 4.0
      negZero = -1.0
      nan = 0.0
      infinity = 5.4
      negInfinity = -385.33
      true = false
      false = true
      list = [ 1L; 3L; 45L ]
      char = 'd'
      resultOk = Stdlib.Result.Result.Ok(6L)
      resultError = Stdlib.Result.Result.Error("other test")
      option = Stdlib.Option.Option.None()
      record = MyTlid { mytlid = 1235UL }
      tuple = (2L, "goodbye")
      emojiChar = 'e'
      uuid = ((Stdlib.Uuid.parse "55555555-5555-5555-5555-555555555555") |> Builtin.unwrap)
      datetime = ((Stdlib.DateTime.parse "2011-11-11T11:11:11Z") |> Builtin.unwrap)
      unit = ()
    }

  // TODO: Add roundtrip for bytes (Bytes values not supported yet)
  (let v = sample ()
   let z = Stdlib.DB.set v "all" SampleDB
   (z, Stdlib.DB.get "all" SampleDB)
  ) == (sample (), Stdlib.Option.Option.Some(sample ()))


  module QueryEquality =
    let fetch (fn: 'a -> Bool) : List<'a> =
      let z = Stdlib.DB.set (sample ()) "sample" SampleDB
      let z = Stdlib.DB.set (otherSample ()) "other" SampleDB
      Stdlib.DB.query SampleDB fn

    // invalid type comparisons errors
    // these work, but the DError has a random string in it that we can't match
    // fetch (fun p -> 5 == "str") =
    //   Builtin.testDerrorSqlMessage "Incorrect type in variable, expected Bool, but got a Error"
    // fetch (fun p -> 5 != "str") =
    //   Builtin.testDerrorSqlMessage "Incorrect type in variable, expected Bool, but got a Error"

    fetch (fun p -> p.int == "str") == Builtin.testDerrorSqlMessage
      "Incorrect type in String \"str\", expected Int64, but got a String"

    fetch (fun p -> p.int != "str") == Builtin.testDerrorSqlMessage
      "Incorrect type in String \"str\", expected Int64, but got a String"

    fetch (fun p -> "str" == p.int) == Builtin.testDerrorSqlMessage
      "Incorrect type in int, expected String, but got a Int64"

    fetch (fun p -> "str" == p.int) == Builtin.testDerrorSqlMessage
      "Incorrect type in int, expected String, but got a Int64"

    fetch (fun p -> p.iNsEnSiTiVe == "iNsEnSiTiVe") == [ sample () ]
    fetch (fun p -> p.iNsEnSiTiVe != "iNsEnSiTiVe") == [ otherSample () ]
    fetch (fun p -> p.iNsEnSiTiVe == "nothing") == []

    // fetch (fun p -> p.``ALLCAPS`` == 1L) == [ sample () ]
    // fetch (fun p -> p.``ALLCAPS`` != 1L) == [ otherSample () ]
    // fetch (fun p -> p.``ALLCAPS`` == 1000L) == []

    fetch (fun p -> p.int == 2L) == [ sample () ]
    fetch (fun p -> p.int != 2L) == [ otherSample () ]
    fetch (fun p -> p.int == 200L) == []

    fetch (fun p -> p.uint64 == 2UL) == [ sample () ]
    fetch (fun p -> p.uint64 != 2UL) == [ otherSample () ]
    fetch (fun p -> p.uint64 == 200UL) == []

    fetch (fun p -> p.int8 == 2y) == [ sample () ]
    fetch (fun p -> p.int8 != 2y) == [ otherSample () ]
    fetch (fun p -> p.int8 == 100y) == []

    fetch (fun p -> p.uint8 == 2uy) == [ sample () ]
    fetch (fun p -> p.uint8 != 2uy) == [ otherSample () ]
    fetch (fun p -> p.uint8 == 100uy) == []

    fetch (fun p -> p.int16 == 2s) == [ sample () ]
    fetch (fun p -> p.int16 != 2s) == [ otherSample () ]
    fetch (fun p -> p.int16 == 100s) == []

    fetch (fun p -> p.uint16 == 2us) == [ sample () ]
    fetch (fun p -> p.uint16 != 2us) == [ otherSample () ]
    fetch (fun p -> p.uint16 == 100us) == []

    fetch (fun p -> p.int32 == 2l) == [ sample () ]
    fetch (fun p -> p.int32 != 2l) == [ otherSample () ]
    fetch (fun p -> p.int32 == 100l) == []

    fetch (fun p -> p.uint32 == 2ul) == [ sample () ]
    fetch (fun p -> p.uint32 != 2ul) == [ otherSample () ]
    fetch (fun p -> p.uint32 == 100ul) == []

    fetch (fun p -> p.int128 == 170141183460469231731687303715884105727Q) == [ sample () ]

    fetch (fun p -> p.int128 != 170141183460469231731687303715884105727Q) == [ otherSample () ]

    fetch (fun p -> p.int128 == 100Q) == []

    fetch (fun p -> p.uint128 == 340282366920938463463374607431768211455Z) == [ sample () ]

    fetch (fun p -> p.uint128 != 340282366920938463463374607431768211455Z) == [ otherSample () ]

    fetch (fun p -> p.uint128 == 100Z) == []

    fetch (fun p -> p.float == 3.0) == [ sample () ]
    fetch (fun p -> p.float != 3.0) == [ otherSample () ]
    fetch (fun p -> p.float == 30.0) == []

    fetch (fun p -> p.negZero == -0.0) == [ sample () ]
    fetch (fun p -> p.negZero != -0.0) == [ otherSample () ]
    fetch (fun p -> p.negZero == 19000.0) == []

    // CLEANUP: nan shouldn't be equal
    fetch (fun p -> p.nan == Builtin.testNan) == [ sample () ]
    fetch (fun p -> p.nan != Builtin.testNan) == [ otherSample () ]
    fetch (fun p -> p.nan == 14.0) == []

    fetch (fun p -> p.infinity == Builtin.testInfinity) == [ sample () ]
    fetch (fun p -> p.infinity != Builtin.testInfinity) == [ otherSample () ]
    fetch (fun p -> p.infinity == 1.0) == []

    fetch (fun p -> p.negInfinity == Builtin.testNegativeInfinity) == [ sample () ]

    fetch (fun p -> p.negInfinity != Builtin.testNegativeInfinity) == [ otherSample () ]

    fetch (fun p -> p.negInfinity == 1.0) == []

    fetch (fun p -> p.true == true) == [ sample () ]
    fetch (fun p -> p.true != true) == [ otherSample () ]

    fetch (fun p -> p.false == false) == [ sample () ]
    fetch (fun p -> p.false != false) == [ otherSample () ]

    // A bug in postgresql jsonb support prevents this from working
    // fetch (fun p -> p.list == [1;2;3]) = [sample ()]
    // fetch (fun p -> p.list != [1;2;3]) = [otherSample ()]
    // fetch (fun p -> p.list == []) = []

    fetch (fun p -> p.char == 'c') == [ sample () ]
    fetch (fun p -> p.char != 'c') == [ otherSample () ]
    fetch (fun p -> p.char == 'x') == []

    fetch (fun p -> p.emojiChar == ((Builtin.testToChar "👍") |> Builtin.unwrap)) == [ sample () ]

    fetch (fun p -> p.emojiChar != ((Builtin.testToChar "👍") |> Builtin.unwrap)) == [ otherSample () ]

    fetch (fun p -> p.emojiChar == 'x') == []

    fetch (fun p ->
      p.uuid
      == ((Stdlib.Uuid.parse "00000050-0000-0000-0000-000000000000")
          |> Builtin.unwrap)) == [ sample () ]

    fetch (fun p ->
      p.uuid
      != ((Stdlib.Uuid.parse "00000050-0000-0000-0000-000000000000")
          |> Builtin.unwrap)) == [ otherSample () ]

    fetch (fun p ->
      p.uuid
      == ((Stdlib.Uuid.parse "11111111-1111-1111-1111-000000000000")
          |> Builtin.unwrap)) == []

    fetch (fun p ->
      p.datetime
      == ((Stdlib.DateTime.parse "2020-01-01T00:00:00Z") |> Builtin.unwrap)) == [ sample () ]

    fetch (fun p ->
      p.datetime
      != ((Stdlib.DateTime.parse "2020-01-01T00:00:00Z") |> Builtin.unwrap)) == [ otherSample () ]

    fetch (fun p ->
      p.datetime
      == ((Stdlib.DateTime.parse "2019-12-31T23:59:59Z") |> Builtin.unwrap)) == []

    (fetch (fun p -> p.unit == ())) |> Stdlib.List.sortBy (fun v -> v.int) == [ sample (); otherSample () ]

    fetch (fun p -> p.unit != ()) == []

    // Test equality for two different function results - this tests TVariable types, esp checking that we keep track of them correctly
    fetch (fun p ->
      ((Stdlib.Uuid.parse "00000050-0000-0000-0000-000000000000") |> Builtin.unwrap)
      == p.uuid) == [ sample () ]

    ((fetch (fun p ->
      ((Stdlib.Uuid.parse "00000050-0000-0000-0000-000000000000") |> Builtin.unwrap)
      == ((Stdlib.Uuid.parse "00000050-0000-0000-0000-000000000000")
          |> Builtin.unwrap)))
     |> Stdlib.List.length) == 2L



module ValueMissingColumnGivesGoodError =
  // TYPESCLEANUP: can we test a missing column against the DB anymore?
  // (Stdlib.DB.set (XY { x = "x"; y = "v" }) "i" XDB) = Builtin.Test.runtimeError "Found but did not expect: [y]"

  (Stdlib.DB.set (XY { x = "x"; y = "v" }) "i" XDB) == Builtin.testDerrorMessage
    "DB XDB's value should be a X. However, a XY (XY {  x: ...) was passed instead.\n\nExpected: X\nActual: a XY: XY {\n  x: \"x\",\n  y: \"v\"\n}"


module SetDoesUpsert =
  (let old = Stdlib.DB.set (X { x = "hello" }) "hello" XDB
   let newval = Stdlib.DB.set (X { x = "goodbye" }) "hello" XDB
   Stdlib.DB.getAllWithKeys XDB) == Dict { hello = X { x = "goodbye" } }

module SetCharUpserts =
  (let old = Stdlib.DB.set (Z { x = 'a' }) "a" ZDB
   let newval = Stdlib.DB.set (Z { x = 'b' }) "a" ZDB
   Stdlib.DB.getAllWithKeys ZDB) == Dict { a = Z { x = 'b' } }



module Get =
  // return none for empty store
  (Stdlib.DB.get "lol" XDB) == Stdlib.Option.Option.None()

  // return none for invalid key
  (let _ = Stdlib.DB.set (X { x = "hello" }) "key" XDB
   Stdlib.DB.get "lol" XDB) == Stdlib.Option.Option.None()

  // returns single value
  (let _ = Stdlib.DB.set (X { x = "hello" }) "key" XDB
   Stdlib.DB.get "key" XDB) == PACKAGE.Darklang.Stdlib.Option.Option.Some(X { x = "hello" })

  // returns correct value given reassigned entry
  (let _ = Stdlib.DB.set (X { x = "hello" }) "key" XDB
   let _ = Stdlib.DB.set (X { x = "goodbye" }) "key" XDB
   Stdlib.DB.get "key" XDB) == Stdlib.Option.Option.Some(X { x = "goodbye" })

  // returns value given multiple entries
  (let _ = Stdlib.DB.set (X { x = "pancake" }) "key1" XDB
   let _ = Stdlib.DB.set (X { x = "waffle" }) "key2" XDB
   let _ = Stdlib.DB.set (X { x = "scone" }) "key3" XDB
   Stdlib.DB.get "key2" XDB) == Stdlib.Option.Option.Some(X { x = "waffle" })


module Params =
  type Param<'a> = { x: 'a; b: Int64 }

  [<DB>]
  type ParamDB = Param<String>

  (let _ = Stdlib.DB.set (Param { x = "hello"; b = 5L }) "key" ParamDB
   Stdlib.DB.get "key" ParamDB) == Stdlib.Option.Option.Some(
    Param { x = "hello"; b = 5L }
  )



module GetAll =
  (let one = Stdlib.DB.set (SortedX { x = "hello"; sortBy = 0L }) "one" SortedXDB

   let two = Stdlib.DB.set (SortedX { x = "goodbye"; sortBy = 1L }) "two" SortedXDB

   let three = Stdlib.DB.set (SortedX { x = "howdy"; sortBy = 2L }) "three" SortedXDB

   (Stdlib.DB.getAll SortedXDB) |> Stdlib.List.sortBy (fun x -> x.sortBy))
    == [(SortedX { x = "hello"; sortBy = 0L })
        (SortedX { x = "goodbye"; sortBy = 1L })
        (SortedX { x = "howdy"; sortBy = 2L }) ]


module GetAllKeys =
  (let one = Stdlib.DB.set (X { x = "hello" }) "one" XDB
   let two = Stdlib.DB.set (X { x = "goodbye" }) "two" XDB
   (Stdlib.DB.keys XDB) |> Stdlib.List.sort) == [ "one"; "two" ]


module GetAllWithKeys =
  (let one = Stdlib.DB.set (X { x = "hello" }) "one" XDB
   let two = Stdlib.DB.set (X { x = "goodbye" }) "two" XDB
   Stdlib.DB.getAllWithKeys XDB) == Dict
    { one = X { x = "hello" }
      two = X { x = "goodbye" } }


module GetManyWithKeys =
  (let one = Stdlib.DB.set (X { x = "hello" }) "one" XDB
   let two = Stdlib.DB.set (X { x = "goodbye" }) "two" XDB
   Stdlib.DB.getManyWithKeys [ "one"; "two" ] XDB) == Dict
    { one = (X { x = "hello" })
      two = (X { x = "goodbye" }) }


module GetExisting =
  (let one = Stdlib.DB.set (X { x = "hello" }) "one" XDB
   let two = Stdlib.DB.set (X { x = "goodbye" }) "two" XDB
   Stdlib.DB.getExisting [ "three"; "two" ] XDB) == [ (X { x = "goodbye" }) ]


module GetMany =
  (let one = Stdlib.DB.set (X { x = "hello" }) "one" XDB
   let two = Stdlib.DB.set (X { x = "goodbye" }) "two" XDB
   Stdlib.DB.getMany [ "three"; "two" ] XDB) == Stdlib.Option.Option.None()

  (let one = Stdlib.DB.set (X { x = "hello" }) "one" XDB
   let two = Stdlib.DB.set (X { x = "goodbye" }) "two" XDB

   (Stdlib.DB.getMany [ "one"; "two" ] XDB)
   |> Builtin.unwrap
   |> Stdlib.List.sortBy (fun v -> v.x)) == [ (X { x = "goodbye" })
                                              (X { x = "hello" }) ]


module Delete =
  (let one = Stdlib.DB.set (X { x = "hello" }) "one" XDB
   let delete = Stdlib.DB.delete "one" XDB
   Stdlib.DB.getAllWithKeys XDB) == Dict { }

  // delete nothing
  (let one = Stdlib.DB.set (X { x = "hello" }) "one" XDB
   let delete = Stdlib.DB.delete "two" XDB
   Stdlib.DB.getAllWithKeys XDB) == Dict { one = (X { x = "hello" }) }

  // deletes only one
  (let one = Stdlib.DB.set (X { x = "hello" }) "one" XDB
   let two = Stdlib.DB.set (X { x = "goodbye" }) "two" XDB
   let delete = Stdlib.DB.delete "one" XDB
   Stdlib.DB.getAllWithKeys XDB) == Dict { two = (X { x = "goodbye" }) }

module DeleteAll =
  (let one = Stdlib.DB.set (X { x = "hello" }) "one" XDB
   let delete = Stdlib.DB.deleteAll XDB
   Stdlib.DB.getAll XDB) == []

  // deletes all
  (let one = Stdlib.DB.set (X { x = "hello" }) "one" XDB
   let two = Stdlib.DB.set (X { x = "goodbye" }) "two" XDB
   let delete = Stdlib.DB.deleteAll XDB
   Stdlib.DB.getAll XDB) == []

  // when empty
  (let delete = Stdlib.DB.deleteAll XDB
   Stdlib.DB.getAll XDB) == []

module Count =
  // empty
  (Stdlib.DB.count XDB) == 0L

  // one entries
  (let _ = Stdlib.DB.set (X { x = "hello" }) "one" XDB
   Stdlib.DB.count XDB) == 1L

  // multiple entries
  (let _ = Stdlib.DB.set (X { x = "hello" }) "one" XDB
   let _ = Stdlib.DB.set (X { x = "goodbye" }) "two" XDB
   let _ = Stdlib.DB.set (X { x = "howdy" }) "three" XDB
   let _ = Stdlib.DB.set (X { x = "cheers" }) "four" XDB
   Stdlib.DB.count XDB) == 4L

// ------------
// SqlCompiler queries
// ------------
type Person =
  { name: String
    human: Bool
    height: Int64
    income: Float
    dob: DateTime
    age: Int64 }

[<DB>]
type PersonDB = Person

let addFriend
  (key: String)
  (name: String)
  (height: Int64)
  (human: Bool)
  (dob: String)
  (income: Float)
  (age: Int64)
  : Person =
  let dob = (Stdlib.DateTime.parse dob) |> Builtin.unwrap

  // TODO parser: remove parens once the new PR is merged
  let obj =
    Person
      { height = (height)
        name = (name)
        human = (human)
        dob = (dob)
        income = (income)
        age = (age) }

  Stdlib.DB.set obj key PersonDB

let prepFriends () : Unit =
  (let _ = addFriend "ross" "Ross" 73L true "1967-05-12T00:00:00Z" 100.0 33L
   let _ = addFriend "rachel" "Rachel" 65L true "1969-05-05T00:00:00Z" 82.0 27L
   // Note spaces around Chandler, that's to test trim functions
   let _ = addFriend "chandler" " Chandler " 72L true "1969-08-19T10:13:42Z" 83.0 45L
   let _ = addFriend "cat" "GrumpyCat" 10L false "2012-04-04T00:00:00Z" 0.0 9L
   ())

let d (datestr: String) : DateTime =
  (Stdlib.DateTime.parse datestr) |> Builtin.unwrap

let rossDOB () : DateTime = d "1967-05-12T00:00:00Z"

// TODO Parser : add support for fn_type_reference wrapped in parens
let friendsError (lambda: 'a -> Bool) : List<Person> =
  let _ = prepFriends ()
  (Stdlib.DB.query PersonDB lambda)

let friends (lambda: 'a -> Bool) : List<String> =
  let _ = prepFriends ()

  (Stdlib.DB.query PersonDB lambda)
  |> Stdlib.List.map (fun p -> p.name)
  |> Stdlib.List.sort


// Test standard language features
module FindAll =
  type T2 = { field2: Int64 }
  type T1 = { field1: T2 }

  (friends (fun p -> true)) == [ " Chandler "; "GrumpyCat"; "Rachel"; "Ross" ]

  // equality
  (friends (fun p -> p.name == "Ross")) == [ "Ross" ]
  (friends (fun p -> p.height == 73L)) == [ "Ross" ]
  (friends (fun p -> p.human == false)) == [ "GrumpyCat" ]
  (friends (fun p -> p.income == 100.0)) == [ "Ross" ]
  (friends (fun p -> p.dob == (rossDOB ()))) == [ "Ross" ]

  // with condition
  (friends (fun p -> p.height > 3L)) == [ " Chandler "
                                          "GrumpyCat"
                                          "Rachel"
                                          "Ross" ]

  // boolean queries
  (friends (fun p -> p.human)) == [ " Chandler "; "Rachel"; "Ross" ]

  // string inequality works
  (friends (fun p -> p.name != "")) == [ " Chandler "; "GrumpyCat"; "Rachel"; "Ross" ]

  // &&
  (friends (fun p -> p.human && p.height > 66L)) == [ " Chandler "; "Ross" ]

  // ||
  (friends (fun p -> p.human || p.height > 66L)) == [ " Chandler "; "Rachel"; "Ross" ]

  // inlining
  (friends (fun p -> let x = 32L
   p.height > x && true)) == [ " Chandler "
                               "Rachel"
                               "Ross" ]

  // inlining field access
  (friends (fun p -> let x = p.height
   true && x > 32L)) == [ " Chandler "
                          "Rachel"
                          "Ross" ]

  // inlining package functions
  (friends (fun p -> let x = p.height
   true && Stdlib.Int64.greaterThan x 32L)) == [ " Chandler "
                                                 "Rachel"
                                                 "Ross" ]

  // inlining user functions
  let userAnd (a: Bool) (b: Bool) : Bool = Stdlib.Bool.and a b

  let userStringContains (user: Person) (str: String) : Bool =
    Stdlib.String.contains user.name str

  let userLessThan (user: Person) (height: Int64) : Bool =
    Stdlib.Int64.lessThan user height

  let userAdd (a: Int64) (b: Int64) : Int64 = a + b

  (friends (fun p -> userAnd (true || false) (p.height > 66L)))
  == [ " Chandler "
       "Ross" ]

  (friends (fun p -> let a = true
   (userAnd (a && a) (p.height > 66L))))
  == [ " Chandler "
       "Ross" ]

  (friends (fun p -> userAnd p.human true)) == [ " Chandler "; "Rachel"; "Ross" ]

  (friends (fun p -> userStringContains p "Chandler")) == [ " Chandler " ]

  (friends (fun p -> userLessThan p.height 65L)) == [ "GrumpyCat" ]

  (friends (fun p ->
    let a = 1L
    let b = 9L
    (p.height == (userAdd 1L b) && (p.age == b)))) == [ "GrumpyCat" ]

  (friends (fun p ->
    let a = 1L
    let b = 9L
    (p.height == (userAdd (b - 8L) b) && (p.age == b)))) == [ "GrumpyCat" ]

  (friends (fun p ->
    let a = 1L
    let b = 9L
    (p.height == userAdd 6L (b - 5L)))) == [ "GrumpyCat" ]

  (friends (fun p ->
    let a = 1L
    let b = 9L
    (p.height == (userAdd (b - 5L) b) && (p.age == b)))) == []

  (friends (fun p ->
    let a = 1L
    let b = 9L
    let c = userAdd 6L 4L
    (p.height == c) && (p.age == b))) == [ "GrumpyCat" ]


  // Tests for functions that are inlined 2-3 functions deep
  let nestedUserFn (user: Person) (height: Int64) : Bool =
    userAnd user.human (userLessThan user.height height)

  let anotherNestedUserFn (user: Person) (height: Int64) : Bool =
    userAnd
      user.human
      (Stdlib.Int64.lessThan user.height (Stdlib.Int64.add height 1L))


  (friends (fun p -> nestedUserFn p 68L)) == [ "Rachel" ]

  (friends (fun p -> anotherNestedUserFn p 68L)) == [ "Rachel" ]


  // pipes
  (friends (fun p -> p.height |> (*) 2L |> (<) 40L)) == [ "GrumpyCat" ]

  //[test.db query with external variable] with DB Person
  // TODO pass an external var x
  //(friends (fun p -> p.height < x)) = ["GrumpyCat"]

  // fieldaccess
  type IntField = { x: Int64 }

  (friends (fun p -> let obj = IntField { x = 42L }
   p.height > obj.x)) == [ " Chandler "
                           "Rachel"
                           "Ross" ]

  // nested fieldaccess
  friends (fun p ->
    let obj = T1 { field1 = T2 { field2 = 42L } }
    p.height > obj.field1.field2) == [ " Chandler "
                                       "Rachel"
                                       "Ross" ]

  (let x = "not int"
   friends (fun p -> p.height > x)) == Builtin.testDerrorSqlMessage
    "Variable `x` should be an Int64. However, a String (\"not int\") was passed instead.\n\nExpected: (x: Int64)\nActual: a String: \"not int\""

  // lambda doesnt return a bool
  friendsError (fun p -> "x") == Builtin.testDerrorSqlMessage
    "Incorrect type in String \"x\", expected Bool, but got a String"

  // bad variable name
  friendsError
    (fun p ->
      let x = 32L
      true && p.height > y)
  == Builtin.testDerrorSqlMessage "This variable is not defined: y"

  // sql injection
  friendsError (fun p -> "; select * from users;" == p.name) == []


module CompiledFunctions =
  (friends (fun p -> Stdlib.Float.lessThan 90.0 p.income)) == [ "Ross" ]

  (friends (fun p -> Stdlib.Float.lessThanOrEqualTo p.income 82.10)) == [ "GrumpyCat"
                                                                          "Rachel" ]

  (friends (fun p -> Stdlib.Float.greaterThan p.income 90.0)) == [ "Ross" ]


  (friends (fun p -> Stdlib.Float.divide p.income 2.0 == 50.0)) == [ "Ross" ]

  (friends (fun p -> Stdlib.Float.multiply p.income 2.0 == 200.0)) == [ "Ross" ]

  (friends (fun p -> Stdlib.Float.power p.income 2.0 == 10000.0)) == [ "Ross" ]

  (friends (fun p -> Stdlib.Float.add p.income 0.0 == 0.0)) == [ "GrumpyCat" ]

  (friends (fun p -> Stdlib.Float.subtract p.income 3.0 == 80.0)) == [ " Chandler " ]


  (friends (fun p -> Stdlib.Float.greaterThanOrEqualTo 82.10 p.income)) == [ "GrumpyCat"; "Rachel" ]

  (friends (fun p -> Stdlib.Int64.lessThanOrEqualTo p.height 65L)) == [ "GrumpyCat"; "Rachel" ]

  (friends (fun p -> Stdlib.Int64.lessThan p.height 65L)) == [ "GrumpyCat" ]

  (friends (fun p -> Stdlib.Int64.greaterThanOrEqualTo p.height 65L)) == [ " Chandler "
                                                                           "Rachel"
                                                                           "Ross" ]

  (friends (fun p -> Stdlib.Int64.greaterThan p.height 65L)) == [ " Chandler "; "Ross" ]

  (friends (fun p -> Stdlib.Int64.add p.height 1L == 11L)) == [ "GrumpyCat" ]

  (friends (fun p -> Stdlib.Int64.subtract p.height 3L == 69L)) == [ " Chandler " ]

  (friends (fun p -> Stdlib.Int64.multiply p.height 2L == 146L)) == [ "Ross" ]

  (friends (fun p -> Stdlib.Int64.divide p.height 2L == 5L)) == [ "GrumpyCat" ]

  // TODO: This test should pass, but it is causing an infinite recursion
  // (friends (fun p -> (Stdlib.Int64.power p.height 2) == Stdlib.Result.Result.Ok(100))) = [ "GrumpyCat" ]

  (friends (fun p -> Stdlib.String.toLowercase p.name == "rachel")) == [ "Rachel" ]
  (friends (fun p -> Stdlib.String.toUppercase p.name == "RACHEL")) == [ "Rachel" ]
  (friends (fun p -> Stdlib.String.reverse p.name == "lehcaR")) == [ "Rachel" ]
  // Not implemented yet
  // (friends (fun p -> Stdlib.String.length p.name > 5)) = [" Chandler "; "GrumpyCat"; "Rachel" ]
  (friends (fun p -> Stdlib.String.contains p.name "ROSS")) == []

  (friends (fun p -> Stdlib.String.contains p.name "R")) == [ "Rachel"; "Ross" ]

  (friends (fun p -> Stdlib.String.contains p.name "ZZZ")) == []

  (friends (fun p -> Stdlib.String.contains p.name "")) == [ " Chandler "
                                                             "GrumpyCat"
                                                             "Rachel"
                                                             "Ross" ]

  (friends (fun p -> Stdlib.String.replaceAll p.name "handle" "he" == " Cher ")) == [ " Chandler " ]

  (friends (fun p -> Stdlib.String.replaceAll p.name " " "Xx" == "XxChandlerXx")) == [ " Chandler " ]

  (friends (fun p ->
    Stdlib.String.replaceAll p.name "xxx" "notUsed" == " Chandler ")) == [ " Chandler " ]

  (friends (fun p -> Stdlib.String.trim p.name == "Chandler")) == [ " Chandler " ]

  (friends (fun p -> Stdlib.String.trimStart p.name == "Chandler ")) == [ " Chandler " ]

  (friends (fun p -> Stdlib.String.trimEnd p.name == " Chandler")) == [ " Chandler " ]

  (friends (fun p -> Stdlib.Bool.not p.human)) == [ "GrumpyCat" ]
  (friends (fun p -> Stdlib.Bool.and p.human p.human)) == [ " Chandler "
                                                            "Rachel"
                                                            "Ross" ]

  (friends (fun p -> Stdlib.Bool.or p.human p.human)) == [ " Chandler "
                                                           "Rachel"
                                                           "Ross" ]

  (friends (fun p -> Stdlib.Bool.not (Stdlib.Bool.and p.human p.human))) == [ "GrumpyCat" ]

  (friends (fun p -> Stdlib.Bool.and p.human (Stdlib.Bool.not p.human))) == []

  (friends (fun p -> Stdlib.Bool.or p.human (Stdlib.Bool.not p.human))) == [ " Chandler "
                                                                             "GrumpyCat"
                                                                             "Rachel"
                                                                             "Ross" ]

  (friends (fun p -> Stdlib.String.reverse p.name == "lehcaR")) == [ "Rachel" ]

  (friends (fun p ->
    Stdlib.String.reverse (
      (Stdlib.String.toLowercase p.name) |> Stdlib.String.toUppercase
    )
    == "LEHCAR")) == [ "Rachel" ]

  (friends (fun p ->
    Stdlib.DateTime.lessThanOrEqualTo p.dob (d "2000-01-01T01:02:03Z"))) == [ " Chandler "
                                                                              "Rachel"
                                                                              "Ross" ]

  (friends (fun p -> Stdlib.DateTime.lessThanOrEqualTo p.dob (rossDOB ()))) == [ "Ross" ]

  (friends (fun p -> Stdlib.DateTime.lessThan p.dob (rossDOB ()))) == []

  (friends (fun p ->
    Stdlib.DateTime.greaterThanOrEqualTo p.dob (d "2000-01-01T01:02:03Z"))) == [ "GrumpyCat" ]

  (friends (fun p -> Stdlib.DateTime.greaterThanOrEqualTo p.dob (rossDOB ()))) == [ " Chandler "
                                                                                    "GrumpyCat"
                                                                                    "Rachel"
                                                                                    "Ross" ]

  (friends (fun p -> Stdlib.DateTime.greaterThan p.dob (rossDOB ()))) == [ " Chandler "
                                                                           "GrumpyCat"
                                                                           "Rachel" ]

  (friends (fun p ->
    Stdlib.DateTime.lessThanOrEqualTo
      p.dob
      (Stdlib.DateTime.addSeconds (Stdlib.DateTime.now ()) 1L))) == [ " Chandler "
                                                                      "GrumpyCat"
                                                                      "Rachel"
                                                                      "Ross" ]

  (friends (fun p ->
    Stdlib.DateTime.lessThanOrEqualTo
      p.dob
      (Stdlib.DateTime.subtractSeconds (Stdlib.DateTime.now ()) 1L))) == [ " Chandler "
                                                                           "GrumpyCat"
                                                                           "Rachel"
                                                                           "Ross" ]

  (friends (fun p ->
    Stdlib.DateTime.atStartOfDay p.dob == (d "1969-08-19T00:00:00Z"))) == [ " Chandler " ]

  (friends (fun p -> Stdlib.DateTime.hour p.dob == 10L)) == [ " Chandler " ]
  (friends (fun p -> Stdlib.DateTime.day p.dob == 19L)) == [ " Chandler " ]
  (friends (fun p -> Stdlib.DateTime.minute p.dob == 13L)) == [ " Chandler " ]
  (friends (fun p -> Stdlib.DateTime.month p.dob == 8L)) == [ " Chandler " ]
  (friends (fun p -> Stdlib.DateTime.second p.dob == 42L)) == [ " Chandler " ]

  (friends (fun p -> Stdlib.DateTime.year p.dob == 1969L)) == [ " Chandler "; "Rachel" ]

  // Test package constants
  // Bool
  (friends (fun p ->
    Stdlib.Bool.and p.human PACKAGE.Darklang.Test.Constants.boolConst)) == [ " Chandler "
                                                                             "Rachel"
                                                                             "Ross" ]

  // Float
  // CLEANUP Parser: had to change format for the next couple of tests to make it work
  (friends
    (fun p ->
      Stdlib.Float.lessThanOrEqualTo
        p.income
        PACKAGE.Darklang.Test.Constants.floatConst)) == [ "GrumpyCat" ]

  // Int64
  (friends
    (fun p ->
      Stdlib.Int64.greaterThanOrEqualTo
        p.height
        PACKAGE.Darklang.Test.Constants.intConst)) == [ " Chandler "
                                                        "GrumpyCat"
                                                        "Rachel"
                                                        "Ross" ]

  // String
  (friends (fun p ->
    Stdlib.String.contains p.name PACKAGE.Darklang.Test.Constants.stringConst)) == []


module PartialEvaluation =
  type A = { a: Int64 }
  type Z = { z: A }
  type Y = { y: Z }
  type AL = { a: List<Int64> }
  type ZL = { z: AL }
  type YL = { y: ZL }
  // fieldAccesses outside query
  (let _ = prepFriends ()
   let x = Y { y = Z { z = A { a = 5L } } }

   ((Stdlib.DB.query PersonDB (fun p -> x.y.z.a < p.height))
    |> Stdlib.List.map (fun p -> p.name)
    |> Stdlib.List.sort)) == [ " Chandler "; "GrumpyCat"; "Rachel"; "Ross" ]

  // fieldAccesses inside query
  (friends (fun p -> let x = Y { y = Z { z = A { a = 5L } } }
   x.y.z.a < p.height)) == [ " Chandler "
                             "GrumpyCat"
                             "Rachel"
                             "Ross" ]

  // fieldAccesses inside query
  (friends (fun p ->
    let x = YL { y = ZL { z = AL { a = [ 1L; 2L; 3L; 4L; 5L ] } } }
    (Stdlib.List.length x.y.z.a) < p.height)) == [ " Chandler "
                                                   "GrumpyCat"
                                                   "Rachel"
                                                   "Ross" ]

  // tuple destructuring inside query
  (friends (fun p ->
    let (a0, a1, a2, a3, ((b, c), d)) = (0L, 1L, 2L, 3L, ((5L, "aa"), 'a'))
    b < p.height)) == [ " Chandler "; "GrumpyCat"; "Rachel"; "Ross" ]


module QueryOne =
  (let _ = prepFriends ()
   Stdlib.DB.queryOne PersonDB (fun p -> p.name == "bob")) == Stdlib.Option.Option.None()

  (let _ = prepFriends ()
   Stdlib.DB.queryOne PersonDB (fun p -> p.name == "Rachel"))
  |> Stdlib.Option.map (fun v -> v.name) == Stdlib.Option.Option.Some("Rachel")


  // interpolated
  (let _ = prepFriends ()
   let test = "ache"

   (Stdlib.DB.queryOne PersonDB (fun p -> p.name == $"R{test}l"))
   |> Stdlib.Option.map (fun v -> v.name)) == Stdlib.Option.Option.Some("Rachel")


module QueryOneWithKey =
  // multiple
  (let _ = prepFriends ()
   Stdlib.DB.queryOneWithKey PersonDB (fun p -> p.human)) == Stdlib.Option.Option.None()

  // none
  (let _ = prepFriends ()
   Stdlib.DB.queryOneWithKey PersonDB (fun p -> p.name == "bob")) == Stdlib.Option.Option.None()

  // one
  (let _ = prepFriends ()

   (Stdlib.DB.queryOneWithKey PersonDB (fun p -> p.name == "Rachel"))
   |> Builtin.unwrap
   |> (fun v -> (Stdlib.Tuple2.second v).name)) == "Rachel"

  // interpolated
  (let _ = prepFriends ()
   let test = "ache"

   (Stdlib.DB.queryOneWithKey PersonDB (fun p -> p.name == $"R{test}l"))
   |> Stdlib.Option.map (fun v -> (Stdlib.Tuple2.second v).name)) == Stdlib.Option.Option.Some("Rachel")


module QueryWithKey =
  // none
  (let _ = prepFriends ()
   Stdlib.DB.queryWithKey PersonDB (fun p -> p.name == "bob"))
  // TOTO Parser: remove parens once the new PR is merged
  == (Stdlib.Dict.empty)

  // one
  (let _ = prepFriends ()

   (Stdlib.DB.queryWithKey PersonDB (fun p -> p.name == "Rachel"))
   |> Stdlib.Dict.toList
   |> Stdlib.List.map (fun v -> (Stdlib.Tuple2.second v).name)) == [ "Rachel" ]

module QueryCount =
  // none
  (let _ = prepFriends ()
   Stdlib.DB.queryCount PersonDB (fun p -> p.name == "bob")) == 0L

  // one
  (let _ = prepFriends ()
   Stdlib.DB.queryCount PersonDB (fun p -> p.height > 3L)) == 4L


((Stdlib.DB.generateKey ()) |> Stdlib.String.length) == 36L