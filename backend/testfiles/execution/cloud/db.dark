// really simple data stores of Records
type X = { x: String }

[<DB>]
type XDB = X


type Z = { x: Char }

[<DB>]
type ZDB = Z


type XY = { x: String; y: String }

[<DB>]
type XYDB = XY


type SortedX = { x: String; sortBy: Int }

[<DB>]
type SortedXDB = SortedX

// simple data stores of Enums
// , and Records containing Enums

type MyEnum =
  | A
  | B
  | C

type MyEnum2 =
  | D
  | E
  | F of MyEnum

type EnumTestRecord = { x: String; y: MyEnum }

[<DB>]
type TestEnumDB = EnumTestRecord

[<DB>]
type TestEnumDB2 = MyEnum

[<DB>]
type TestEnumDB3 = MyEnum2


// Nested field accessing
type VeryInnerRecord = { age: Int }
type AliasOfVeryInnerRecord = VeryInnerRecord
type InnerRecord = { numbers: AliasOfVeryInnerRecord }
type OuterRecord = { name: String; details: InnerRecord }
type AliasOfRecord = OuterRecord

[<DB>]
type TestNestedRecord = OuterRecord

[<DB>]
type TestNestedAliasRecord = AliasOfRecord

module NestedRecordFieldAccess =
  // can use lambda like (fun p -> p.details.numbers.age)
  (Builtin.DB.set
    (OuterRecord
      { name = "joe"
        details = InnerRecord { numbers = AliasOfVeryInnerRecord { age = 41 } } })
    "jjj"
    TestNestedRecord

   Builtin.DB.set
     (OuterRecord
       { name = "frank"
         details = InnerRecord { numbers = VeryInnerRecord { age = 22 } } })
     "fff"
     TestNestedRecord

   let shouldBeJustJoe =
     Builtin.DB.query TestNestedRecord (fun p -> p.details.numbers.age == 41)

   PACKAGE.Darklang.Stdlib.List.length shouldBeJustJoe) = 1

  // same as above, but with aliases
  (Builtin.DB.set
    (AliasOfRecord
      { name = "jeremy"
        details = InnerRecord { numbers = VeryInnerRecord { age = 38 } } })
    "ignored"
    TestNestedAliasRecord

   Builtin.DB.set
     (AliasOfRecord
       { name = "josephine"
         details = InnerRecord { numbers = AliasOfVeryInnerRecord { age = 29 } } })
     "alsoIgnored"
     TestNestedAliasRecord

   let shouldBeJustJeremy =
     Builtin.DB.query TestNestedAliasRecord (fun p -> p.details.numbers.age == 38)

   PACKAGE.Darklang.Stdlib.List.length shouldBeJustJeremy) = 1



// Query data from a type with generics
type GenericThing<'a> = { name: 'a }
type RecordWithGenericThing = GenericThing<String>

[<DB>]
type TestRecordWithGenericThing = RecordWithGenericThing

// module AccessDataInGenericField =
//   (Builtin.DB.set
//     (RecordWithGenericThing { name = "joe" })
//     "jjj"
//     TestRecordWithGenericThing

//    Builtin.DB.set
//      (RecordWithGenericThing { name = "frank" })
//      "fff"
//      TestRecordWithGenericThing

//    let shouldBeJustJoe =
//      Builtin.DB.query TestRecordWithGenericThing (fun p -> p.name == "joe")

//    PACKAGE.Darklang.Stdlib.List.length shouldBeJustJoe) = 1


module AddToTestEnumDBs =
  (let test1 =
    Builtin.DB.set (EnumTestRecord { x = "hello"; y = MyEnum.A }) "test1" TestEnumDB in

   let test2 =
     Builtin.DB.set
       (EnumTestRecord { x = "goodbye"; y = MyEnum.B })
       "test2"
       TestEnumDB in

   (Builtin.DB.getAll TestEnumDB) |> PACKAGE.Darklang.Stdlib.List.sort) = [ EnumTestRecord
                                                                              { x =
                                                                                  "goodbye"
                                                                                y =
                                                                                  MyEnum.B }
                                                                            EnumTestRecord
                                                                              { x =
                                                                                  "hello"
                                                                                y =
                                                                                  MyEnum.A } ]

  (let test1 =
    Builtin.DB.set (EnumTestRecord { x = "hello"; y = MyEnum.A }) "test1" TestEnumDB in

   let test2 =
     Builtin.DB.set
       (EnumTestRecord { x = "goodbye"; y = MyEnum.B })
       "test2"
       TestEnumDB in

   (Builtin.DB.get "test1" TestEnumDB)) = PACKAGE.Darklang.Stdlib.Option.Option.Some(
    EnumTestRecord { x = "hello"; y = MyEnum.A }
  )

  (let test1 = Builtin.DB.set MyEnum.A "test1" TestEnumDB2 in
   let test2 = Builtin.DB.set MyEnum.B "test2" TestEnumDB2 in
   (Builtin.DB.getAll TestEnumDB2) |> PACKAGE.Darklang.Stdlib.List.sort) = [ MyEnum.A
                                                                             MyEnum.B ]

  (let test1 = Builtin.DB.set MyEnum.C "test1" TestEnumDB2 in
   let test2 = Builtin.DB.set MyEnum.B "test2" TestEnumDB2 in
   (Builtin.DB.get "test1" TestEnumDB2)) = PACKAGE.Darklang.Stdlib.Option.Option.Some(
    MyEnum.C
  )

  (let test1 = Builtin.DB.set MyEnum2.D "test1" TestEnumDB3 in
   let test2 = Builtin.DB.set MyEnum2.E "test2" TestEnumDB3 in
   let test3 = Builtin.DB.set (MyEnum2.F MyEnum.A) "test3" TestEnumDB3 in
   (Builtin.DB.getAll TestEnumDB3) |> PACKAGE.Darklang.Stdlib.List.sort) = [ MyEnum2.D
                                                                             MyEnum2.E
                                                                             MyEnum2.F
                                                                               MyEnum.A ]

  (let test1 = Builtin.DB.set MyEnum.D "test1" TestEnumDB2 in
   (Builtin.DB.getAll TestEnumDB2)) = Builtin.Test.derrorMessage
    "There is no case named `D` in MyEnum"

  (let testQuery =
    Builtin.DB.set (EnumTestRecord { x = "hello"; y = MyEnum.A }) "test1" TestEnumDB in

   (Builtin.DB.query TestEnumDB (fun p -> p.x == "hello"))) = [ EnumTestRecord
                                                                  { x = "hello"
                                                                    y = MyEnum.A } ]


type MyTlid =
  { mytlid: PACKAGE.Darklang.LanguageTools.TLID }

[<DB>]
type MyTlidDB = MyTlid

module addToTest =
  (let test = Builtin.DB.set (MyTlid { mytlid = 1234 }) "test" MyTlidDB in
   (Builtin.DB.getAll MyTlidDB)) = [ MyTlid { mytlid = 1234 } ]


module Roundtrip =
  type Sample =
    { iNsEnSiTiVe: String
      ``ALLCAPS``: Int
      int: Int
      float: Float
      negZero: Float
      nan: Float
      infinity: Float
      negInfinity: Float
      ``true``: Bool
      ``false``: Bool
      char: Char
      emojiChar: Char
      uuid: Uuid
      resultOk: PACKAGE.Darklang.Stdlib.Result.Result<Int, String>
      resultError: PACKAGE.Darklang.Stdlib.Result.Result<Int, String>
      list: List<Int>
      datetime: DateTime
      unit: Unit }

  [<DB>]
  type SampleDB = Sample

  let sample () : Sample =
    Sample
      { iNsEnSiTiVe = "iNsEnSiTiVe"
        ``ALLCAPS`` = 1
        int = 2
        float = 3.0
        negZero = -0.0
        nan = Builtin.Test.nan
        infinity = Builtin.Test.infinity
        negInfinity = Builtin.Test.negativeInfinity
        ``true`` = true
        ``false`` = false
        list = [ 1; 2; 3 ]
        char = 'c'
        resultOk = PACKAGE.Darklang.Stdlib.Result.Result.Ok 5
        resultError = PACKAGE.Darklang.Stdlib.Result.Result.Error "test"
        emojiChar = (Builtin.Test.toChar "ðŸ‘") |> Builtin.unwrap
        uuid =
          (PACKAGE.Darklang.Stdlib.Uuid.parse "00000050-0000-0000-0000-000000000000")
          |> Builtin.unwrap
        datetime =
          (PACKAGE.Darklang.Stdlib.DateTime.parse "2020-01-01T00:00:00Z")
          |> Builtin.unwrap
        unit = ()
      // dont test password because hashing it twice will get different values
      }

  let otherSample () : Sample =
    Sample
      { iNsEnSiTiVe = "normal"
        ``ALLCAPS`` = 2
        int = 3
        float = 4.0
        negZero = -1.0
        nan = 0.0
        infinity = 5.4
        negInfinity = -385.33
        ``true`` = false
        ``false`` = true
        list = [ 1; 3; 45 ]
        char = 'd'
        resultOk = PACKAGE.Darklang.Stdlib.Result.Result.Ok 6
        resultError = PACKAGE.Darklang.Stdlib.Result.Result.Error "other test"
        emojiChar = 'e'
        uuid =
          (PACKAGE.Darklang.Stdlib.Uuid.parse "55555555-5555-5555-5555-555555555555")
          |> Builtin.unwrap
        datetime =
          (PACKAGE.Darklang.Stdlib.DateTime.parse "2011-11-11T11:11:11Z")
          |> Builtin.unwrap
        unit = ()
      // dont test password because hashing it twice will get different values
      }

  // TODO: Add roundtrip for records, unit, tuple, option, result, bytes
  (let v = sample ()
   let z = Builtin.DB.set v "all" SampleDB in
   (z, Builtin.DB.get "all" SampleDB)) = (sample (),
                                          PACKAGE.Darklang.Stdlib.Option.Option.Some(
                                            sample ()
                                          ))


  type Passwords = { password: Password }

  [<DB>]
  type PasswordsDB = Passwords

  // TYPESCLEANUP - support passwords
  // (let pw = PACKAGE.Darklang.Stdlib.Password.hash_v0 "password" in
  //  let x = Builtin.DB.set (Passwords { password = pw }) "test" PasswordsDB in
  //  let y = (Builtin.DB.queryOne PasswordsDB (fun p -> p.password == pw)) |> Builtin.unwrap in
  //  PACKAGE.Darklang.Stdlib.Password.check_v0 y.password "password") = true

  module QueryEquality =
    let fetch (fn: 'a -> Bool) : List<'a> =
      let z = Builtin.DB.set (sample ()) "sample" SampleDB in
      let z = Builtin.DB.set (otherSample ()) "other" SampleDB in
      Builtin.DB.query SampleDB fn

    // invalid type comparisons errors
    // these work, but the DError has a random string in it that we can't match
    // fetch (fun p -> 5 == "str") =
    //   Builtin.Test.derrorSqlMessage "Incorrect type in variable, expected Bool, but got a Error"
    // fetch (fun p -> 5 != "str") =
    //   Builtin.Test.derrorSqlMessage "Incorrect type in variable, expected Bool, but got a Error"

    fetch (fun p -> p.int == "str") = Builtin.Test.derrorSqlMessage
      "Incorrect type in b, expected Int, but got a String"

    fetch (fun p -> p.int != "str") = Builtin.Test.derrorSqlMessage
      "Incorrect type in b, expected Int, but got a String"

    fetch (fun p -> "str" == p.int) = Builtin.Test.derrorSqlMessage
      "Incorrect type in b, expected String, but got a Int"

    fetch (fun p -> "str" == p.int) = Builtin.Test.derrorSqlMessage
      "Incorrect type in b, expected String, but got a Int"

    fetch (fun p -> p.iNsEnSiTiVe == "iNsEnSiTiVe") = [ sample () ]
    fetch (fun p -> p.iNsEnSiTiVe != "iNsEnSiTiVe") = [ otherSample () ]
    fetch (fun p -> p.iNsEnSiTiVe == "nothing") = []

    fetch (fun p -> p.``ALLCAPS`` == 1) = [ sample () ]
    fetch (fun p -> p.``ALLCAPS`` != 1) = [ otherSample () ]
    fetch (fun p -> p.``ALLCAPS`` == 1000) = []

    fetch (fun p -> p.int == 2) = [ sample () ]
    fetch (fun p -> p.int != 2) = [ otherSample () ]
    fetch (fun p -> p.int == 200) = []

    fetch (fun p -> p.float == 3.0) = [ sample () ]
    fetch (fun p -> p.float != 3.0) = [ otherSample () ]
    fetch (fun p -> p.float == 30.0) = []

    fetch (fun p -> p.negZero == -0.0) = [ sample () ]
    fetch (fun p -> p.negZero != -0.0) = [ otherSample () ]
    fetch (fun p -> p.negZero == 19000.0) = []

    // CLEANUP: nan shouldn't be equal
    fetch (fun p -> p.nan == Builtin.Test.nan) = [ sample () ]
    fetch (fun p -> p.nan != Builtin.Test.nan) = [ otherSample () ]
    fetch (fun p -> p.nan == 14.0) = []

    fetch (fun p -> p.infinity == Builtin.Test.infinity) = [ sample () ]
    fetch (fun p -> p.infinity != Builtin.Test.infinity) = [ otherSample () ]
    fetch (fun p -> p.infinity == 1.0) = []

    fetch (fun p -> p.negInfinity == Builtin.Test.negativeInfinity) = [ sample () ]

    fetch (fun p -> p.negInfinity != Builtin.Test.negativeInfinity) = [ otherSample
                                                                          () ]

    fetch (fun p -> p.negInfinity == 1.0) = []

    fetch (fun p -> p.``true`` == true) = [ sample () ]
    fetch (fun p -> p.``true`` != true) = [ otherSample () ]

    fetch (fun p -> p.``false`` == false) = [ sample () ]
    fetch (fun p -> p.``false`` != false) = [ otherSample () ]

    // A bug in postgresql jsonb support prevents this from working
    // fetch (fun p -> p.list == [1;2;3]) = [sample ()]
    // fetch (fun p -> p.list != [1;2;3]) = [otherSample ()]
    // fetch (fun p -> p.list == []) = []

    fetch (fun p -> p.char == 'c') = [ sample () ]
    fetch (fun p -> p.char != 'c') = [ otherSample () ]
    fetch (fun p -> p.char == 'x') = []

    fetch (fun p -> p.emojiChar == ((Builtin.Test.toChar "ðŸ‘") |> Builtin.unwrap)) = [ sample
                                                                                         () ]

    fetch (fun p -> p.emojiChar != ((Builtin.Test.toChar "ðŸ‘") |> Builtin.unwrap)) = [ otherSample
                                                                                         () ]

    fetch (fun p -> p.emojiChar == 'x') = []

    fetch (fun p ->
      p.uuid
      == ((PACKAGE.Darklang.Stdlib.Uuid.parse "00000050-0000-0000-0000-000000000000")
          |> Builtin.unwrap)) = [ sample () ]

    fetch (fun p ->
      p.uuid
      != ((PACKAGE.Darklang.Stdlib.Uuid.parse "00000050-0000-0000-0000-000000000000")
          |> Builtin.unwrap)) = [ otherSample () ]

    fetch (fun p ->
      p.uuid
      == ((PACKAGE.Darklang.Stdlib.Uuid.parse "11111111-1111-1111-1111-000000000000")
          |> Builtin.unwrap)) = []

    fetch (fun p ->
      p.datetime
      == ((PACKAGE.Darklang.Stdlib.DateTime.parse "2020-01-01T00:00:00Z")
          |> Builtin.unwrap)) = [ sample () ]

    fetch (fun p ->
      p.datetime
      != ((PACKAGE.Darklang.Stdlib.DateTime.parse "2020-01-01T00:00:00Z")
          |> Builtin.unwrap)) = [ otherSample () ]

    fetch (fun p ->
      p.datetime
      == ((PACKAGE.Darklang.Stdlib.DateTime.parse "2019-12-31T23:59:59Z")
          |> Builtin.unwrap)) = []

    (fetch (fun p -> p.unit == ()))
    |> PACKAGE.Darklang.Stdlib.List.sortBy (fun v -> v.int) = [ sample ()
                                                                otherSample () ]

    fetch (fun p -> p.unit != ()) = []

    // Test equality for two different function results - this tests TVariable types, esp checking that we keep track of them correctly
    fetch (fun p ->
      ((PACKAGE.Darklang.Stdlib.Uuid.parse "00000050-0000-0000-0000-000000000000")
       |> Builtin.unwrap)
      == p.uuid) = [ sample () ]

    ((fetch (fun p ->
      ((PACKAGE.Darklang.Stdlib.Uuid.parse "00000050-0000-0000-0000-000000000000")
       |> Builtin.unwrap)
      == ((PACKAGE.Darklang.Stdlib.Uuid.parse "00000050-0000-0000-0000-000000000000")
          |> Builtin.unwrap)))
     |> PACKAGE.Darklang.Stdlib.List.length) = 2



// CLEANUP test ``ALL CAPS``
// CLEANUP test partial evaluation of lists and tuples


module ValueMissingColumnGivesGoodError =
  // TYPESCLEANUP: can we test a missing column against the DB anymore?
  // (Builtin.DB.set (XY { x = "x"; y = "v" }) "i" XDB) = Builtin.Test.runtimeError "Found but did not expect: [y]"

  (Builtin.DB.set (XY { x = "x"; y = "v" }) "i" XDB) = Builtin.Test.derrorMessage
    "DB XDB's value should be a X. However, a XY (XY {  x: ...) was passed instead.\n\nExpected: X\nActual: a XY: XY {\n  x: \"x\",\n  y: \"v\"\n}"


module SetDoesUpsert =
  (let old = Builtin.DB.set (X { x = "hello" }) "hello" XDB in
   let newval = Builtin.DB.set (X { x = "goodbye" }) "hello" XDB in
   Builtin.DB.getAllWithKeys XDB) = Dict { hello = X { x = "goodbye" } }

module SetCharUpserts =
  (let old = Builtin.DB.set (Z { x = 'a' }) "a" ZDB in
   let newval = Builtin.DB.set (Z { x = 'b' }) "a" ZDB in
   Builtin.DB.getAllWithKeys ZDB) = Dict { a = Z { x = 'b' } }



module Get =
  // return none for empty store
  (Builtin.DB.get "lol" XDB) = PACKAGE.Darklang.Stdlib.Option.Option.None

  // return none for invalid key
  (let _ = Builtin.DB.set (X { x = "hello" }) "key" XDB in Builtin.DB.get "lol" XDB) = PACKAGE.Darklang.Stdlib.Option.Option.None

  // returns single value
  (let _ = Builtin.DB.set (X { x = "hello" }) "key" XDB in Builtin.DB.get "key" XDB) = PACKAGE
    .Darklang
    .Stdlib
    .Option
    .Option
    .Some(X { x = "hello" })

  // returns correct value given reassigned entry
  (let _ = Builtin.DB.set (X { x = "hello" }) "key" XDB in
   let _ = Builtin.DB.set (X { x = "goodbye" }) "key" XDB in
   Builtin.DB.get "key" XDB) = PACKAGE.Darklang.Stdlib.Option.Option.Some(
    X { x = "goodbye" }
  )

  // returns value given multiple entries
  (let _ = Builtin.DB.set (X { x = "pancake" }) "key1" XDB in
   let _ = Builtin.DB.set (X { x = "waffle" }) "key2" XDB in
   let _ = Builtin.DB.set (X { x = "scone" }) "key3" XDB in
   Builtin.DB.get "key2" XDB) = PACKAGE.Darklang.Stdlib.Option.Option.Some(
    X { x = "waffle" }
  )


module Params =
  type Param<'a> = { x: 'a; b: Int }

  [<DB>]
  type ParamDB = Param<String>

  (let _ = Builtin.DB.set (Param { x = "hello"; b = 5 }) "key" ParamDB
   Builtin.DB.get "key" ParamDB) = PACKAGE.Darklang.Stdlib.Option.Option.Some(
    Param { x = "hello"; b = 5 }
  )



module GetAll =
  (let one = Builtin.DB.set (SortedX { x = "hello"; sortBy = 0 }) "one" SortedXDB in
   let two = Builtin.DB.set (SortedX { x = "goodbye"; sortBy = 1 }) "two" SortedXDB in
   let three = Builtin.DB.set (SortedX { x = "howdy"; sortBy = 2 }) "three" SortedXDB in

   (Builtin.DB.getAll SortedXDB)
   |> PACKAGE.Darklang.Stdlib.List.sortBy_v0 (fun x -> x.sortBy)) = [ (SortedX
                                                                        { x = "hello"
                                                                          sortBy = 0 })
                                                                      (SortedX
                                                                        { x =
                                                                            "goodbye"
                                                                          sortBy = 1 })
                                                                      (SortedX
                                                                        { x = "howdy"
                                                                          sortBy = 2 }) ]


module GetAllKeys =
  (let one = Builtin.DB.set (X { x = "hello" }) "one" XDB in
   let two = Builtin.DB.set (X { x = "goodbye" }) "two" XDB in
   (Builtin.DB.keys XDB) |> PACKAGE.Darklang.Stdlib.List.sort_v0) = [ "one"; "two" ]


module GetAllWithKeys =
  (let one = Builtin.DB.set (X { x = "hello" }) "one" XDB in
   let two = Builtin.DB.set (X { x = "goodbye" }) "two" XDB in
   Builtin.DB.getAllWithKeys XDB) = Dict
    { one = X { x = "hello" }
      two = X { x = "goodbye" } }


module GetManyWithKeys =
  (let one = Builtin.DB.set (X { x = "hello" }) "one" XDB in
   let two = Builtin.DB.set (X { x = "goodbye" }) "two" XDB in
   Builtin.DB.getManyWithKeys [ "one"; "two" ] XDB) = Dict
    { one = (X { x = "hello" })
      two = (X { x = "goodbye" }) }


module GetExisting =
  (let one = Builtin.DB.set (X { x = "hello" }) "one" XDB in
   let two = Builtin.DB.set (X { x = "goodbye" }) "two" XDB in
   Builtin.DB.getExisting_v0 [ "three"; "two" ] XDB) = [ (X { x = "goodbye" }) ]


module GetMany =
  (let one = Builtin.DB.set (X { x = "hello" }) "one" XDB in
   let two = Builtin.DB.set (X { x = "goodbye" }) "two" XDB in
   Builtin.DB.getMany [ "three"; "two" ] XDB) = PACKAGE.Darklang.Stdlib.Option.Option.None

  (let one = Builtin.DB.set (X { x = "hello" }) "one" XDB in
   let two = Builtin.DB.set (X { x = "goodbye" }) "two" XDB in

   (Builtin.DB.getMany [ "one"; "two" ] XDB)
   |> Builtin.unwrap
   |> PACKAGE.Darklang.Stdlib.List.sortBy (fun v -> v.x)) = [ (X { x = "goodbye" })
                                                              (X { x = "hello" }) ]


module Delete =
  (let one = Builtin.DB.set (X { x = "hello" }) "one" XDB in
   let delete = Builtin.DB.delete "one" XDB in
   Builtin.DB.getAllWithKeys XDB) = Dict { }

  // delete nothing
  (let one = Builtin.DB.set (X { x = "hello" }) "one" XDB in
   let delete = Builtin.DB.delete "two" XDB in
   Builtin.DB.getAllWithKeys XDB) = Dict { one = (X { x = "hello" }) }

  // deletes only one
  (let one = Builtin.DB.set (X { x = "hello" }) "one" XDB in
   let two = Builtin.DB.set (X { x = "goodbye" }) "two" XDB in
   let delete = Builtin.DB.delete "one" XDB in
   Builtin.DB.getAllWithKeys XDB) = Dict { two = (X { x = "goodbye" }) }

module DeleteAll =
  (let one = Builtin.DB.set (X { x = "hello" }) "one" XDB in
   let delete = Builtin.DB.deleteAll XDB in
   Builtin.DB.getAll XDB) = []

  // deletes all
  (let one = Builtin.DB.set (X { x = "hello" }) "one" XDB in
   let two = Builtin.DB.set (X { x = "goodbye" }) "two" XDB in
   let delete = Builtin.DB.deleteAll XDB in
   Builtin.DB.getAll XDB) = []

  // when empty
  (let delete = Builtin.DB.deleteAll XDB in Builtin.DB.getAll XDB) = []

module Count =
  // empty
  Builtin.DB.count XDB = 0

  // one entries
  (let _ = Builtin.DB.set (X { x = "hello" }) "one" XDB in Builtin.DB.count XDB) = 1

  // multiple entries
  (let _ = Builtin.DB.set (X { x = "hello" }) "one" XDB in
   let _ = Builtin.DB.set (X { x = "goodbye" }) "two" XDB in
   let _ = Builtin.DB.set (X { x = "howdy" }) "three" XDB in
   let _ = Builtin.DB.set (X { x = "cheers" }) "four" XDB in
   Builtin.DB.count XDB) = 4

// ------------
// SqlCompiler queries
// ------------
type Person =
  { name: String
    human: Bool
    height: Int
    income: Float
    dob: DateTime }

[<DB>]
type PersonDB = Person

let addFriend
  (key: String)
  (name: String)
  (height: Int)
  (human: Bool)
  (dob: String)
  (income: Float)
  : Person =
  let dob = (PACKAGE.Darklang.Stdlib.DateTime.parse dob) |> Builtin.unwrap in

  let obj =
    Person
      { height = height
        name = name
        human = human
        dob = dob
        income = income } in

  Builtin.DB.set obj key PersonDB

let prepFriends () : Unit =
  (let _ = addFriend "ross" "Ross" 73 true "1967-05-12T00:00:00Z" 100.0 in
   let _ = addFriend "rachel" "Rachel" 65 true "1969-05-05T00:00:00Z" 82.0 in
   // Note spaces around Chandler, that's to test trim functions
   let _ = addFriend "chandler" " Chandler " 72 true "1969-08-19T10:13:42Z" 83.0 in
   let _ = addFriend "cat" "GrumpyCat" 10 false "2012-04-04T00:00:00Z" 0.0 in
   ())

let d (datestr: String) : DateTime =
  (PACKAGE.Darklang.Stdlib.DateTime.parse datestr) |> Builtin.unwrap

let rossDOB () : DateTime = d "1967-05-12T00:00:00Z"

let friendsError (lambda: ('a -> Bool)) : List<Person> =
  let _ = prepFriends () in Builtin.DB.query PersonDB lambda

let friends (lambda: ('a -> Bool)) : List<String> =
  let _ = prepFriends () in

  (Builtin.DB.query PersonDB lambda)
  |> PACKAGE.Darklang.Stdlib.List.map_v0 (fun p -> p.name)
  |> PACKAGE.Darklang.Stdlib.List.sort_v0


// Test standard language features
module FindAll =
  type T2 = { field2: Int }
  type T1 = { field1: T2 }

  (friends (fun p -> true)) = [ " Chandler "; "GrumpyCat"; "Rachel"; "Ross" ]

  // equality
  (friends (fun p -> p.name == "Ross")) = [ "Ross" ]
  (friends (fun p -> p.height == 73)) = [ "Ross" ]
  (friends (fun p -> p.human == false)) = [ "GrumpyCat" ]
  (friends (fun p -> p.income == 100.0)) = [ "Ross" ]
  (friends (fun p -> p.dob == (rossDOB ()))) = [ "Ross" ]

  // with condition
  (friends (fun p -> p.height > 3)) = [ " Chandler "; "GrumpyCat"; "Rachel"; "Ross" ]

  // boolean queries
  (friends (fun p -> p.human)) = [ " Chandler "; "Rachel"; "Ross" ]

  // string inequality works
  (friends (fun p -> p.name != "")) = [ " Chandler "; "GrumpyCat"; "Rachel"; "Ross" ]

  // &&
  (friends (fun p -> p.human && p.height > 66)) = [ " Chandler "; "Ross" ]

  // ||
  (friends (fun p -> p.human || p.height > 66)) = [ " Chandler "; "Rachel"; "Ross" ]

  // inlining
  (friends (fun p -> let x = 32 in p.height > x && true)) = [ " Chandler "
                                                              "Rachel"
                                                              "Ross" ]

  // inlining field access
  (friends (fun p -> let x = p.height in true && x > 32)) = [ " Chandler "
                                                              "Rachel"
                                                              "Ross" ]

  // pipes
  (friends (fun p -> p.height |> (*) 2 |> (<) 40)) = [ "GrumpyCat" ]

  //[test.db query with external variable] with DB Person
  // TODO pass an external var x
  //(friends (fun p -> p.height < x)) = ["GrumpyCat"]

  // fieldaccess
  type IntField = { x: Int }

  (friends (fun p -> let obj = IntField { x = 42 } in p.height > obj.x)) = [ " Chandler "
                                                                             "Rachel"
                                                                             "Ross" ]

  // nested fieldaccess
  friends (fun p ->
    let obj = T1 { field1 = T2 { field2 = 42 } } in p.height > obj.field1.field2) = [ " Chandler "
                                                                                      "Rachel"
                                                                                      "Ross" ]

  (let x = "not int"
   friends (fun p -> p.height > x)) = Builtin.Test.derrorSqlMessage
    "Variable `x` should be an Int. However, a String (\"not int\") was passed instead.\n\nExpected: (x: Int)\nActual: a String: \"not int\""

  // lambda doesnt return a bool
  friendsError (fun p -> "x") = Builtin.Test.derrorSqlMessage
    "Incorrect type in String \"x\", expected Bool, but got a String"

  // bad variable name
  friendsError (fun p -> let x = 32 in true && p.height > y) = Builtin.Test.derrorSqlMessage
    "This variable is not defined: y"

  // sql injection
  friendsError (fun p -> "; select * from users;" == p.name) = []

module CompiledFunctions =
  (friends (fun p -> PACKAGE.Darklang.Stdlib.Float.lessThan_v0 90.0 p.income)) = [ "Ross" ]

  (friends (fun p ->
    PACKAGE.Darklang.Stdlib.Float.lessThanOrEqualTo_v0 p.income 82.10)) = [ "GrumpyCat"
                                                                            "Rachel" ]

  (friends (fun p -> PACKAGE.Darklang.Stdlib.Float.greaterThan_v0 p.income 90.0)) = [ "Ross" ]

  (friends (fun p ->
    PACKAGE.Darklang.Stdlib.Float.greaterThanOrEqualTo_v0 82.10 p.income)) = [ "GrumpyCat"
                                                                               "Rachel" ]

  (friends (fun p -> PACKAGE.Darklang.Stdlib.Int.lessThanOrEqualTo_v0 p.height 65)) = [ "GrumpyCat"
                                                                                        "Rachel" ]

  (friends (fun p -> PACKAGE.Darklang.Stdlib.Int.lessThan_v0 p.height 65)) = [ "GrumpyCat" ]

  (friends (fun p -> PACKAGE.Darklang.Stdlib.Int.greaterThanOrEqualTo_v0 p.height 65)) = [ " Chandler "
                                                                                           "Rachel"
                                                                                           "Ross" ]

  (friends (fun p -> PACKAGE.Darklang.Stdlib.Int.greaterThan_v0 p.height 65)) = [ " Chandler "
                                                                                  "Ross" ]

  (friends (fun p -> PACKAGE.Darklang.Stdlib.String.toLowercase p.name == "rachel")) = [ "Rachel" ]
  (friends (fun p -> PACKAGE.Darklang.Stdlib.String.toUppercase p.name == "RACHEL")) = [ "Rachel" ]
  (friends (fun p -> PACKAGE.Darklang.Stdlib.String.reverse_v0 p.name == "lehcaR")) = [ "Rachel" ]
  // Not implemented yet
  // (friends (fun p -> PACKAGE.Darklang.Stdlib.String.length p.name > 5)) = [" Chandler "; "GrumpyCat"; "Rachel" ]
  (friends (fun p -> PACKAGE.Darklang.Stdlib.String.contains_v0 p.name "ROSS")) = []

  (friends (fun p -> PACKAGE.Darklang.Stdlib.String.contains_v0 p.name "R")) = [ "Rachel"
                                                                                 "Ross" ]

  (friends (fun p -> PACKAGE.Darklang.Stdlib.String.contains_v0 p.name "ZZZ")) = []

  (friends (fun p -> PACKAGE.Darklang.Stdlib.String.contains_v0 p.name "")) = [ " Chandler "
                                                                                "GrumpyCat"
                                                                                "Rachel"
                                                                                "Ross" ]

  (friends (fun p ->
    PACKAGE.Darklang.Stdlib.String.replaceAll_v0 p.name "handle" "he" == " Cher ")) = [ " Chandler " ]

  (friends (fun p ->
    PACKAGE.Darklang.Stdlib.String.replaceAll_v0 p.name " " "Xx" == "XxChandlerXx")) = [ " Chandler " ]

  (friends (fun p ->
    PACKAGE.Darklang.Stdlib.String.replaceAll_v0 p.name "xxx" "notUsed"
    == " Chandler ")) = [ " Chandler " ]

  (friends (fun p -> PACKAGE.Darklang.Stdlib.String.trim_v0 p.name == "Chandler")) = [ " Chandler " ]

  (friends (fun p ->
    PACKAGE.Darklang.Stdlib.String.trimStart_v0 p.name == "Chandler ")) = [ " Chandler " ]

  (friends (fun p -> PACKAGE.Darklang.Stdlib.String.trimEnd_v0 p.name == " Chandler")) = [ " Chandler " ]
  (friends (fun p -> PACKAGE.Darklang.Stdlib.Bool.not_v0 p.human)) = [ "GrumpyCat" ]

  (friends (fun p -> PACKAGE.Darklang.Stdlib.Bool.and_v0 p.human p.human)) = [ " Chandler "
                                                                               "Rachel"
                                                                               "Ross" ]

  (friends (fun p -> PACKAGE.Darklang.Stdlib.Bool.or_v0 p.human p.human)) = [ " Chandler "
                                                                              "Rachel"
                                                                              "Ross" ]

  (friends (fun p ->
    PACKAGE.Darklang.Stdlib.DateTime.lessThanOrEqualTo
      p.dob
      (d "2000-01-01T01:02:03Z"))) = [ " Chandler "; "Rachel"; "Ross" ]

  (friends (fun p ->
    PACKAGE.Darklang.Stdlib.DateTime.lessThanOrEqualTo p.dob (rossDOB ()))) = [ "Ross" ]

  (friends (fun p -> PACKAGE.Darklang.Stdlib.DateTime.lessThan p.dob (rossDOB ()))) = []

  (friends (fun p ->
    PACKAGE.Darklang.Stdlib.DateTime.greaterThanOrEqualTo
      p.dob
      (d "2000-01-01T01:02:03Z"))) = [ "GrumpyCat" ]

  (friends (fun p ->
    PACKAGE.Darklang.Stdlib.DateTime.greaterThanOrEqualTo p.dob (rossDOB ()))) = [ " Chandler "
                                                                                   "GrumpyCat"
                                                                                   "Rachel"
                                                                                   "Ross" ]

  (friends (fun p -> PACKAGE.Darklang.Stdlib.DateTime.greaterThan p.dob (rossDOB ()))) = [ " Chandler "
                                                                                           "GrumpyCat"
                                                                                           "Rachel" ]

  (friends (fun p ->
    PACKAGE.Darklang.Stdlib.DateTime.lessThanOrEqualTo
      p.dob
      (PACKAGE.Darklang.Stdlib.DateTime.addSeconds_v0
        (PACKAGE.Darklang.Stdlib.DateTime.now_v0 ())
        1))) = [ " Chandler "; "GrumpyCat"; "Rachel"; "Ross" ]

  (friends (fun p ->
    PACKAGE.Darklang.Stdlib.DateTime.lessThanOrEqualTo
      p.dob
      (PACKAGE.Darklang.Stdlib.DateTime.subtractSeconds_v0
        (PACKAGE.Darklang.Stdlib.DateTime.now_v0 ())
        1))) = [ " Chandler "; "GrumpyCat"; "Rachel"; "Ross" ]

  (friends (fun p ->
    PACKAGE.Darklang.Stdlib.DateTime.atStartOfDay_v0 p.dob
    == (d "1969-08-19T00:00:00Z"))) = [ " Chandler " ]

  (friends (fun p -> PACKAGE.Darklang.Stdlib.DateTime.hour p.dob == 10)) = [ " Chandler " ]
  (friends (fun p -> PACKAGE.Darklang.Stdlib.DateTime.day_v0 p.dob == 19)) = [ " Chandler " ]
  (friends (fun p -> PACKAGE.Darklang.Stdlib.DateTime.minute p.dob == 13)) = [ " Chandler " ]
  (friends (fun p -> PACKAGE.Darklang.Stdlib.DateTime.month_v0 p.dob == 8)) = [ " Chandler " ]
  (friends (fun p -> PACKAGE.Darklang.Stdlib.DateTime.second p.dob == 42)) = [ " Chandler " ]

  (friends (fun p -> PACKAGE.Darklang.Stdlib.DateTime.year_v0 p.dob == 1969)) = [ " Chandler "
                                                                                  "Rachel" ]

  // Test package constants
  (friends (fun p ->
    PACKAGE.Darklang.Stdlib.Bool.and_v0
      p.human
      PACKAGE.Darklang.Test.Constants.boolConst)) = [ " Chandler "
                                                      "Rachel"
                                                      "Ross" ]

module PartialEvaluation =
  type A = { a: Int }
  type Z = { z: A }
  type Y = { y: Z }
  type AL = { a: List<Int> }
  type ZL = { z: AL }
  type YL = { y: ZL }
  // fieldAccesses outside query
  (let _ = prepFriends ()
   let x = Y { y = Z { z = A { a = 5 } } }

   ((Builtin.DB.query PersonDB (fun p -> x.y.z.a < p.height))
    |> PACKAGE.Darklang.Stdlib.List.map_v0 (fun p -> p.name)
    |> PACKAGE.Darklang.Stdlib.List.sort_v0)) = [ " Chandler "
                                                  "GrumpyCat"
                                                  "Rachel"
                                                  "Ross" ]

  // fieldAccesses inside query
  (friends (fun p -> let x = Y { y = Z { z = A { a = 5 } } } in x.y.z.a < p.height)) = [ " Chandler "
                                                                                         "GrumpyCat"
                                                                                         "Rachel"
                                                                                         "Ross" ]

  // fieldAccesses inside query
  (friends (fun p ->
    let x = YL { y = ZL { z = AL { a = [ 1; 2; 3; 4; 5 ] } } }
    (PACKAGE.Darklang.Stdlib.List.length_v0 x.y.z.a) < p.height)) = [ " Chandler "
                                                                      "GrumpyCat"
                                                                      "Rachel"
                                                                      "Ross" ]

  // tuple destructuring inside query
  (friends (fun p ->
    let (a0, a1, a2, a3, ((b, c), d)) = (0, 1, 2, 3, ((5, "aa"), 'a'))
    b < p.height)) = [ " Chandler "; "GrumpyCat"; "Rachel"; "Ross" ]


module QueryOneWithKey =
  // multiple
  (let _ = prepFriends () in Builtin.DB.queryOneWithKey PersonDB (fun p -> p.human)) = PACKAGE.Darklang.Stdlib.Option.Option.None

  // none
  (let _ = prepFriends () in
   Builtin.DB.queryOneWithKey PersonDB (fun p -> p.name == "bob")) = PACKAGE.Darklang.Stdlib.Option.Option.None

  // one
  (let _ = prepFriends () in

   (Builtin.DB.queryOneWithKey PersonDB (fun p -> p.name == "Rachel"))
   |> Builtin.unwrap
   |> (fun v -> (PACKAGE.Darklang.Stdlib.Tuple2.second v).name)) = "Rachel"

  // interpolated
  (let _ = prepFriends ()
   let test = "ache"

   (Builtin.DB.queryOneWithKey PersonDB (fun p -> p.name == $"R{test}l"))
   |> PACKAGE.Darklang.Stdlib.Option.map (fun v ->
     (PACKAGE.Darklang.Stdlib.Tuple2.second v).name)) = PACKAGE.Darklang.Stdlib.Option.Option.Some
    "Rachel"


module QueryWithKey =
  // none
  (let _ = prepFriends () in
   Builtin.DB.queryWithKey PersonDB (fun p -> p.name == "bob")) = PACKAGE.Darklang.Stdlib.Dict.empty

  // one
  (let _ = prepFriends () in

   (Builtin.DB.queryWithKey PersonDB (fun p -> p.name == "Rachel"))
   |> Builtin.Dict.toList_v0
   |> PACKAGE.Darklang.Stdlib.List.map (fun v ->
     (PACKAGE.Darklang.Stdlib.Tuple2.second v).name)) = [ "Rachel" ]

module QueryCount =
  // none
  (let _ = prepFriends () in
   Builtin.DB.queryCount_v0 PersonDB (fun p -> p.name == "bob")) = 0

  // one
  (let _ = prepFriends () in
   Builtin.DB.queryCount_v0 PersonDB (fun p -> p.height > 3)) = 4


((Builtin.DB.generateKey_v0 ()) |> PACKAGE.Darklang.Stdlib.String.length) = 36