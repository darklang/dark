// Unsupported stuff:
// - TDB
// - TFn
// None of these are supported as <> type args in the parser,
// so do we really have to do anything here?
// It feels like a "no" to me - ignoring for now.

type Person = { Name: String; Age: Int64 }

type Result<'ok, 'err> = Stdlib.Result.Result<'ok, 'err>
type Option<'t> = Stdlib.Option.Option<'t>

let err
  (v: Stdlib.Result.Result<'a, Stdlib.Json.ParseError.ParseError>)
  : Result<'a, String> =
  v |> Stdlib.Result.mapError Stdlib.Json.ParseError.toString


module Unit =
  Stdlib.Json.serialize<Unit> () = "null"
  Stdlib.Json.parse<Unit> "null" = Result.Ok()

  module Errors =
    (Stdlib.Json.parse<Int64> "()") |> err = Result.Error "Not JSON"

    (Stdlib.Json.parse<Unit> "0") |> err = Result.Error
      "Can't parse JSON `0` as type `Unit` at path: `root`"

    (Stdlib.Json.parse<Unit> "\"\"") |> err = Result.Error
      "Can't parse JSON `\"\"` as type `Unit` at path: `root`"

    (Stdlib.Json.parse<Unit> "\"null\"") |> err =
      Result.Error "Can't parse JSON `\"null\"` as type `Unit` at path: `root`"


module Bool =
  Stdlib.Json.serialize<Bool> true = "true"
  Stdlib.Json.serialize<Bool> false = "false"

  Stdlib.Json.parse<Bool> "true" = Result.Ok true
  Stdlib.Json.parse<Bool> "false" = Result.Ok false
  Stdlib.Json.parse<Bool> " true " = Result.Ok true
  Stdlib.Json.parse<Bool> " false " = Result.Ok false

  Stdlib.Json.parse<List<Bool>> "[true, true, false, true  ] " =
    Result.Ok [ true; true; false; true ]

  module Errors =
    (Stdlib.Json.parse<Bool> "tru") |> err =
      Result.Error "Not JSON"

    (Stdlib.Json.parse<Bool> "null") |> err =
      Result.Error "Can't parse JSON `null` as type `Bool` at path: `root`"

    (Stdlib.Json.parse<Bool> "") |> err =
      Result.Error "Not JSON"

    (Stdlib.Json.parse<Bool> "\"true\"") |> err =
      Result.Error "Can't parse JSON `\"true\"` as type `Bool` at path: `root`"

    (Stdlib.Json.parse<Bool> "0") |> err =
      Result.Error "Can't parse JSON `0` as type `Bool` at path: `root`"

    (Stdlib.Json.parse<Bool> "1") |> err =
      Result.Error "Can't parse JSON `1` as type `Bool` at path: `root`"

    (Stdlib.Json.parse<Bool> "False") |> err =
      Result.Error "Not JSON"

    (Stdlib.Json.parse<Bool> "tRUE") |> err =
      Result.Error "Not JSON"


module Int64 =
  module Basic =
    Stdlib.Json.serialize<Int64> 0L = "0"
    Stdlib.Json.serialize<Int64> 12345L = "12345"
    Stdlib.Json.serialize<Int64> -12345L = "-12345"
    Stdlib.Json.parse<Int64> "0" = Result.Ok 0L
    Stdlib.Json.parse<Int64> "0.0" = Result.Ok 0L
    Stdlib.Json.parse<Int64> "-0.0" = Result.Ok 0L
    Stdlib.Json.parse<Int64> "-1.0" = Result.Ok(-1L)
    Stdlib.Json.parse<Int64> "1.2E2" = Result.Ok 120L
    Stdlib.Json.parse<Int64> "1.2E+2" = Result.Ok 120L
    Stdlib.Json.parse<Int64> "1200E-1" = Result.Ok 120L

  module Int32Limits =
    // test the limits of int32 (-2147483648 to 2147483647)
    Stdlib.Json.serialize<Int64> -2147483648L = "-2147483648"
    Stdlib.Json.serialize<Int64> 2147483647L = "2147483647"
    Stdlib.Json.parse<Int64> "-2147483648" = Result.Ok -2147483648L
    Stdlib.Json.parse<Int64> "2147483647" = Result.Ok 2147483647L
    Stdlib.Json.serialize<Int64> -2147483649L = "-2147483649"
    Stdlib.Json.serialize<Int64> 2147483648L = "2147483648"
    Stdlib.Json.parse<Int64> "-2147483649" = Result.Ok -2147483649L
    Stdlib.Json.parse<Int64> "2147483648" = Result.Ok 2147483648L

  module Int64Limits =
    // test the limits of int64 (-9223372036854775808 to 9223372036854775807)

    // TODO: consider putting ints that won't fit exactly in a float into strings to
    // be certain

    // First number that doesn't fit in an int64
    (Stdlib.Json.parse<Int64> "9223372036854775808") |> err =
      Result.Error "Can't parse JSON `9223372036854775808` as type `Int64` at path: `root`"

    // This is a float that is a valid int64
    Stdlib.Json.parse<Int64> "9.2E18" =
      Result.Ok 9200000000000000000L

    // This is a float that is slightly above the int64 max
    (Stdlib.Json.parse<Int64> "9.3E18") |> err =
      Result.Error "Can't parse JSON `9.3E18` as type `Int64` at path: `root`"

    Stdlib.Json.serialize<Int64> 9223372036854775807L =
      "9223372036854775807"

    Stdlib.Json.parse<Int64> "9223372036854775807" =
      Result.Ok 9223372036854775807L

    Stdlib.Json.serialize<Int64> -9223372036854775808L =
      "-9223372036854775808"

    Stdlib.Json.parse<Int64> "-9223372036854775808" =
      Result.Ok(-9223372036854775808L)


  module Errors =
    // TODO: review Float.tests for more values to test against

    // not ints
    (Stdlib.Json.parse<Int64> " ") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<Int64> "4a") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<Int64> "- 42") |> err = Result.Error "Not JSON"

    (Stdlib.Json.parse<Int64> "null") |> err =
      Result.Error "Can't parse JSON `null` as type `Int64` at path: `root`"

    (Stdlib.Json.parse<Int64> "true") |> err =
      Result.Error "Can't parse JSON `true` as type `Int64` at path: `root`"

    (Stdlib.Json.parse<Int64> "false") |> err =
      Result.Error "Can't parse JSON `false` as type `Int64` at path: `root`"

    (Stdlib.Json.parse<Int64> "\"42\"") |> err =
      Result.Error "Can't parse JSON `\"42\"` as type `Int64` at path: `root`"

    (Stdlib.Json.parse<Int64> "[42]") |> err =
      Result.Error "Can't parse JSON `[42]` as type `Int64` at path: `root`"

    (Stdlib.Json.parse<Int64> "{ \"key\": 42 }") |> err =
      Result.Error "Can't parse JSON `{ \"key\": 42 }` as type `Int64` at path: `root`"

    (Stdlib.Json.parse<Int64> "42.5") |> err =
      Result.Error "Can't parse JSON `42.5` as type `Int64` at path: `root`"

    (Stdlib.Json.parse<Int64> "\"42\n\"") |> err =
      Result.Error "Not JSON"


module UInt64 =
  module Basic =
    Stdlib.Json.serialize<UInt64> 0UL = "0"
    Stdlib.Json.serialize<UInt64> 12345UL = "12345"
    Stdlib.Json.parse<UInt64> "0" = Result.Ok 0UL
    Stdlib.Json.parse<UInt64> "0.0" = Result.Ok 0UL
    Stdlib.Json.parse<UInt64> "1.2E2" = Result.Ok 120UL
    Stdlib.Json.parse<UInt64> "1.2E+2" = Result.Ok 120UL
    Stdlib.Json.parse<UInt64> "1200E-1" = Result.Ok 120UL

  module UInt64Limits =
    // test the limits of uint64 (0 to 18446744073709551615)
    Stdlib.Json.serialize<UInt64> 0UL = "0"
    Stdlib.Json.serialize<UInt64> 18446744073709551615UL = "18446744073709551615"
    Stdlib.Json.parse<UInt64> "0" = Result.Ok 0UL

    Stdlib.Json.parse<UInt64> "18446744073709551615" = Result.Ok 18446744073709551615UL

    // First number that doesn't fit in an int64
    // TODO : The two commented tests below are failing due to a bug in the conversion from a double to a uint64 in dotnet runtime.
    // The tests pass inside the container, but fail in CI
    // (Stdlib.Json.parse<UInt64> "18446744073709551616") |> err =
    //   Result.Error "Can't parse JSON `18446744073709551616` as type `UInt64` at path: `root`"

    // This is a float that is a valid uint64
    // Stdlib.Json.parse<UInt64> "1.8446744073709551615E19" =  Result.Ok 18446744073709551615UL

    // This is a float that is slightly above the uint64 max
    (Stdlib.Json.parse<UInt64> "1.9E19") |> err = Result.Error
      "Can't parse JSON `1.9E19` as type `UInt64` at path: `root`"


  module Errors =
    (Stdlib.Json.parse<UInt64> " ") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<UInt64> "4a") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<UInt64> "- 42") |> err = Result.Error "Not JSON"

    (Stdlib.Json.parse<UInt64> "null") |> err = Result.Error
      "Can't parse JSON `null` as type `UInt64` at path: `root`"

    (Stdlib.Json.parse<UInt64> "true") |> err = Result.Error
      "Can't parse JSON `true` as type `UInt64` at path: `root`"

    (Stdlib.Json.parse<UInt64> "false") |> err = Result.Error
      "Can't parse JSON `false` as type `UInt64` at path: `root`"

    (Stdlib.Json.parse<UInt64> "\"42\"") |> err = Result.Error
      "Can't parse JSON `\"42\"` as type `UInt64` at path: `root`"

    (Stdlib.Json.parse<UInt64> "[42]") |> err = Result.Error
      "Can't parse JSON `[42]` as type `UInt64` at path: `root`"

    (Stdlib.Json.parse<UInt64> "{ \"key\": 42 }") |> err = Result.Error
      "Can't parse JSON `{ \"key\": 42 }` as type `UInt64` at path: `root`"

    (Stdlib.Json.parse<UInt64> "42.5") |> err = Result.Error
      "Can't parse JSON `42.5` as type `UInt64` at path: `root`"

    (Stdlib.Json.parse<UInt64> "\"42\n\"") |> err = Result.Error "Not JSON"


module Int8 =
  module Basic =
    Stdlib.Json.serialize<Int8> 0y = "0"
    Stdlib.Json.serialize<Int8> 123y = "123"
    Stdlib.Json.serialize<Int8> -123y = "-123"

    Stdlib.Json.parse<Int8> "0" = Result.Ok 0y
    Stdlib.Json.parse<Int8> "0.0" = Result.Ok 0y
    Stdlib.Json.parse<Int8> "-0.0" = Result.Ok 0y
    Stdlib.Json.parse<Int8> "-1.0" = Result.Ok -1y
    Stdlib.Json.parse<Int8> "1.2E2" = Result.Ok 120y
    Stdlib.Json.parse<Int8> "1.2E+2" = Result.Ok 120y
    Stdlib.Json.parse<Int8> "1200E-1" = Result.Ok 120y

  module Int8Limits =
    Stdlib.Json.serialize<Int8> -128y = "-128"
    Stdlib.Json.serialize<Int8> 127y = "127"

    Stdlib.Json.parse<Int8> "-128" = Result.Ok -128y
    Stdlib.Json.parse<Int8> "127" = Result.Ok 127y
    (Stdlib.Json.parse<Int8> "-129") |> err = Result.Error "Can't parse JSON `-129` as type `Int8` at path: `root`"
    (Stdlib.Json.parse<Int8> "128") |> err = Result.Error "Can't parse JSON `128` as type `Int8` at path: `root`"

  module Errors =
    (Stdlib.Json.parse<Int8> " ") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<Int8> "4a") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<Int8> "- 42") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<Int8> "null") |> err = Result.Error "Can't parse JSON `null` as type `Int8` at path: `root`"
    (Stdlib.Json.parse<Int8> "true") |> err = Result.Error "Can't parse JSON `true` as type `Int8` at path: `root`"
    (Stdlib.Json.parse<Int8> "false") |> err = Result.Error "Can't parse JSON `false` as type `Int8` at path: `root`"
    (Stdlib.Json.parse<Int8> "\"42\"") |> err = Result.Error "Can't parse JSON `\"42\"` as type `Int8` at path: `root`"
    (Stdlib.Json.parse<Int8> "[42]") |> err = Result.Error "Can't parse JSON `[42]` as type `Int8` at path: `root`"
    (Stdlib.Json.parse<Int8> "{ \"key\": 42 }") |> err = Result.Error "Can't parse JSON `{ \"key\": 42 }` as type `Int8` at path: `root`"
    (Stdlib.Json.parse<Int8> "42.5") |> err = Result.Error "Can't parse JSON `42.5` as type `Int8` at path: `root`"
    (Stdlib.Json.parse<Int8> "\"42\n\"") |> err = Result.Error "Not JSON"


module UInt8 =
  module Basic =
    Stdlib.Json.serialize<UInt8> 1uy = "1"
    Stdlib.Json.serialize<UInt8> 123uy = "123"
    Stdlib.Json.serialize<UInt8> 254uy = "254"

    Stdlib.Json.parse<UInt8> "0" = Result.Ok 0uy
    Stdlib.Json.parse<UInt8> "0.0" = Result.Ok 0uy
    Stdlib.Json.parse<UInt8> "-0.0" = Result.Ok 0uy // CLEANUP is this OK?
    Stdlib.Json.parse<UInt8> "1.2E2" = Result.Ok 120uy
    Stdlib.Json.parse<UInt8> "1.2E+2" = Result.Ok 120uy
    Stdlib.Json.parse<UInt8> "1200E-1" = Result.Ok 120uy


  module UInt8Limits =
    Stdlib.Json.serialize<UInt8> 0uy = "0"
    Stdlib.Json.serialize<UInt8> 255uy = "255"
    Stdlib.Json.parse<UInt8> "0" = Result.Ok 0uy
    Stdlib.Json.parse<UInt8> "255" = Result.Ok 255uy
    (Stdlib.Json.parse<UInt8> "-1") |> err = Result.Error "Can't parse JSON `-1` as type `UInt8` at path: `root`"
    (Stdlib.Json.parse<UInt8> "256") |> err = Result.Error "Can't parse JSON `256` as type `UInt8` at path: `root`"

  module Errors =
    (Stdlib.Json.parse<UInt8> " ") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<UInt8> "4a") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<UInt8> "- 42") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<UInt8> "null") |> err = Result.Error "Can't parse JSON `null` as type `UInt8` at path: `root`"
    (Stdlib.Json.parse<UInt8> "true") |> err = Result.Error "Can't parse JSON `true` as type `UInt8` at path: `root`"
    (Stdlib.Json.parse<UInt8> "false") |> err = Result.Error "Can't parse JSON `false` as type `UInt8` at path: `root`"
    (Stdlib.Json.parse<UInt8> "\"42\"") |> err = Result.Error "Can't parse JSON `\"42\"` as type `UInt8` at path: `root`"
    (Stdlib.Json.parse<UInt8> "[42]") |> err = Result.Error "Can't parse JSON `[42]` as type `UInt8` at path: `root`"
    (Stdlib.Json.parse<UInt8> "{ \"key\": 42 }") |> err = Result.Error "Can't parse JSON `{ \"key\": 42 }` as type `UInt8` at path: `root`"
    (Stdlib.Json.parse<UInt8> "42.5") |> err = Result.Error "Can't parse JSON `42.5` as type `UInt8` at path: `root`"
    (Stdlib.Json.parse<UInt8> "\"42\n\"") |> err = Result.Error "Not JSON"


module Int16 =
  module Basic =
    Stdlib.Json.serialize<Int16> 0s = "0"
    Stdlib.Json.serialize<Int16> 123s = "123"
    Stdlib.Json.serialize<Int16> -123s = "-123"

    Stdlib.Json.parse<Int16> "0" = Result.Ok 0s
    Stdlib.Json.parse<Int16> "0.0" = Result.Ok 0s
    Stdlib.Json.parse<Int16> "-0.0" = Result.Ok 0s
    Stdlib.Json.parse<Int16> "-1.0" = Result.Ok -1s
    Stdlib.Json.parse<Int16> "1.2E2" = Result.Ok 120s
    Stdlib.Json.parse<Int16> "1.2E+2" = Result.Ok 120s
    Stdlib.Json.parse<Int16> "1200E-1" = Result.Ok 120s


  module Int16Limits =
    Stdlib.Json.serialize<Int16> -32768s = "-32768"
    Stdlib.Json.serialize<Int16> 32767s = "32767"

    Stdlib.Json.parse<Int16> "-32768" = Result.Ok -32768s

    Stdlib.Json.parse<Int16> "32767" = Result.Ok 32767s

    (Stdlib.Json.parse<Int16> "-32769") |> err = Result.Error
      "Can't parse JSON `-32769` as type `Int16` at path: `root`"

    (Stdlib.Json.parse<Int16> "32768") |> err = Result.Error
      "Can't parse JSON `32768` as type `Int16` at path: `root`"

  module Errors =
    (Stdlib.Json.parse<Int16> " ") |> err = Result.Error "Not JSON"

    (Stdlib.Json.parse<Int16> "4a") |> err = Result.Error "Not JSON"

    (Stdlib.Json.parse<Int16> "- 42") |> err = Result.Error "Not JSON"

    (Stdlib.Json.parse<Int16> "null") |> err = Result.Error
      "Can't parse JSON `null` as type `Int16` at path: `root`"

    (Stdlib.Json.parse<Int16> "true") |> err = Result.Error
      "Can't parse JSON `true` as type `Int16` at path: `root`"

    (Stdlib.Json.parse<Int16> "false") |> err = Result.Error
      "Can't parse JSON `false` as type `Int16` at path: `root`"

    (Stdlib.Json.parse<Int16> "\"42\"") |> err = Result.Error
      "Can't parse JSON `\"42\"` as type `Int16` at path: `root`"

    (Stdlib.Json.parse<Int16> "[42]") |> err = Result.Error
      "Can't parse JSON `[42]` as type `Int16` at path: `root`"

    (Stdlib.Json.parse<Int16> "{ \"key\": 42 }") |> err = Result.Error
      "Can't parse JSON `{ \"key\": 42 }` as type `Int16` at path: `root`"

    (Stdlib.Json.parse<Int16> "42.5") |> err = Result.Error
      "Can't parse JSON `42.5` as type `Int16` at path: `root`"

    (Stdlib.Json.parse<Int16> "\"42\n\"") |> err = Result.Error "Not JSON"


module UInt16 =
  module Basic =
    Stdlib.Json.serialize<UInt16> 0us = "0"
    Stdlib.Json.serialize<UInt16> 123us = "123"

    Stdlib.Json.parse<UInt16> "0" = Result.Ok 0us

    Stdlib.Json.parse<UInt16> "0.0" = Result.Ok 0us

    Stdlib.Json.parse<UInt16> "1.2E2" = Result.Ok 120us

    Stdlib.Json.parse<UInt16> "1.2E+2" = Result.Ok 120us

    Stdlib.Json.parse<UInt16> "1200E-1" = Result.Ok 120us

  module UInt16Limits =
    Stdlib.Json.serialize<UInt16> 0us = "0"
    Stdlib.Json.serialize<UInt16> 65535us = "65535"

    Stdlib.Json.parse<UInt16> "0" = Result.Ok 0us

    Stdlib.Json.parse<UInt16> "65535" = Result.Ok 65535us

    (Stdlib.Json.parse<UInt16> "-1") |> err = Result.Error
      "Can't parse JSON `-1` as type `UInt16` at path: `root`"

    (Stdlib.Json.parse<UInt16> "65536") |> err = Result.Error
      "Can't parse JSON `65536` as type `UInt16` at path: `root`"

  module Errors =
    (Stdlib.Json.parse<UInt16> " ") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<UInt16> "4a") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<UInt16> "- 42") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<UInt16> "\"42\n\"") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<UInt16> "null") |> err = Result.Error "Can't parse JSON `null` as type `UInt16` at path: `root`"
    (Stdlib.Json.parse<UInt16> "true") |> err = Result.Error "Can't parse JSON `true` as type `UInt16` at path: `root`"
    (Stdlib.Json.parse<UInt16> "false") |> err = Result.Error "Can't parse JSON `false` as type `UInt16` at path: `root`"
    (Stdlib.Json.parse<UInt16> "\"42\"") |> err = Result.Error "Can't parse JSON `\"42\"` as type `UInt16` at path: `root`"
    (Stdlib.Json.parse<UInt16> "[42]") |> err = Result.Error "Can't parse JSON `[42]` as type `UInt16` at path: `root`"
    (Stdlib.Json.parse<UInt16> "{ \"key\": 42 }") |> err = Result.Error "Can't parse JSON `{ \"key\": 42 }` as type `UInt16` at path: `root`"
    (Stdlib.Json.parse<UInt16> "42.5") |> err = Result.Error "Can't parse JSON `42.5` as type `UInt16` at path: `root`"


module Int32 =
  module Basic =
    Stdlib.Json.serialize<Int32> 0l = "0"
    Stdlib.Json.serialize<Int32> 123l = "123"
    Stdlib.Json.serialize<Int32> -123l = "-123"

    Stdlib.Json.parse<Int32> "0" = Result.Ok 0l
    Stdlib.Json.parse<Int32> "0.0" = Result.Ok 0l
    Stdlib.Json.parse<Int32> "-0.0" = Result.Ok 0l
    Stdlib.Json.parse<Int32> "-1.0" = Result.Ok -1l
    Stdlib.Json.parse<Int32> "1.2E2" = Result.Ok 120l
    Stdlib.Json.parse<Int32> "1.2E+2" = Result.Ok 120l
    Stdlib.Json.parse<Int32> "1200E-1" = Result.Ok 120l

  module Int32Limits =
    Stdlib.Json.serialize<Int32> -2147483648l = "-2147483648"
    Stdlib.Json.serialize<Int32> 2147483647l = "2147483647"

    Stdlib.Json.parse<Int32> "-2147483648" = Result.Ok -2147483648l
    Stdlib.Json.parse<Int32> "2147483647" = Result.Ok 2147483647l

    (Stdlib.Json.parse<Int32> "-2147483649") |> err = Result.Error "Can't parse JSON `-2147483649` as type `Int32` at path: `root`"
    (Stdlib.Json.parse<Int32> "2147483648") |> err = Result.Error "Can't parse JSON `2147483648` as type `Int32` at path: `root`"

  module Errors =
    (Stdlib.Json.parse<Int32> " ") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<Int32> "4a") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<Int32> "- 42") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<Int32> "\"42\n\"") |> err = Result.Error "Not JSON"

    (Stdlib.Json.parse<Int32> "null") |> err = Result.Error "Can't parse JSON `null` as type `Int32` at path: `root`"
    (Stdlib.Json.parse<Int32> "true") |> err = Result.Error "Can't parse JSON `true` as type `Int32` at path: `root`"
    (Stdlib.Json.parse<Int32> "false") |> err = Result.Error "Can't parse JSON `false` as type `Int32` at path: `root`"
    (Stdlib.Json.parse<Int32> "\"42\"") |> err = Result.Error "Can't parse JSON `\"42\"` as type `Int32` at path: `root`"
    (Stdlib.Json.parse<Int32> "[42]") |> err = Result.Error "Can't parse JSON `[42]` as type `Int32` at path: `root`"
    (Stdlib.Json.parse<Int32> "{ \"key\": 42 }") |> err = Result.Error "Can't parse JSON `{ \"key\": 42 }` as type `Int32` at path: `root`"
    (Stdlib.Json.parse<Int32> "42.5") |> err = Result.Error "Can't parse JSON `42.5` as type `Int32` at path: `root`"


module UInt32 =
  module Basic =
    Stdlib.Json.serialize<UInt32> 0ul = "0"
    Stdlib.Json.serialize<UInt32> 123ul = "123"

    Stdlib.Json.parse<UInt32> "0" = Result.Ok 0ul
    Stdlib.Json.parse<UInt32> "0.0" = Result.Ok 0ul
    Stdlib.Json.parse<UInt32> "-0.0" = Result.Ok 0ul
    Stdlib.Json.parse<UInt32> "1.2E2" = Result.Ok 120ul
    Stdlib.Json.parse<UInt32> "1.2E+2" = Result.Ok 120ul
    Stdlib.Json.parse<UInt32> "1200E-1" = Result.Ok 120ul

  module UInt32Limits =
    Stdlib.Json.serialize<UInt32> 0ul = "0"
    Stdlib.Json.serialize<UInt32> 4294967295ul = "4294967295"

    Stdlib.Json.parse<UInt32> "0" = Result.Ok 0ul
    Stdlib.Json.parse<UInt32> "4294967295" = Result.Ok 4294967295ul

    (Stdlib.Json.parse<UInt32> "-1") |> err = Result.Error
      "Can't parse JSON `-1` as type `UInt32` at path: `root`"

    (Stdlib.Json.parse<UInt32> "4294967296") |> err = Result.Error
      "Can't parse JSON `4294967296` as type `UInt32` at path: `root`"

  module Errors =
    (Stdlib.Json.parse<UInt32> " ") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<UInt32> "4a") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<UInt32> "- 42") |> err = Result.Error "Not JSON"

    (Stdlib.Json.parse<UInt32> "null") |> err = Result.Error
      "Can't parse JSON `null` as type `UInt32` at path: `root`"

    (Stdlib.Json.parse<UInt32> "true") |> err = Result.Error
      "Can't parse JSON `true` as type `UInt32` at path: `root`"

    (Stdlib.Json.parse<UInt32> "false") |> err = Result.Error
      "Can't parse JSON `false` as type `UInt32` at path: `root`"

    (Stdlib.Json.parse<UInt32> "\"42\"") |> err = Result.Error
      "Can't parse JSON `\"42\"` as type `UInt32` at path: `root`"

    (Stdlib.Json.parse<UInt32> "[42]") |> err = Result.Error
      "Can't parse JSON `[42]` as type `UInt32` at path: `root`"

    (Stdlib.Json.parse<UInt32> "{ \"key\": 42 }") |> err = Result.Error
      "Can't parse JSON `{ \"key\": 42 }` as type `UInt32` at path: `root`"

    (Stdlib.Json.parse<UInt32> "42.5") |> err = Result.Error
      "Can't parse JSON `42.5` as type `UInt32` at path: `root`"

    (Stdlib.Json.parse<UInt32> "\"42\n\"") |> err = Result.Error "Not JSON"


module Int128 =
  module Basic =
    Stdlib.Json.serialize<Int128> 0Q = "0"
    Stdlib.Json.serialize<Int128> 12345Q = "12345"
    Stdlib.Json.serialize<Int128> -12345Q = "-12345"
    Stdlib.Json.parse<Int128> "0" = Result.Ok 0Q
    Stdlib.Json.parse<Int128> "0.0" = Result.Ok 0Q
    Stdlib.Json.parse<Int128> "-0.0" = Result.Ok 0Q
    Stdlib.Json.parse<Int128> "-1.0" = Result.Ok(-1Q)
    Stdlib.Json.parse<Int128> "1.2E2" = Result.Ok 120Q
    Stdlib.Json.parse<Int128> "1.2E+2" = Result.Ok 120Q
    Stdlib.Json.parse<Int128> "1200E-1" = Result.Ok 120Q

  module Int128Limits =
    Stdlib.Json.serialize<Int128> -170141183460469231731687303715884105728Q = "-170141183460469231731687303715884105728"
    Stdlib.Json.serialize<Int128> 170141183460469231731687303715884105727Q = "170141183460469231731687303715884105727"

    Stdlib.Json.parse<Int128> "-170141183460469231731687303715884105728" = Result.Ok
      -170141183460469231731687303715884105728Q

    Stdlib.Json.parse<Int128> "170141183460469231731687303715884105727" = Result.Ok
      170141183460469231731687303715884105727Q


    // First number that doesn't fit in an Int128
    (Stdlib.Json.parse<Int128> "170141183460469231731687303715884105728") |> err = Result.Error
      "Can't parse JSON `170141183460469231731687303715884105728` as type `Int128` at path: `root`"

    // This is a float that is a valid Int128
    Stdlib.Json.parse<Int128> "1.7E38" = Result.Ok
      169999999999999998061923293023115935744Q

    // This is a float that is slightly above the Int128 max
    (Stdlib.Json.parse<Int128> "1.8E38") |> err = Result.Error
      "Can't parse JSON `1.8E38` as type `Int128` at path: `root`"

    // A large negative number that is within Int128 range
    Stdlib.Json.parse<Int128> "-1.7E38" = Result.Ok
      -169999999999999998061923293023115935744Q

    // A negative number that is too small for Int128
    (Stdlib.Json.parse<Int128> "-1.8E38") |> err = Result.Error
      "Can't parse JSON `-1.8E38` as type `Int128` at path: `root`"


  module Errors =
    (Stdlib.Json.parse<Int128> " ") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<Int128> "4a") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<Int128> "- 42") |> err = Result.Error "Not JSON"

    (Stdlib.Json.parse<Int128> "null") |> err = Result.Error
      "Can't parse JSON `null` as type `Int128` at path: `root`"

    (Stdlib.Json.parse<Int128> "true") |> err = Result.Error
      "Can't parse JSON `true` as type `Int128` at path: `root`"

    (Stdlib.Json.parse<Int128> "false") |> err = Result.Error
      "Can't parse JSON `false` as type `Int128` at path: `root`"

    (Stdlib.Json.parse<Int128> "\"42\"") |> err = Result.Error
      "Can't parse JSON `\"42\"` as type `Int128` at path: `root`"

    (Stdlib.Json.parse<Int128> "[42]") |> err = Result.Error
      "Can't parse JSON `[42]` as type `Int128` at path: `root`"

    (Stdlib.Json.parse<Int128> "{ \"key\": 42 }") |> err = Result.Error
      "Can't parse JSON `{ \"key\": 42 }` as type `Int128` at path: `root`"

    (Stdlib.Json.parse<Int128> "42.5") |> err = Result.Error
      "Can't parse JSON `42.5` as type `Int128` at path: `root`"

    (Stdlib.Json.parse<Int128> "\"42\n\"") |> err = Result.Error "Not JSON"

    // (-1.7014118346046923E+38) this result is out of range for Int128 and is wrapped around to the min value
    Stdlib.Json.parse<Int128> "-170141183460469231731687303715884105800" = Result.Ok
      -170141183460469231731687303715884105728Q

    (Stdlib.Json.parse<Int128> "170141183460469231731687303715884105800") |> err = Result.Error
      "Can't parse JSON `170141183460469231731687303715884105800` as type `Int128` at path: `root`"

module UInt128 =
  module Basic =
    Stdlib.Json.serialize<UInt128> 0Z = "0"
    Stdlib.Json.serialize<UInt128> 12345Z = "12345"
    Stdlib.Json.parse<UInt128> "0" = Result.Ok 0Z
    Stdlib.Json.parse<UInt128> "0.0" = Result.Ok 0Z
    Stdlib.Json.parse<UInt128> "-0.0" = Result.Ok 0Z
    Stdlib.Json.parse<UInt128> "1.2E2" = Result.Ok 120Z
    Stdlib.Json.parse<UInt128> "1.2E+2" = Result.Ok 120Z
    Stdlib.Json.parse<UInt128> "1200E-1" = Result.Ok 120Z

  module UInt128Limits =
    Stdlib.Json.serialize<UInt128> 0Z = "0"

    Stdlib.Json.parse<UInt128> "340282366920938463463374607431768211455" = Result.Ok
      340282366920938463463374607431768211455Z

    // First number that doesn't fit in a UInt128
    (Stdlib.Json.parse<UInt128> "340282366920938463463374607431768211456") |> err = Result.Error
      "Can't parse JSON `340282366920938463463374607431768211456` as type `UInt128` at path: `root`"

    // This is a large number that is a valid UInt128
    Stdlib.Json.parse<UInt128> "3.4E38" = Result.Ok
      339999999999999996123846586046231871488Z

    // This is a number that is slightly above the UInt128 max
    (Stdlib.Json.parse<UInt128> "3.5E38") |> err = Result.Error
      "Can't parse JSON `3.5E38` as type `UInt128` at path: `root`"

    (Stdlib.Json.parse<UInt128> "-1") |> err = Result.Error
      "Can't parse JSON `-1` as type `UInt128` at path: `root`"


  module Errors =
    (Stdlib.Json.parse<UInt128> " ") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<UInt128> "4a") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<UInt128> "- 42") |> err = Result.Error "Not JSON"

    (Stdlib.Json.parse<UInt128> "null") |> err = Result.Error
      "Can't parse JSON `null` as type `UInt128` at path: `root`"

    (Stdlib.Json.parse<UInt128> "true") |> err = Result.Error
      "Can't parse JSON `true` as type `UInt128` at path: `root`"

    (Stdlib.Json.parse<UInt128> "false") |> err = Result.Error
      "Can't parse JSON `false` as type `UInt128` at path: `root`"

    (Stdlib.Json.parse<UInt128> "\"42\"") |> err = Result.Error
      "Can't parse JSON `\"42\"` as type `UInt128` at path: `root`"

    (Stdlib.Json.parse<UInt128> "[42]") |> err = Result.Error
      "Can't parse JSON `[42]` as type `UInt128` at path: `root`"

    (Stdlib.Json.parse<UInt128> "{ \"key\": 42 }") |> err = Result.Error
      "Can't parse JSON `{ \"key\": 42 }` as type `UInt128` at path: `root`"

    (Stdlib.Json.parse<UInt128> "42.5") |> err = Result.Error
      "Can't parse JSON `42.5` as type `UInt128` at path: `root`"

    (Stdlib.Json.parse<UInt128> "\"42\n\"") |> err = Result.Error "Not JSON"

    (Stdlib.Json.parse<UInt128> "340282366920938463463374607431768211456") |> err = Result.Error
      "Can't parse JSON `340282366920938463463374607431768211456` as type `UInt128` at path: `root`"


module Float =
  // TODO: test the upper/lower bounds
  // TODO: test highly-precise numbers
  // TODO: review Float.tests for more values to test against

  Stdlib.Json.serialize<Float> 0.0 = "0.0"
  Stdlib.Json.serialize<Float> 1.0 = "1.0"
  Stdlib.Json.serialize<Float> 0.1 = "0.1"

  Stdlib.Json.serialize<Float> (2.0 / 3.0) = "0.6666666666666666"

  Stdlib.Json.serialize<Float> 12345.67890 = "12345.6789"
  Stdlib.Json.serialize<Float> -12345.67890 = "-12345.6789"

  // ints as floats
  Stdlib.Json.parse<Float> "0.0" = Result.Ok 0.0
  Stdlib.Json.parse<Float> "0" = Result.Ok 0.0
  Stdlib.Json.parse<Float> "123" = Result.Ok 123.0


  Stdlib.Json.parse<Float> "12345.67890" = Result.Ok 12345.67890

  Stdlib.Json.parse<Float> "-12345.67890" = Result.Ok -12345.67890

  Stdlib.Json.parse<Float> " 42.0 " = Result.Ok 42.0
  Stdlib.Json.parse<Float> " -42.0 " = Result.Ok -42.0
  Stdlib.Json.parse<Float> "1e3" = Result.Ok 1000.0
  Stdlib.Json.parse<Float> "-1e3" = Result.Ok -1000.0

  Stdlib.Json.serialize<Float> 3.14159265358979323846 = "3.141592653589793"

  Stdlib.Json.serialize<Float> 1.618033988749895 = "1.618033988749895"

  Stdlib.Json.parse<Float> "1.0000001" = Result.Ok 1.0000001

  Stdlib.Json.parse<Float> "-1.00000001" = Result.Ok -1.00000001

  Stdlib.Json.parse<Float> "-2147483647.8" = Result.Ok -2147483647.8


  Stdlib.Json.parse<Float> "17.55042081" = Result.Ok 17.55042081

  Stdlib.Json.parse<Float> "2147483647.000009" = Result.Ok 2147483647.000009

  Stdlib.Json.parse<Float> "-2367.9267" = Result.Ok -2367.9267

  Stdlib.Json.parse<Float> "0.6999999999999999555910790149937383830547332763671875" = Result.Ok
    0.6999999999999999555910790149937383830547332763671875

  Stdlib.Json.parse<Float> "0.7999999999" = Result.Ok 0.7999999999

  module Values =
    Stdlib.Json.serialize<Float> Builtin.testNegativeInfinity_v0 = "\"-Infinity\""
    Stdlib.Json.parse<Float> "\"-Infinity\"" = Result.Ok Builtin.testNegativeInfinity_v0
    Stdlib.Json.serialize<Float> Builtin.testInfinity_v0 = "\"Infinity\""
    Stdlib.Json.parse<Float> "\"Infinity\"" = Result.Ok Builtin.testInfinity_v0
    Stdlib.Json.serialize<Float> Builtin.testNan_v0 = "\"NaN\""
    Stdlib.Json.parse<Float> "\"NaN\"" = Result.Ok Builtin.testNan_v0



  module Errors =
    (Stdlib.Json.parse<Float> "e") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<Float> "pi") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<Float> " -42 . 0 ") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<Float> "0") |> err = Result.Ok 0.0
    (Stdlib.Json.parse<Float> " ") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<Float> "4a") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<Float> "- 42.0") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<Float> "-141s") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<Float> "null") |> err = Result.Error "Can't parse JSON `null` as type `Float` at path: `root`"
    (Stdlib.Json.parse<Float> "true") |> err = Result.Error "Can't parse JSON `true` as type `Float` at path: `root`"
    (Stdlib.Json.parse<Float> "false") |> err = Result.Error "Can't parse JSON `false` as type `Float` at path: `root`"
    (Stdlib.Json.parse<Float> "\"42\"") |> err = Result.Error "Can't parse JSON `\"42\"` as type `Float` at path: `root`"
    (Stdlib.Json.parse<Float> "[42]") |> err = Result.Error "Can't parse JSON `[42]` as type `Float` at path: `root`"
    (Stdlib.Json.parse<Float> "{ \"key\": 42 }") |> err = Result.Error "Can't parse JSON `{ \"key\": 42 }` as type `Float` at path: `root`"
    (Stdlib.Json.parse<Float> "\"42\n\"") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<Float> "000000.9") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<Float> "-000000.9") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<Float> "-00000000.000") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<Float> "00000000.000") |> err = Result.Error "Not JSON"
    (Stdlib.Json.parse<Float> "\"65.0\"") |> err = Result.Error "Can't parse JSON `\"65.0\"` as type `Float` at path: `root`"



module Char =
  let charFromString (s: String) : Char =
    (Stdlib.String.head s) |> Builtin.unwrap

  Stdlib.Json.serialize<Char> 'a' = "\"a\""
  Stdlib.Json.parse<Char> "\"a\"" = Result.Ok 'a'

  module SimpleEmoji =
    Stdlib.Json.serialize<Char> ("üòÇ" |> charFromString) = "\"\\uD83D\\uDE02\""

    Stdlib.Json.parse<Char> "\"üòÇ\"" = Result.Ok(charFromString "üòÇ")
    Stdlib.Json.parse<Char> "\"\\uD83D\\uDE02\"" = Result.Ok(charFromString "üòÇ")

  module ComplexEmoji =
    Stdlib.Json.serialize<Char> (charFromString "üë©‚Äçüë©‚Äçüëß‚Äçüë¶") = "\"\\uD83D\\uDC69‚Äç\\uD83D\\uDC69‚Äç\\uD83D\\uDC67‚Äç\\uD83D\\uDC66\""

    Stdlib.Json.parse<Char>
      "\"\\uD83D\\uDC69‚Äç\\uD83D\\uDC69‚Äç\\uD83D\\uDC67‚Äç\\uD83D\\uDC66\"" = Result.Ok(
      charFromString "üë©‚Äçüë©‚Äçüëß‚Äçüë¶"
    )

    Stdlib.Json.parse<Char> "\"üë©‚Äçüë©‚Äçüëß‚Äçüë¶\"" = Result.Ok(
      "üë©‚Äçüë©‚Äçüëß‚Äçüë¶" |> charFromString
    )

  Stdlib.Json.serialize<Char> (charFromString "≈Å") = "\"≈Å\""
  Stdlib.Json.parse<Char> "\"≈Å\"" = Result.Ok '≈Å'

  module Errors =
    (Stdlib.Json.parse<Char> "\"test\"") |> err = Result.Error
      "Can't parse JSON `\"test\"` as type `Char` at path: `root`"

    (Stdlib.Json.parse<Char> "\"\"") |> err = Result.Error
      "Can't parse JSON `\"\"` as type `Char` at path: `root`"

    (Stdlib.Json.parse<Char> "62") |> err = Result.Error
      "Can't parse JSON `62` as type `Char` at path: `root`"


module String =
  Stdlib.Json.serialize<String> "abc" = "\"abc\""
  Stdlib.Json.parse<String> "\"abc\"" = Result.Ok "abc"

  Stdlib.Json.serialize<String> "" = "\"\""
  Stdlib.Json.parse<String> "\"\"" = Result.Ok ""

  Stdlib.Json.serialize<String> "≈º√≥≈Çw" = "\"≈º√≥≈Çw\""
  Stdlib.Json.parse<String> "\"≈º√≥≈Çw\"" = Result.Ok "≈º√≥≈Çw"

  Stdlib.Json.serialize<String> "üë®‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë®üë©‚Äçüë©‚Äçüëß‚Äçüë¶üè≥Ô∏è‚Äç‚ößÔ∏è‚ÄçÔ∏èüáµüá∑" = "\"\\uD83D\\uDC68‚Äç‚ù§Ô∏è‚Äç\\uD83D\\uDC8B‚Äç\\uD83D\\uDC68\\uD83D\\uDC69‚Äç\\uD83D\\uDC69‚Äç\\uD83D\\uDC67‚Äç\\uD83D\\uDC66\\uD83C\\uDFF3Ô∏è‚Äç‚ößÔ∏è‚ÄçÔ∏è\\uD83C\\uDDF5\\uD83C\\uDDF7\""

  Stdlib.Json.parse<String> "\"üë®‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë®üë©‚Äçüë©‚Äçüëß‚Äçüë¶üè≥Ô∏è‚Äç‚ößÔ∏è‚ÄçÔ∏èüáµüá∑\"" = Result.Ok "üë®‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë®üë©‚Äçüë©‚Äçüëß‚Äçüë¶üè≥Ô∏è‚Äç‚ößÔ∏è‚ÄçÔ∏èüáµüá∑"
  Stdlib.Json.serialize<String> "üë©‚Äçüë©‚Äçüëß‚Äçüë¶" = "\"\\uD83D\\uDC69‚Äç\\uD83D\\uDC69‚Äç\\uD83D\\uDC67‚Äç\\uD83D\\uDC66\""

  Stdlib.Json.parse<String> "\"üë©‚Äçüë©‚Äçüëß‚Äçüë¶\"" = Result.Ok "üë©‚Äçüë©‚Äçüëß‚Äçüë¶"

  Stdlib.Json.parse<String>
    "\"\\uD83D\\uDC69‚Äç\\uD83D\\uDC69‚Äç\\uD83D\\uDC67‚Äç\\uD83D\\uDC66\"" = Result.Ok
    "üë©‚Äçüë©‚Äçüëß‚Äçüë¶"

  Stdlib.Json.serialize<String>
    "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non risus. Suspendisse lectus tortor, dignissim sit amet, adipiscing nec, ultricies sed, dolor." = "\"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non risus. Suspendisse lectus tortor, dignissim sit amet, adipiscing nec, ultricies sed, dolor.\""

  Stdlib.Json.parse<String>
    "\"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non risus. Suspendisse lectus tortor, dignissim sit amet, adipiscing nec, ultricies sed, dolor.\"" = Result.Ok
    "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non risus. Suspendisse lectus tortor, dignissim sit amet, adipiscing nec, ultricies sed, dolor."


  Stdlib.Json.serialize<String> (Stdlib.String.repeat_v0 "a" 100L) = "\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\""

  Stdlib.Json.parse<String>
    "\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"" = Result
    .Ok(Stdlib.String.repeat_v0 "a" 100L)


module DateTime =
  let d (datestr: String) : DateTime =
    (Stdlib.DateTime.parse datestr) |> Builtin.unwrap

  // now-ish
  Stdlib.Json.serialize<DateTime> (d "2023-07-28T22:42:36Z") = "\"2023-07-28T22:42:36Z\""

  Stdlib.Json.parse<DateTime> "\"2023-07-28T22:42:36Z\"" = Result.Ok(
    d "2023-07-28T22:42:36Z"
  )

  // epoch
  Stdlib.Json.serialize<DateTime> (d "1969-07-28T22:42:36Z") = "\"1969-07-28T22:42:36Z\""

  Stdlib.Json.parse<DateTime> "\"1969-07-28T22:42:36Z\"" = Result.Ok(
    d "1969-07-28T22:42:36Z"
  )

  // before epoch
  Stdlib.Json.serialize<DateTime> (d "1402-07-28T22:42:36Z") = "\"1402-07-28T22:42:36Z\""

  Stdlib.Json.parse<DateTime> "\"1402-07-28T22:42:36Z\"" = Result.Ok(
    d "1402-07-28T22:42:36Z"
  )

  // far in future
  Stdlib.Json.serialize<DateTime> (d "3023-07-28T22:42:36Z") = "\"3023-07-28T22:42:36Z\""

  Stdlib.Json.parse<DateTime> "\"3023-07-28T22:42:36Z\"" = Result.Ok(
    d "3023-07-28T22:42:36Z"
  )

  module Errors =
    (Stdlib.Json.parse<DateTime> "\"3023-07-28T22:42:36\"") |> err = Result.Error
      "Can't parse JSON `\"3023-07-28T22:42:36\"` as type `DateTime` at path: `root`"

    (Stdlib.Json.parse<DateTime> "\"2023-07-28\"") |> err = Result.Error
      "Can't parse JSON `\"2023-07-28\"` as type `DateTime` at path: `root`"

    (Stdlib.Json.parse<DateTime> "1") |> err = Result.Error
      "Can't parse JSON `1` as type `DateTime` at path: `root`"


module Uuid =
  let uuid (s: String) : Uuid =
    (Stdlib.Uuid.parse_v0 s) |> Builtin.unwrap

  // empty
  Stdlib.Json.serialize<Uuid> (uuid "00000000-0000-0000-0000-000000000000") = "\"00000000-0000-0000-0000-000000000000\""

  Stdlib.Json.parse<Uuid> "\"00000000-0000-0000-0000-000000000000\"" = Result.Ok(
    uuid "00000000-0000-0000-0000-000000000000"
  )

  // normal
  Stdlib.Json.serialize<Uuid> (uuid "3700adbc-7a46-4ff4-81d3-45afb03f6e2d") = "\"3700adbc-7a46-4ff4-81d3-45afb03f6e2d\""

  Stdlib.Json.parse<Uuid> "\"3700adbc-7a46-4ff4-81d3-45afb03f6e2d\"" = Result.Ok(
    uuid "3700adbc-7a46-4ff4-81d3-45afb03f6e2d"
  )

  Stdlib.Json.serialize<Uuid> (uuid "11111111-2222-3333-4444-555555555555") = "\"11111111-2222-3333-4444-555555555555\""

  Stdlib.Json.parse<Uuid> "\"11111111-2222-3333-4444-555555555555\"" = Result.Ok(
    uuid "11111111-2222-3333-4444-555555555555"
  )

  module Errors =
    // needs one more 0 at the end
    (Stdlib.Json.parse<Uuid> "\"00000000-0000-0000-0000-00000000000\"") |> err = Result.Error
      "Can't parse JSON `\"00000000-0000-0000-0000-00000000000\"` as type `Uuid` at path: `root`"


module BadTypes =
  // these cause an error in the type checker
  // Stdlib.Json.parse<'a> "5" = Result.Ok []
  // Stdlib.Json.serialize<'a> 5 = Result.Error "dunno what happens"

  Stdlib.Json.parse<Int64 -> Int64> "{}" =
    Builtin.testDerrorMessage
      "Unsupported type in JSON: (Int64) -> Int64. Some types are not supported in Json serialization, and cannot be used as arguments to Builtin.jsonParse or Builtin.jsonSerialize"

  Stdlib.Json.serialize<Int64 -> Int64> (fun i -> 5) =
    Builtin.testDerrorMessage
      "Cannot serialize (lambda) into JSON"


module List =
  type MyString = String

  Stdlib.Json.serialize<List<Int64>> [] = "[]"
  Stdlib.Json.parse<List<Int64>> "[]" = Result.Ok []

  Stdlib.Json.serialize<List<Int64>> [ 1L; 2L; 3L ] = "[1,2,3]"

  Stdlib.Json.parse<List<Int64>> "[1,2,3]" = Result.Ok [ 1L; 2L; 3L ]

  (Stdlib.Json.parse<List<Int64>> "[1,2,3,]") |> err = Result.Error "Not JSON"

  Stdlib.Json.serialize<List<List<List<Int64>>>>
    [ [ [ 1L; 2L; 3L ]; [ 4L; 5L; 6L ] ]; [ [ 7L; 8L ]; [ 9L; 0L ] ] ] = "[[[1,2,3],[4,5,6]],[[7,8],[9,0]]]"

  Stdlib.Json.parse<List<List<List<Int64>>>> "[[[1,2,3],[4,5,6]],[[7,8],[9,0]]]" = Result.Ok
    [ [ [ 1L; 2L; 3L ]; [ 4L; 5L; 6L ] ]; [ [ 7L; 8L ]; [ 9L; 0L ] ] ]

  Stdlib.Json.parse<List<Dict<String>>>
    """[{"name": "Alice", "role": "admin"}, {"name": "Bob", "role": "user"}, {"name": "Charlie", "role": "user"}]""" = Result.Ok
    [ Dict { name = "Alice"; role = "admin" }
      Dict { name = "Bob"; role = "user" }
      Dict { name = "Charlie"; role = "user" } ]

  Stdlib.Json.serialize<List<Dict<String>>>
    [ Dict { name = "Alice"; role = "admin" }
      Dict { name = "Bob"; role = "user" }
      Dict { name = "Charlie"; role = "user" } ] = """[{"name":"Alice","role":"admin"},{"name":"Bob","role":"user"},{"name":"Charlie","role":"user"}]"""

  Stdlib.Json.parse<List<Person>>
    """[{"Name": "Alice", "Age": 42}, {"Name": "Bob", "Age": 27}, {"Name": "Charlie", "Age": 99}]""" = Result.Ok
    [ Person { Name = "Alice"; Age = 42L }
      Person { Name = "Bob"; Age = 27L }
      Person { Name = "Charlie"; Age = 99L } ]

  Stdlib.Json.serialize<List<Person>>
    [ Person { Name = "Alice"; Age = 42L }
      Person { Name = "Bob"; Age = 27L }
      Person { Name = "Charlie"; Age = 99L } ] = """[{"Age":42,"Name":"Alice"},{"Age":27,"Name":"Bob"},{"Age":99,"Name":"Charlie"}]"""

  Stdlib.Json.parse<List<Dict<MyString>>>
    """[{"name": "Alice", "role": "admin"}, {"name": "Bob", "role": "user"}, {"name": "Charlie", "role": "user"}]""" = Result.Ok
    [ Dict { name = "Alice"; role = "admin" }
      Dict { name = "Bob"; role = "user" }
      Dict { name = "Charlie"; role = "user" } ]

  module Errors =
    Stdlib.Json.serialize<List<Int64>> [ 1L, 2L, "three" ] =
      Builtin.testDerrorMessage
        "Darklang.Stdlib.Json.serialize's 1st parameter `value` expects List<Int64>, but got (Int64 * Int64 * String) ((1, 2, \"three\"))"

    (Stdlib.Json.parse<List<Int64>> "[1, 2, \"three\"]") |> err =
      Result.Error "Can't parse JSON `\"three\"` as type `Int64` at path: `root[2]`"

    (Stdlib.Json.parse<List<Int64>> "[1, 2, ]") |> err = Result.Error "Not JSON"

    (Stdlib.Json.parse<List<List<List<Int64>>>> "[[[1,2,3],[4,5.5,6]],[[7,8],[9,0]]]")
    |> err = Result.Error
      "Can't parse JSON `5.5` as type `Int64` at path: `root[0][1][1]`"

    (Stdlib.Json.parse<List<Dict<Int64>>>
      """[{"name": "Alice", "role": "admin"}, {"name": "Bob", "role": "user"}, {"name": "Charlie", "role": "user"}]""")
    |> err = Result.Error
      "Can't parse JSON `\"Alice\"` as type `Int64` at path: `root[0].name`"


module Tuples =
  Stdlib.Json.serialize<Int64 * String * Int64> (1L, "two", 3L) = "[1,\"two\",3]"

  Stdlib.Json.parse<Int64 * String * Int64> "[1,\"two\",3]" = Result.Ok(
    (1L, "two", 3L)
  )

  (Stdlib.Json.parse<Int64 * String * Int64> "[1,3]") |> err = Result.Error
    "Can't parse JSON `[1,3]` as type `(Int64 * String * Int64)` at path: `root`"


  Stdlib.Json.serialize<List<Int64> * List<Person>> (
    [ 1L; 2L; 3L ],
    [ Person { Name = "Alice"; Age = 42L } ]
  ) = "[[1,2,3],[{\"Age\":42,\"Name\":\"Alice\"}]]"

  Stdlib.Json.parse<List<Int64> * List<Person>>
    "[[1,2,3],[{\"Age\":42,\"Name\":\"Alice\"}]]" = Result.Ok(
    ([ 1L; 2L; 3L ], [ Person { Name = "Alice"; Age = 42L } ])
  )


  Stdlib.Json.serialize<(Int64 * String) * (Person * Dict<String>)> (
    (1L, "two"),
    (Person { Name = "Alice"; Age = 42L }, Stdlib.Dict.singleton "a" "b")
  ) = "[[1,\"two\"],[{\"Age\":42,\"Name\":\"Alice\"},{\"a\":\"b\"}]]"

  Stdlib.Json.parse<(Int64 * String) * (Person * Dict<String>)>
    "[[1,\"two\"],[{\"Age\":42,\"Name\":\"Alice\"},{\"a\":\"b\"}]]" = Result.Ok(
    ((1L, "two"),
     (Person { Name = "Alice"; Age = 42L }, Stdlib.Dict.singleton "a" "b"))
  )


  Stdlib.Json.serialize<(List<Int64 * String> * List<UInt8>) *
  (Person * Dict<String>)> (
    ([ (1L, "two"); (3L, "four") ], []),
    (Person { Name = "Alice"; Age = 42L }, Stdlib.Dict.singleton "a" "b")
  ) = "[[[[1,\"two\"],[3,\"four\"]],[]],[{\"Age\":42,\"Name\":\"Alice\"},{\"a\":\"b\"}]]"

  Stdlib.Json.parse<(List<Int64 * String> * List<UInt8>) * (Person * Dict<String>)>
    "[[[[1,\"two\"],[3,\"four\"]],[]],[{\"Age\":42,\"Name\":\"Alice\"},{\"a\":\"b\"}]]" = Result
    .Ok(
      (([ (1L, "two"); (3L, "four") ], []),
       (Person { Name = "Alice"; Age = 42L }, Stdlib.Dict.singleton "a" "b"))
    )


  Stdlib.Json.serialize<Person * Option<Int64>> (
    Person { Name = "Alice"; Age = 42L },
    Option.Some 1L
  ) = "[{\"Age\":42,\"Name\":\"Alice\"},{\"Some\":[1]}]"

  Stdlib.Json.parse<Person * Option<Int64>>
    "[{\"Age\":42,\"Name\":\"Alice\"},{\"Some\":[1]}]" = Result.Ok(
    (Person { Name = "Alice"; Age = 42L }, Option.Some 1L)
  )


  Stdlib.Json.serialize<Option<Int64> * Result<Int64, String>> (
    Option.Some 1L,
    Result.Ok 2L
  ) = "[{\"Some\":[1]},{\"Ok\":[2]}]"

  Stdlib.Json.parse<Option<Int64> * Result<Int64, String>>
    "[{\"Some\":[1]},{\"Ok\":[2]}]" = Result.Ok((Option.Some 1L, Result.Ok 2L))


  Stdlib.Json.serialize<Char * Bool> ('a', true) = "[\"a\",true]"
  Stdlib.Json.parse<Char * Bool> "[\"a\",true]" = Result.Ok(('a', true))


  Stdlib.Json.serialize<DateTime * Uuid> (
    DateTime.d "2023-07-28T22:42:36Z",
    Uuid.uuid "3700adbc-7a46-4ff4-81d3-45afb03f6e2d"
  ) = "[\"2023-07-28T22:42:36Z\",\"3700adbc-7a46-4ff4-81d3-45afb03f6e2d\"]"

  Stdlib.Json.parse<DateTime * Uuid>
    "[\"2023-07-28T22:42:36Z\",\"3700adbc-7a46-4ff4-81d3-45afb03f6e2d\"]" = Result.Ok(
    (DateTime.d "2023-07-28T22:42:36Z",
     Uuid.uuid "3700adbc-7a46-4ff4-81d3-45afb03f6e2d")
  )


  module Errors =
    (Stdlib.Json.parse<String * String * Int64> """[1, "two", 3]""") |> err = Result.Error
      "Can't parse JSON `1` as type `String` at path: `root[0]`"

    (Stdlib.Json.parse<String> """[1, "two", 3]""") |> err = Result.Error
      "Can't parse JSON `[1, \"two\", 3]` as type `String` at path: `root`"

    (Stdlib.Json.parse<Int64 * String> """[1, "two", 3]""") |> err = Result.Error
      "Can't parse JSON `[1, \"two\", 3]` as type `(Int64 * String)` at path: `root`"

    (Stdlib.Json.parse<List<String * String> * (Person * Dict<String>)>
      "[[[2,\"two\"],[3,\"four\"]],[{\"Age\":42,\"Name\":\"Alice\"},{\"a\":1}]]")
    |> err = Result.Error
      "Can't parse JSON `2` as type `String` at path: `root[0][0][0]`"

    (Stdlib.Json.parse<(List<Int64 * List<String>>) * String>
      "[[[1,\"two\"],[3,\"four\"]],\"\"]")
    |> err = Result.Error
      "Can't parse JSON `\"two\"` as type `List<String>` at path: `root[0][0][1]`"

    (Stdlib.Json.parse<Person * Option<Int64>>
      "[{\"Age\":42,\"Name\":\"Alice\"},{\"Some\":[\"one\"]}]")
    |> err = Result.Error
      "Can't parse JSON `\"one\"` as type `Int64` at path: `root[1].Some[0]`"


module Option =
  // TODO: more...
  Stdlib.Json.serialize<Option<Int64>> Option.None = "{\"None\":[]}"
  Stdlib.Json.parse<Option<Int64>> "{\"None\":[]}" = Result.Ok Option.None
  Stdlib.Json.serialize<Option<Int64>> (Option.Some 1L) = "{\"Some\":[1]}"
  Stdlib.Json.parse<Option<Int64>> "{\"Some\":[1]}" = Result.Ok(Option.Some 1L)

  module Errors =
    // TODO: these might make good candidates for more ergonmic parsing
    (Stdlib.Json.parse<Option<Int64>> "null") |> err = Result.Error
      "Can't parse JSON `null` as type `Darklang.Stdlib.Option.Option<Int64>` at path: `root`"

    (Stdlib.Json.parse<Option<Int64>> "1") |> err = Result.Error
      "Can't parse JSON `1` as type `Darklang.Stdlib.Option.Option<Int64>` at path: `root`"

    (Stdlib.Json.parse<Option<List<String>>> "[1,2,3]") |> err = Result.Error
      "Can't parse JSON `[1,2,3]` as type `Darklang.Stdlib.Option.Option<List<String>>` at path: `root`"



module Result =
  Stdlib.Json.serialize<Result<Int64, String>> (Result.Ok 1L) = "{\"Ok\":[1]}"

  Stdlib.Json.parse<Result<Int64, String>> "{\"Ok\":[1]}" = Result.Ok(Result.Ok 1L)

  Stdlib.Json.serialize<Result<Int64, String>> (Result.Error "err message") = "{\"Error\":[\"err message\"]}"

  Stdlib.Json.parse<Result<Int64, String>> "{\"Error\":[\"err message\"]}" = Result
    .Ok(Result.Error "err message")

  Stdlib.Json.serialize<Result<List<Dict<String> * Option<Int64>>, String>> (
    Result.Ok
      [ (Stdlib.Dict.singleton "a" "b", Option.Some 1L)
        (Stdlib.Dict.singleton "c" "d", Option.None) ]
  ) = "{\"Ok\":[[[{\"a\":\"b\"},{\"Some\":[1]}],[{\"c\":\"d\"},{\"None\":[]}]]]}"

  Stdlib.Json.parse<Result<List<Dict<String> * Option<Int64>>, String>>"{\"Ok\":[[[{\"a\":\"b\"},{\"Some\":[1]}],[{\"c\":\"d\"},{\"None\":[]}]]]}" =
    Result.Ok(Result.Ok [ (Stdlib.Dict.singleton "a" "b", Option.Some 1L); (Stdlib.Dict.singleton "c" "d", Option.None) ])

  Stdlib.Json.serialize<Result<Result<Int64, String>, String>> (
    Result.Ok(Result.Ok 1L)
  ) = "{\"Ok\":[{\"Ok\":[1]}]}"

  Stdlib.Json.serialize<Result<Result<Int64, String>, String>> (
    Result.Ok(Result.Error "err message")
  ) = "{\"Ok\":[{\"Error\":[\"err message\"]}]}"

  Stdlib.Json.parse<Result<Result<Int64, String>, String>> "{\"Ok\":[{\"Ok\":[1]}]}" =
    Result.Ok(Result.Ok(Result.Ok 1L))

  Stdlib.Json.parse<Result<Result<Int64, String>, String>> "{\"Ok\":[{\"Error\":[\"err message\"]}]}" =
    Result.Ok(Result.Ok(Result.Error "err message"))

  Stdlib.Json.serialize<Result<Result<Option<Result<Int64, String>>, String>, String>> (
    Result.Ok(Result.Ok(Option.Some(Result.Ok 1L)))
  ) = "{\"Ok\":[{\"Ok\":[{\"Some\":[{\"Ok\":[1]}]}]}]}"

  Stdlib.Json.parse<Result<Result<Option<Result<Int64, String>>, String>, String>>
    "{\"Ok\":[{\"Ok\":[{\"Some\":[{\"Ok\":[1]}]}]}]}" = Result.Ok(
    Result.Ok(Result.Ok(Option.Some(Result.Ok 1L)))
  )

module Dict =
  Stdlib.Json.serialize<Dict<String>> (Stdlib.Dict.singleton "a" "b") = """{"a":"b"}"""
  Stdlib.Json.parse<Dict<String>> """{"a":"b"}""" = Result.Ok(Stdlib.Dict.singleton "a" "b")

  Stdlib.Json.serialize<Dict<String>> (Dict { a = "b"; c = "d" }) = """{"a":"b","c":"d"}"""
  Stdlib.Json.parse<Dict<String>> """{"a":"b","c":"d"}""" = Result.Ok(Dict { a = "b"; c = "d" })

  module Errors =
    (Stdlib.Json.parse<Dict<Int64>> """{1:"b",2:"d"}""") |> err = Result.Error "Not JSON"


module UserDefinedEnums =
  // TODO: more nesting...
  type PrettyLikely =
    | Yeah
    | Enh of reason: String * Int64

  type PrettyLikely2 =
    | PrettyLikely of PrettyLikely
    | Yes
    | No

  Stdlib.Json.serialize<PrettyLikely> PrettyLikely.Yeah = "{\"Yeah\":[]}"

  Stdlib.Json.parse<PrettyLikely> "{\"Yeah\":[]}" = Result.Ok PrettyLikely.Yeah

  Stdlib.Json.serialize<PrettyLikely> (PrettyLikely.Enh("printer broke", 7L)) = "{\"Enh\":[\"printer broke\",7]}"

  Stdlib.Json.parse<PrettyLikely> "{\"Enh\":[\"printer broke\",7]}" = Result.Ok(
    PrettyLikely.Enh("printer broke", 7L)
  )

  Stdlib.Json.serialize<PrettyLikely2> (PrettyLikely2.PrettyLikely PrettyLikely.Yeah) = "{\"PrettyLikely\":[{\"Yeah\":[]}]}"

  Stdlib.Json.parse<PrettyLikely2> "{\"PrettyLikely\":[{\"Yeah\":[]}]}" = Result.Ok(
    PrettyLikely2.PrettyLikely PrettyLikely.Yeah
  )

  Stdlib.Json.serialize<PrettyLikely2> (
    PrettyLikely2.PrettyLikely(PrettyLikely.Enh("printer broke", 7L))
  ) = "{\"PrettyLikely\":[{\"Enh\":[\"printer broke\",7]}]}"

  Stdlib.Json.parse<PrettyLikely2>
    "{\"PrettyLikely\":[{\"Enh\":[\"printer broke\",7]}]}" = Result.Ok(
    PrettyLikely2.PrettyLikely(PrettyLikely.Enh("printer broke", 7L))
  )

  module Errors =
    (Stdlib.Json.parse<PrettyLikely> "{\"Enh\":[\"printer broke\",\"not int\"]}")
    |> err = Result.Error
      "Can't parse JSON `\"not int\"` as type `Int64` at path: `root.Enh[1]`"

    // EnumMissingField
    (Stdlib.Json.parse<PrettyLikely> "{\"Enh\":[\"printer broke\"]}") |> err = Result.Error
      "Can't parse JSON because argument 1 (`Int64`) is missing at path: `root.Enh`"

    // EnumExtraField
    (Stdlib.Json.parse<PrettyLikely> "{\"Enh\":[\"printer broke\", 1, 2.0]}") |> err = Result.Error
      "Can't parse JSON due to an extra argument `2.0` at path: `root.Enh[2]`"

    // CantMatchWithType
    (Stdlib.Json.parse<PrettyLikely> "{}") |> err = Result.Error
      "Can't parse JSON `{}` as type `UserDefinedEnums.PrettyLikely` at path: `root`"

    (Stdlib.Json.parse<PrettyLikely> "[]") |> err = Result.Error
      "Can't parse JSON `[]` as type `UserDefinedEnums.PrettyLikely` at path: `root`"

    // EnumInvalidCasename
    (Stdlib.Json.parse<PrettyLikely> "{\"Wrong\":[\"printer broke\", 1, 2.0]}")
    |> err = Result.Error
      "Can't parse JSON as `Wrong` is not a known case of type `UserDefinedEnums.PrettyLikely` at path: `root`"

    // EnumTooManyCases
    (Stdlib.Json.parse<PrettyLikely>
      "{\"Enh\":[\"printer broke\", 1], \"Extra\": \"field\"}")
    |> err = Result.Error
      "Can't parse JSON with multiple fields (`Enh`, `Extra`) as type `UserDefinedEnums.PrettyLikely` at path: `root`"




module UserDefinedRecords =

  Stdlib.Json.serialize<Person> (Person { Name = "Bob"; Age = 42L }) = """{"Age":42,"Name":"Bob"}"""

  Stdlib.Json.parse<Person> """{ "Name": "Bob", "Age": 42 }""" = Result.Ok(
    Person { Name = "Bob"; Age = 42L }
  )

  // can parse even if the JSON has _extra_ fields
  Stdlib.Json.parse<Person> """{ "Name": "Bob", "Age": 42, "Height": "6 ft" }""" = Result
    .Ok(Person { Name = "Bob"; Age = 42L })

  (let personMaybe = Stdlib.Json.parse<Person> """{ "Name": "Bob", "Age": 42 }"""

   match personMaybe with
   | Ok person -> person.Age
   | Error _ -> 0) = 42L


  type People =
    { GroupName: String
      People: List<Person> }

  Stdlib.Json.serialize<People> (
    People
      { GroupName = "Two Georges"
        People =
          [ Person { Name = "George A"; Age = 27L }
            Person { Name = "George B"; Age = 42L } ] }
  ) = """{"GroupName":"Two Georges","People":[{"Age":27,"Name":"George A"},{"Age":42,"Name":"George B"}]}"""

  Stdlib.Json.parse<People>
    """{"GroupName":"Two Georges","People":[{"Age":27,"Name":"George A"},{"Age":42,"Name":"George B"}]}""" = Result
    .Ok(
      People
        { GroupName = "Two Georges"
          People =
            [ Person { Name = "George A"; Age = 27L }
              Person { Name = "George B"; Age = 42L } ] }
    )


  type Combo<'e1, 'e2> = { e1: 'e1; e2: 'e2 }

  Stdlib.Json.serialize<Combo<Person, Combo<People, Int64>>> (
    Combo
      { e1 = Person { Name = "Bob"; Age = 42L }
        e2 =
          Combo
            { e1 =
                People
                  { GroupName = "Two Georges"
                    People =
                      [ Person { Name = "George A"; Age = 27L }
                        Person { Name = "George B"; Age = 42L } ] }
              e2 = 5L } }
  ) = """{"e1":{"Age":42,"Name":"Bob"},"e2":{"e1":{"GroupName":"Two Georges","People":[{"Age":27,"Name":"George A"},{"Age":42,"Name":"George B"}]},"e2":5}}"""

  Stdlib.Json.parse<Combo<Person, Combo<People, Int64>>>
    """{"e1":{"Age":42,"Name":"Bob"},"e2":{"e1":{"GroupName":"Two Georges","People":[{"Age":27,"Name":"George A"},{"Age":42,"Name":"George B"}]},"e2":5}}""" = Result
    .Ok(
      Combo
        { e1 = Person { Name = "Bob"; Age = 42L }
          e2 =
            Combo
              { e1 =
                  People
                    { GroupName = "Two Georges"
                      People =
                        [ Person { Name = "George A"; Age = 27L }
                          Person { Name = "George B"; Age = 42L } ] }
                e2 = 5L } }
    )

  (Combo
    { e1 = Person { Name = "Bob"; Age = 42L }
      e2 =
        Combo
          { e1 =
              People
                { GroupName = "Two Georges"
                  People =
                    [ Person { Name = "George A"; Age = 27L }
                      Person { Name = "George B"; Age = 42L } ] }
            e2 = 5L } })
  |> Stdlib.Json.serialize<Combo<Person, Combo<People, Int64>>>
  |> Stdlib.Json.parse<Combo<Person, Combo<People, Int64>>>
  |> Builtin.unwrap = (Combo
    { e1 = Person { Name = "Bob"; Age = 42L }
      e2 =
        Combo
          { e1 =
              People
                { GroupName = "Two Georges"
                  People =
                    [ Person { Name = "George A"; Age = 27L }
                      Person { Name = "George B"; Age = 42L } ] }
            e2 = 5L } })

  module Errors =
    (Stdlib.Json.parse<Person> "[]") |> err = Result.Error
      "Can't parse JSON `[]` as type `Person` at path: `root`"

    // Extra fields are allowed, but missing fields are not
    (Stdlib.Json.parse<Person> "{\"notAField\": 5}") |> err = Result.Error
      "Can't parse JSON because `Name` field is not provided at path: `root`"

    (Stdlib.Json.parse<Person> "{\"Age\": 5, \"Age\": 6, \"Name\": \"\"}") |> err = Result.Error
      "Can't parse JSON because `Age` is defined more than once at path: `root`"




module UserDefinedAliases =

  type MyInt = Int64

  Stdlib.Json.serialize<MyInt> 42L = "42"
  Stdlib.Json.parse<MyInt> "42" = Result.Ok 42L

  type MyPerson = Person

  Stdlib.Json.serialize<MyPerson> (Person { Name = "Bob"; Age = 42L }) = """{"Age":42,"Name":"Bob"}"""

  Stdlib.Json.parse<MyPerson> """{ "Name": "Bob", "Age": 42 }""" = Result.Ok(
    Person { Name = "Bob"; Age = 42L }
  )

  type MyPrettyLikely = UserDefinedEnums.PrettyLikely

  Stdlib.Json.serialize<MyPrettyLikely> (
    UserDefinedEnums.PrettyLikely.Enh("printer broke", 7L)
  ) = "{\"Enh\":[\"printer broke\",7]}"

  Stdlib.Json.parse<MyPrettyLikely> "{\"Enh\":[\"printer broke\",7]}" = Result.Ok(
    UserDefinedEnums.PrettyLikely.Enh("printer broke", 7L)
  )


  type Person1 = { Name: String; Age: Int64 }
  type Person2 = { Name: String; Age: Int64 }

  Stdlib.Json.serialize<Person2> (Person1 { Name = "Bob"; Age = 42L }) = Builtin.testDerrorMessage
    "Darklang.Stdlib.Json.serialize's 1st parameter `value` expects UserDefinedAliases.Person2, but got UserDefinedAliases.Person1 (UserDefinedAliases.Person1 {\n  Age: 42,\n  Name: \"Bob\"\n})"

  type StringResult<'a> = Result<'a, String>

  Stdlib.Json.serialize<StringResult<Int64>> (Result.Ok 1L) = "{\"Ok\":[1]}"

  Stdlib.Json.serialize<StringResult<Int64>> (Result.Error "err") = "{\"Error\":[\"err\"]}"

  // This test currently slips by the typechecker, and so we get an internal exception
  Stdlib.Json.serialize<StringResult<Int64>> (Result.Error 1L) =
    Builtin.testDerrorMessage
      "Darklang.Stdlib.Json.serialize's 1st parameter `value` expects Darklang.Stdlib.Result.Result<Int64, String>, but got Darklang.Stdlib.Result.Result<_, Int64> (Darklang.Stdlib.Result.Result<_, Int64>.Error(1))"


module Package =
  Stdlib.Json.serialize<Option<Int64>> Option.None = "{\"None\":[]}"

  Stdlib.Json.parse<Option<Int64>> "{\"None\":[]}" = Result.Ok Option.None

  Stdlib.Json.serialize<Result<Int64, String>> (Result.Ok 1L) = "{\"Ok\":[1]}"

  Stdlib.Json.serialize<Result<Int64, String>> (Result.Error "err message") = "{\"Error\":[\"err message\"]}"

  Stdlib.Json.parse<Result<Int64, String>> "{\"Ok\":[1]}" = Result.Ok(Result.Ok 1L)

  Stdlib.Json.parse<Result<Int64, String>> "{\"Error\":[\"err message\"]}" = Result
    .Ok(Result.Error "err message")

  Stdlib.Json.serialize<Darklang.LanguageTools.ID> 42L = "42"
  Stdlib.Json.parse<Darklang.LanguageTools.ID> "42" = Result.Ok 42L

  Stdlib.Json.serialize<Darklang.LanguageTools.Sign>
    Darklang.LanguageTools.Sign.Positive = "{\"Positive\":[]}"

  Stdlib.Json.parse<Darklang.LanguageTools.Sign> "{\"Positive\":[]}" = Result.Ok
    Darklang.LanguageTools.Sign.Positive


  Stdlib.Json.serialize<Darklang.OpenAI.Completion.ResponseChoice> (
    Darklang.OpenAI.Completion.ResponseChoice { text = "hello" }
  ) = "{\"text\":\"hello\"}"

  Stdlib.Json.parse<Darklang.OpenAI.Completion.ResponseChoice>
    "{\"text\":\"hello\"}" = Result.Ok(
    Darklang.OpenAI.Completion.ResponseChoice { text = "hello" }
  )

  Stdlib.Json.serialize<Darklang.OpenAI.Completion.Request> (
    Darklang.OpenAI.Completion.Request
      { model = "davinci"
        prompt = "test"
        max_tokens = 5L
        temperature = 0.7 }
  ) = "{\"max_tokens\":5,\"model\":\"davinci\",\"prompt\":\"test\",\"temperature\":0.7}"

  Stdlib.Json.parse<Darklang.OpenAI.Completion.Request>
    "{\"max_tokens\":5,\"model\":\"davinci\",\"prompt\":\"test\",\"temperature\":0.7}" = Result
    .Ok(
      Darklang.OpenAI.Completion.Request
        { model = "davinci"
          prompt = "test"
          max_tokens = 5L
          temperature = 0.7 }
    )

  // TODO use types that actually still dexist
  // Stdlib.Json.serialize<Darklang.LanguageTools.RuntimeErrors.NameResolution.ErrorType> (
  //   Darklang.LanguageTools.RuntimeErrors.NameResolution.ErrorType.InvalidPackageName
  //     [ "NamePart" ]
  // ) = "{\"InvalidPackageName\":[[\"NamePart\"]]}"

  // Stdlib.Json.parse<Darklang.LanguageTools.RuntimeErrors.NameResolution.ErrorType>
  //   "{\"NotFound\":[[\"NamePart\"]]}" = Result.Ok(
  //   Darklang.LanguageTools.RuntimeErrors.NameResolution.ErrorType.NotFound
  //     [ "NamePart" ]
  // )

  // Stdlib.Json.serialize<List<Darklang.LanguageTools.RuntimeErrors.NameResolution.ErrorType>>
  //   [ (Darklang.LanguageTools.RuntimeErrors.NameResolution.ErrorType.InvalidPackageName
  //       [ "NamePart" ])
  //     (Darklang.LanguageTools.RuntimeErrors.NameResolution.ErrorType.MissingEnumModuleName
  //       "Ok")
  //     (Darklang.LanguageTools.RuntimeErrors.NameResolution.ErrorType.NotFound
  //       [ "NamePart" ]) ] = "[{\"InvalidPackageName\":[[\"NamePart\"]]},{\"MissingEnumModuleName\":[\"Ok\"]},{\"NotFound\":[[\"NamePart\"]]}]"

  // Stdlib.Json.parse<List<Darklang.LanguageTools.RuntimeErrors.NameResolution.ErrorType>>
  //   "[{\"InvalidPackageName\":[[\"NamePart\"]]},{\"MissingEnumModuleName\":[\"Ok\"]},{\"NotFound\":[[\"NamePart\"]]}]" = Result
  //   .Ok(
  //     [ (Darklang.LanguageTools.RuntimeErrors.NameResolution.ErrorType.InvalidPackageName
  //         [ "NamePart" ])
  //       (Darklang.LanguageTools.RuntimeErrors.NameResolution.ErrorType.MissingEnumModuleName
  //         "Ok")
  //       (Darklang.LanguageTools.RuntimeErrors.NameResolution.ErrorType.NotFound
  //         [ "NamePart" ]) ]
  //   )


// from old tests - worth reviewing to see if we have missing cases


//Stdlib.Json.parse<TODO> "{Id : 1.0}" = null
//Stdlib.Json.parse<TODO> "{Id : 1.}" = null

//Stdlib.Json.parse<TODO> "[ {date : \"2013-11-05\", locations : {Japan: 3, Germany: 1}} ]" = null
//Stdlib.Json.parse<TODO> "({id : 555, edition : \"First\", author : \"Dennis Ritchie\"})" = null
//Stdlib.Json.parse<TODO> "" = null
//Stdlib.Json.parse<TODO> "1,0/0,0" = null
//Stdlib.Json.parse<TODO> "1" = 1

//Stdlib.Json.parse<TODO> "{Id : 1.0}" = Builtin.Test.runtimeError "'I' is an invalid start of a property name. Expected a '\"'. LineNumber: 0 | BytePositionInLine: 1."
//Stdlib.Json.parse<TODO> "{\"Id\" : 1.}" = Builtin.Test.runtimeError "'}' is invalid within a number, immediately after a decimal point ('.'). Expected a digit ('0'-'9'). LineNumber: 0 | BytePositionInLine: 10."
//Stdlib.Json.parse<TODO> "{id : 555, edition : \"First\", author : \"Dennis Ritchie\"}" =  Builtin.Test.runtimeError "'i' is an invalid start of a property name. Expected a '\"'. LineNumber: 0 | BytePositionInLine: 1."
//Stdlib.Json.parse<TODO> "\"\"" = ""

//Stdlib.Json.parse<TODO> "" = Builtin.Test.runtimeError "JSON string was empty"

//Stdlib.Json.parse<TODO> "{ \"v\": 4611686018427387903 }" = { v = 4611686018427387903L }
//Stdlib.Json.parse<TODO> "{ \"v\": 4611686018427387904 }" = { v = 4611686018427387904L }

//Stdlib.Json.parse<TODO> "''" = Builtin.Test.runtimeError "''' is an invalid start of a value. LineNumber: 0 | BytePositionInLine: 0."
//Stdlib.Json.parse<TODO> "" = Builtin.Test.runtimeError "JSON string was empty"
//Stdlib.Json.parse<TODO> "{Id : 1.0}" = Builtin.Test.runtimeError "'I' is an invalid start of a property name. Expected a '\"'. LineNumber: 0 | BytePositionInLine: 1."
//Stdlib.Json.parse<TODO> "{\"Id\" : 1.}" = Builtin.Test.runtimeError "'}' is invalid within a number, immediately after a decimal point ('.'). Expected a digit ('0'-'9'). LineNumber: 0 | BytePositionInLine: 10.")"
//Stdlib.Json.parse<TODO> "{id : 555, edition : \"First\", author : \"Dennis Ritchie\"}" =  Builtin.Test.runtimeError "'i' is an invalid start of a property name. Expected a '\"'. LineNumber: 0 | BytePositionInLine: 1."

//Stdlib.Json.parse<TODO> "{ \"v\": 4611686018427387903 }" = Result.Ok { v = 4611686018427387903L }
//Stdlib.Json.parse<TODO> "{ \"v\": 4611686018427387904 }" = Result.Ok { v = 4611686018427387904L }

//Stdlib.Json.parse<TODO> "" = Result.Error "JSON string was empty"
//Stdlib.Json.parse<TODO> "{3: false}" = Result.Error "'3' is an invalid start of a property name. Expected a '\"'. LineNumber: 0 | BytePositionInLine: 1."

//Stdlib.Json.parse<TODO> "{Id : 1.0}" = Result.Error "'I' is an invalid start of a property name. Expected a '\"'. LineNumber: 0 | BytePositionInLine: 1."
//Stdlib.Json.parse<TODO> "{\"Id\" : Infinity }" = Result.Error "'I' is an invalid start of a value. LineNumber: 0 | BytePositionInLine: 8."
//Stdlib.Json.parse<TODO> "{\"Id\" : -Infinity }" = Result.Error "'I' is invalid within a number, immediately after a sign character ('+' or '-'). Expected a digit ('0'-'9'). LineNumber: 0 | BytePositionInLine: 9."
//Stdlib.Json.parse<TODO> "{\"Id\" : NaN }" = Result.Error "'N' is an invalid start of a value. LineNumber: 0 | BytePositionInLine: 8."
//Stdlib.Json.parse<TODO> "{\"Id\" : 1.}" = Result.Error "'}' is invalid within a number, immediately after a decimal point ('.'). Expected a digit ('0'-'9'). LineNumber: 0 | BytePositionInLine: 10."
//Stdlib.Json.parse<TODO> "[ {\"date\" : \"2013-11-05\", locations : {Japan: 3, Germany: 1}} ]" = Result.Error "'l' is an invalid start of a property name. Expected a '\"'. LineNumber: 0 | BytePositionInLine: 26."
//Stdlib.Json.parse<TODO> "{\"id\" : 555, edition : \"First\", author : \"Dennis Ritchie\"}" = Result.Error "'e' is an invalid start of a property name. Expected a '\"'. LineNumber: 0 | BytePositionInLine: 13."
//Stdlib.Json.parse<TODO> "{\"id\" : 555, \"edition\" : 'First' }" = Result.Error "''' is an invalid start of a value. LineNumber: 0 | BytePositionInLine: 25."
//Stdlib.Json.parse<TODO> "({\"id\" : 555, \"edition\" : \"First\", \"author\" : \"Dennis Ritchie\"})" = Result.Error "'(' is an invalid start of a value. LineNumber: 0 | BytePositionInLine: 0."

// ## Nested types (lists, tuples, records, etc.)
// Stdlib.Json.serialize<List<List<Int64 * List<MyType<String>> * Dict<MyType<List<Int64>>>>>> = Ok "test"
// Stdlib.Json.serialize<List<List<Int64 * List<MyType<String>> * Dict<MyType<List<Int64>>>>>> = Ok "test"