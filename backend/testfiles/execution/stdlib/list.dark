// CLEANUP the following tests should fail on having mixed types
//[1; 2.3] = Builtin.testDerrorMessage "Cannot form a list of mixed types - the 2nd element does not match the type of previous elements"
//[(1,10);10;(3,30)] = Builtin.testDerrorMessage "Cannot form a list of mixed types ..."
//[(1,10);(2,20);(3,30,40)] = Builtin.testDerrorMessage "Cannot form a list of mixed types"


Stdlib.List.all [] (fun item -> item < 3L) == true
Stdlib.List.all [ 2L ] (fun item -> item < 3L) == true
Stdlib.List.all [ 1L; 2L ] (fun item -> item < 3L) == true
Stdlib.List.all [ 4L ] (fun item -> item < 3L) == false
Stdlib.List.all [ 1L; 4L ] (fun item -> item < 3L) == false


Stdlib.List.append [ 1L; 2L; 3L ] [ 4L; 5L; 6L ] == [ 1L; 2L; 3L; 4L; 5L; 6L ]

Stdlib.List.append [ 3L; 4L ] [ 5L; 6L ] == [ 3L; 4L; 5L; 6L ]
Stdlib.List.append [ 1L ] [ 2L ] == [ 1L; 2L ]
Stdlib.List.append [] [] == []


Stdlib.List.drop [ "a"; "b"; "c"; "d" ] -3L == [ "a"; "b"; "c"; "d" ]

Stdlib.List.drop [ "a"; "b"; "c"; "d" ] 3L == [ "d" ]
Stdlib.List.drop [ 1L; 2L; 3L; 4L ] -1L == [ 1L; 2L; 3L; 4L ]
Stdlib.List.drop [ 1L; 2L; 3L; 4L ] 0L == [ 1L; 2L; 3L; 4L ]
Stdlib.List.drop [ 1L; 2L; 3L; 4L ] 440737095L == []
Stdlib.List.drop [ 1L; 2L; 3L; 4L ] 1184467440737095L == []
Stdlib.List.drop [ 1L; 2L; 3L; 4L ] 2L == [ 3L; 4L ]
Stdlib.List.drop [ 1L; 2L; 3L; 4L ] 4L == []
Stdlib.List.drop [ 1L; 2L; 3L; 4L ] 5L == []
Stdlib.List.drop [ 3L; 3L; 3L ] 0L == [ 3L; 3L; 3L ]
Stdlib.List.drop [ 5L; 4L; 3L; 2L; 1L ] 5L == []
Stdlib.List.drop [ 5L ] 4L == []
Stdlib.List.drop [] 4L == []

Stdlib.List.dropWhile [ 1L; 2L; 3L; 4L ] (fun item -> 0L - 1L)
== Builtin.testDerrorMessage "If only supports Booleans"

Stdlib.List.dropWhile [ 1L; 2L; 3L; 4L ] (fun item -> item < 3L) == [ 3L; 4L ]

Stdlib.List.dropWhile [ 1L; 2L; 3L; 4L ] (fun item -> item >= 1L) == []

Stdlib.List.dropWhile [ 1L; 5L; 2L; 2L ] (fun item -> item < 3L)
== [ 5L; 2L; 2L ]

Stdlib.List.dropWhile [] (fun item -> item < 3L) == []

Stdlib.List.empty == []

//CLEANUP Parser: had to use `let _ =` because we don't have support for EStatement yet + (had to align lambda's parens for the tests to parse correctly)
(let _ =
  Stdlib.List.iter
    [ 1L; 2L; 3L ]
    (fun x -> Builtin.testIncrementSideEffectCounter ())
 Builtin.testSideEffectCount ())
== 3L

(let _ =
  Stdlib.List.iter
    [ 1L; 2L; 3L; 4L; 5L ]
    (fun x ->
      if x % 2L == 0L then
        Builtin.testIncrementSideEffectCounter ()
    )
 Builtin.testSideEffectCount ())
== 2L

(let _ =
  Stdlib.List.iter
    []
    (fun x -> Builtin.testIncrementSideEffectCounter ())
 Builtin.testSideEffectCount ())
== 0L

(let _ =
  Stdlib.List.iter
    [ 10L; 20L; 30L ]
    (fun x ->
      let _ = Builtin.testIncrementSideEffectCounter ()
      Builtin.testIncrementSideEffectCounter ()
    )
 Builtin.testSideEffectCount ())
== 6L

(let _ =
  Stdlib.List.iter
    [ 1L; 2L; 3L ]
    (fun x ->
      if x > 2L then
        Builtin.testIncrementSideEffectCounter ()
    )
 Builtin.testSideEffectCount ())
== 1L

Stdlib.List.filter [ 1L; 2L; 3L ] (fun item ->
  match item with
  | 1L -> Stdlib.Option.Option.None()
  | 2L -> false
  | 3L -> true) == Builtin.testDerrorMessage "If only supports Booleans"

Stdlib.List.filter [ true; false; true ] (fun item -> "a") == Builtin.testDerrorMessage
  "If only supports Booleans"

Stdlib.List.filter [ 1L; 2L; 3L ] (fun item ->
  match item with
  | 1L -> true
  | 2L -> false
  | 3L -> true) == [ 1L; 3L ]

Stdlib.List.filter [] (fun item -> true) == []
Stdlib.List.filter [ -20L; 5L; 9L ] (fun x -> x > 20L) == []
Stdlib.List.filter [] (fun item -> "a") == []

Stdlib.List.filterMap [ 1L; 2L; 3L ] (fun item ->
  if item == 2L then
    Stdlib.Option.Option.None()
  else
    (Stdlib.Option.Option.Some(item * 2L))) == [ 2L; 6L ]

Stdlib.List.filterMap [] (fun item -> 0L) == []

Stdlib.List.findFirst [ 1L; 2L; 3L ] (fun x -> x > 5L) == Stdlib.Option.Option.None()
Stdlib.List.findFirst [] (fun x -> x) == Stdlib.Option.Option.None()

Stdlib.List.findFirst [ 1L; 2L; 3L; 1L; 4L ] (fun x -> x > 1L) == Stdlib.Option.Option.Some(2L)

Stdlib.List.findFirst [ 0L; 5L; -6L; -10L ] (fun x -> x < 0L) == Stdlib.Option.Option.Some(-6L)

Stdlib.List.findFirst [ 1L; -33L; 3L; -2L; 12L ] (fun x -> (x < 0L && x % 2L == 0L)) == Stdlib.Option.Option.Some(-2L)

// CLEANUP once DList contains typeRefs, this test may be uncommented and the error message updated
Stdlib.List.flatten [1;2;3] =
  Builtin.testRuntimeError "In List.flatten's 1st argument (`list`), the value should be a List<List<'a>>. However, a List<Int64> ([1; 2; 3]) was passed instead.\n\nExpected: List<List<'a>>\nActual: List<Int64>: [1; 2; 3]"
Stdlib.List.flatten [ [ 1L ]; [ 2L ]; [ 3L ] ] == [ 1L; 2L; 3L ]

Stdlib.List.flatten [ [ 1L ]; [ [ 2L; 3L ] ] ] == Builtin.testDerrorMessage
  "Could not merge types List<List<List<Int64>>> and List<List<Int64>>"

Stdlib.List.flatten [ [ [] ] ] == [ [] ]
Stdlib.List.flatten [ [] ] == []
Stdlib.List.flatten [] == []

Stdlib.List.fold [ "a"; "b"; "c"; "d" ] "x" (fun accum curr -> accum ++ curr) == "xabcd"

Stdlib.List.fold [ 1L; 2L; 3L; 4L; 5L ] [] (fun accum curr ->
  Stdlib.List.pushBack accum (curr + 1L)) == [ 2L; 3L; 4L; 5L; 6L ]

Stdlib.List.fold [] [] (fun accum curr -> 5L) == []

Stdlib.List.getAt [ "a"; "b"; "c"; "d" ] -1L == Stdlib.Option.Option.None()
Stdlib.List.getAt [ 0L ] 1L == Stdlib.Option.Option.None()
Stdlib.List.getAt [] 1L == Stdlib.Option.Option.None()
Stdlib.List.getAt [ 1L; 2L; 3L; 4L ] 6018427387902L == Stdlib.Option.Option.None()

Stdlib.List.getAt [ 1L; 2L; 3L; 4L ] 0L == Stdlib.Option.Option.Some(1L)

Stdlib.List.getAt [ 3L; 3L; 3L ] -5L == Stdlib.Option.Option.None()
Stdlib.List.getAt [ 3L; 3L; 3L ] 2147483648L == Stdlib.Option.Option.None()

Stdlib.List.head [ 1L; 2L; 3L ] == Stdlib.Option.Option.Some(1L)

Stdlib.List.head [ Builtin.testRuntimeError "test" ] == Builtin.testDerrorMessage
  "test"

Stdlib.List.head [] == Stdlib.Option.Option.None()

Stdlib.List.indexedMap [ 3L; 2L; 1L ] (fun i v -> v - i) == [ 3L; 1L; -1L ]

Stdlib.List.indexedMap [] (fun i v -> v - i) == []

Stdlib.List.indexedMap [ 3L; 2L; 1L ] (fun i v -> i) == [ 0L; 1L; 2L ]

Stdlib.List.interleave [ 1L; 2L; 3L ] [ 4L; 5L; 6L ]
== [ 1L; 4L; 2L; 5L; 3L; 6L ]

Stdlib.List.interleave [ 1L; 2L; 3L ] [ 4L ] == [ 1L; 4L; 2L; 3L ]
Stdlib.List.interleave [ 1L; 2L; 3L ] [] == [ 1L; 2L; 3L ]
Stdlib.List.interleave [ 1L ] [ 4L; 5L; 6L ] == [ 1L; 4L; 5L; 6L ]
Stdlib.List.interleave [] [ 4L; 5L; 6L ] == [ 4L; 5L; 6L ]
Stdlib.List.interleave [] [] == []

Stdlib.List.interleave [ "a"; "b"; "c" ] [ 0L ]
== Builtin.testDerrorMessage "Could not merge types List<Int64> and List<String>"

Stdlib.List.interpose [ 1L; 2L; 3L ] 5L == [ 1L; 5L; 2L; 5L; 3L ]
Stdlib.List.interpose [ 1L ] 5L == [ 1L ]

Stdlib.List.interpose [] 5L == []

Stdlib.List.interpose [ "a"; "b"; "c" ] 0L == Builtin.testDerrorMessage
  "Could not merge types List<Int64> and List<String>"

Stdlib.List.isEmpty [ 1L ] == false
Stdlib.List.isEmpty [] == true

Stdlib.List.last [ 1L; 2L; 3L ] == Stdlib.Option.Option.Some(3L)

Stdlib.List.last [ Builtin.testRuntimeError "test" ] == Builtin.testDerrorMessage
  "test"

Stdlib.List.last [] == Stdlib.Option.Option.None()

Stdlib.List.length [ 1L; 2L; 3L ] == 3L
Stdlib.List.length [] == 0L

Stdlib.List.map (Stdlib.List.range 1L 5L) (fun x -> x + 1L) == [  2L
                                                                  3L
                                                                  4L
                                                                  5L
                                                                  6L ]

(Stdlib.List.map [ 1L; 2L; 3L ] (fun x ->
  Stdlib.Bool.and
    (Stdlib.Int64.greaterThanOrEqualTo x 0L)
    (Stdlib.Int64.lessThanOrEqualTo x 4L))) == [ true; true; true ]

Stdlib.List.map [ 1L; 2L ] (fun x -> x + 1L) == [ 2L; 3L ]
Stdlib.List.map [] (fun x -> x + 1L) == []

Stdlib.List.map2 [ 10L; 20L; 30L ] [ 1L; 2L; 3L ] (fun a b -> a - b) == Stdlib.Option.Option.Some([ 9L; 18L; 27L ])

Stdlib.List.map2 [ 10L; 20L ] [ 1L; 2L; 3L ] (fun a b -> a - b) == Stdlib.Option.Option.None()

Stdlib.List.map2 [] [] (fun a b -> a - b) == Stdlib.Option.Option.Some([])

Stdlib.List.map2shortest [ 10L; 20L; 30L ] [ 1L; 2L; 3L ] (fun a b -> a - b) == [ 9L
                                                                                  18L
                                                                                  27L ]

Stdlib.List.map2shortest [ 10L; 20L ] [ 1L; 2L; 3L ] (fun a b -> a - b) == [  9L
                                                                              18L ]

Stdlib.List.map2shortest [] [ 1L; 2L; 3L ] (fun a b -> a - b) == []
Stdlib.List.map2shortest [ 1L; 2L; 3L ] [] (fun a b -> a - b) == []

Stdlib.List.member [ 1L; 2L; 3L ] 2L == true
Stdlib.List.member [ 1L; 2L; 3L ] 4L == false
Stdlib.List.member [] 1L == false

Stdlib.List.partition [ -20L; 5L; 9L ] (fun x -> x > 0L) == ([ 5L; 9L ], [ -20L ])

Stdlib.List.partition [] (fun item -> true) == ([], [])
Stdlib.List.partition [] (fun item -> "a") == ([], [])

Stdlib.List.partition [ 1L; 2L; 3L ] (fun item ->
  match item with
  | 1L -> true
  | 2L -> false
  | 3L -> true) == ([ 1L; 3L ], [ 2L ])

Stdlib.List.partition [ true; false; true ] (fun item -> "a") == Builtin.testDerrorMessage "If only supports Booleans"


Stdlib.List.partition [ 1L; 2L; 3L ] (fun item ->
  match item with
  | 1L -> Stdlib.Option.Option.None()
  | 2L -> false
  | 3L -> true) == Builtin.testDerrorMessage "If only supports Booleans"

Stdlib.List.pushBack [ 2L; 3L ] 1L == [ 2L; 3L; 1L ]

Stdlib.List.pushBack [] 1L == [ 1L ]

Stdlib.List.push [ 2L; 3L ] 1L == [ 1L; 2L; 3L ]
Stdlib.List.push [] 1L == [ 1L ]

Stdlib.List.randomElement [ 1L ] == Stdlib.Option.Option.Some(1L)

Stdlib.List.randomElement [ Builtin.testRuntimeError "test" ] == Builtin.testDerrorMessage
  "test"

Stdlib.List.randomElement [] == Stdlib.Option.Option.None()

Stdlib.List.range -1L 0L == [ -1L; 0L ]

Stdlib.List.range -5L 5L == [ -5L; -4L; -3L; -2L; -1L; 0L; 1L; 2L; 3L; 4L; 5L ]

Stdlib.List.range 5L 0L == []

Stdlib.List.repeat 0L 1L == Stdlib.Result.Result.Ok([])

Stdlib.List.repeat 1L "a" == Stdlib.Result.Result.Ok([ "a" ])

Stdlib.List.repeat 1L 1L == Stdlib.Result.Result.Ok([ 1L ])

Stdlib.List.repeat 3L 1L == Stdlib.Result.Result.Ok([ 1L; 1L; 1L ])

Stdlib.List.repeat 3L 3L == Stdlib.Result.Result.Ok([ 3L; 3L; 3L ])

Stdlib.List.repeat 5L "a" == Stdlib.Result.Result.Ok([ "a"; "a"; "a"; "a"; "a" ])

Stdlib.List.repeat -4L "a" == Stdlib.Result.Result.Error
  ("Expected `times` to be positive, but it was `-4`")

Stdlib.List.repeat 3L [ 1L; 2L; 3L ] == Stdlib.Result.Result.Ok
  ([ [ 1L; 2L; 3L ]; [ 1L; 2L; 3L ]; [ 1L; 2L; 3L ] ])

Stdlib.List.repeat 3L [] == Stdlib.Result.Result.Ok([ []; []; [] ])

Stdlib.List.reverse [ "a"; "b"; "c"; "d" ] == [ "d"; "c"; "b"; "a" ]

Stdlib.List.reverse [ 5L; 4L; 3L; 2L; 1L ] == [ 1L; 2L; 3L; 4L; 5L ]

Stdlib.List.reverse [] == []

Stdlib.List.singleton 1L == [ 1L ]

Stdlib.List.sortBy [ 6L; 2L; 8L; 3L ] (fun x -> 0L - x) == [ 8L; 6L; 3L; 2L ]

Stdlib.List.sortBy [] (fun x -> 0L - x) == []

Stdlib.List.sort [ "6"; "2"; "8"; "3" ] == [ "2"; "3"; "6"; "8" ]
Stdlib.List.sort [ 6L; 2L; 8L; 3L ] == [ 2L; 3L; 6L; 8L ]
Stdlib.List.sort [] == []

Stdlib.List.sortByComparator [ 3L; 1L; 2L ] (fun a b -> 0.1) == Builtin.testDerrorMessage
  "Function return value should be an Int64. However, a Float (0.1) was returned instead.\n\nExpected: Int64\nActual: a Float: 0.1"

Stdlib.List.sortByComparator [ 3L; 1L; 2L ] (fun a b -> 3L) == Stdlib.Result.Result.Error
  ("Expected comparator function to return -1, 0, or 1, but it returned 3")

Stdlib.List.sortByComparator [ 1L; 2L; 3L ] (fun a b -> "㧑༷釺") == Builtin.testDerrorMessage
  "Function return value should be an Int64. However, a String (\"㧑༷釺\") was returned instead.\n\nExpected: Int64\nActual: a String: \"㧑༷釺\""

Stdlib.List.sortByComparator [ 3L; 1L; 2L ] (fun a b ->
  if Stdlib.Int64.lessThan a b then -1L else 1L) == Stdlib.Result.Result.Ok
  ([ 1L; 2L; 3L ])

Stdlib.List.sortByComparator [] (fun a b ->
  if Stdlib.Int64.lessThan a b then -1L else 1L) == Stdlib.Result.Result.Ok([])

// CLEANUP parser: had to change the format of this test for it to pass
Stdlib.List.sortByComparator
  [ 3L
    1L
    2L
    67L
    3L
    -1L
    6L
    3L
    5L
    6L
    2L
    5L
    63L
    2L
    3L
    5L
    -1L
    -1L
    -1L ]
  (fun a b -> if Stdlib.Int64.lessThan a b then -1L else 1L)
== Stdlib.Result.Result.Ok
  ([  -1L
      -1L
      -1L
      -1L
      1L
      2L
      2L
      2L
      3L
      3L
      3L
      3L
      5L
      5L
      5L
      6L
      6L
      63L
      67L ])

// CLEANUP this error message is not ideal in 2 ways:
// - The error does not provide context that the issue is with the fn specifically
// - it seems to be from the perspective of the lambda
//   (I'm a lambda and I'm expecting 2 arguments, but I got 1!!)
//   rather than from the perspective of the function it's being used in
Stdlib.List.sortByComparator [ 6.0; 2.0 ] (fun x -> x) == Builtin.testDerrorMessage
  "Expected 1 arguments, got 2"

Stdlib.List.tail [ 10L; 20L; 30L; 40L ] == Stdlib.Option.Option.Some
  ([ 20L; 30L; 40L ])

Stdlib.List.tail [] == Stdlib.Option.Option.None()

Stdlib.List.take [ "a"; "b"; "c"; "d" ] -1L == []

Stdlib.List.take [ "a"; "b"; "c"; "d" ] 2147483648L == [ "a"; "b"; "c"; "d" ]

Stdlib.List.take [ "a"; "b"; "c"; "d" ] 3L == [ "a"; "b"; "c" ]
Stdlib.List.take [ 3L; 3L; 3L ] 0L == []

Stdlib.List.take [ 5L; 4L; 3L; 2L; 1L ] 5L == [ 5L; 4L; 3L; 2L; 1L ]

Stdlib.List.take [ 5L ] 4L == [ 5L ]
Stdlib.List.take [] 4L == []

//TODO: better error message
Stdlib.List.takeWhile [ 1L; 2L; 3L; 4L ] (fun item -> 0L - 1L) == Builtin.testDerrorMessage
  "If only supports Booleans"

Stdlib.List.takeWhile [ 1L; 2L; 3L; 4L ] (fun item -> item < 1L) == []

Stdlib.List.takeWhile [ 1L; 2L; 3L; 4L ] (fun item -> item < 3L) == [ 1L; 2L ]

Stdlib.List.takeWhile [ 1L; 5L; 2L; 2L ] (fun item -> item < 3L) == [ 1L ]
Stdlib.List.takeWhile [] (fun item -> item < 3L) == []
// it isn't specified which is the right value to keep when there are duplicates
Stdlib.List.uniqueBy [ 1L; 2L; 3L; 4L ] (fun x -> Stdlib.Int64.divide x 2L) == [  1L
                                                                                  2L
                                                                                  4L ]

Stdlib.List.uniqueBy [ 1L; 2L; 3L; 4L ] (fun x -> x) == [ 1L; 2L; 3L; 4L ]

Stdlib.List.uniqueBy [ 1L; 1L; 1L; 1L ] (fun x -> x) == [ 1L ]

Stdlib.List.uniqueBy [ 7L; 42L; 7L; 2L; 10L ] (fun x -> x) == [ 2L; 7L; 10L; 42L ]

Stdlib.List.uniqueBy [] (fun x -> x) == []

Stdlib.List.uniqueBy [ 6L; 2.0 ] (fun x -> x) == Builtin.testDerrorMessage
  "Could not merge types List<Float> and List<Int64>"

Stdlib.List.unique [ 1L; 2L; 3L; 4L ] == [ 1L; 2L; 3L; 4L ]
Stdlib.List.unique [ 1L; 1L; 1L; 1L ] == [ 1L ]

Stdlib.List.unique [ 7L; 42L; 7L; 2L; 10L ] == [ 2L; 7L; 10L; 42L ]

Stdlib.List.unique [] == []
// TODO: more tests, with values of more complex types

Stdlib.List.unzip [ (1L, 10L); (2L, 20L); (3L, 30L) ] == ([ 1L; 2L; 3L ], [ 10L; 20L; 30L ])

Stdlib.List.unzip [ (10L, 6L) ] == ([ 10L ], [ 6L ])

Stdlib.List.zipShortest [ 10L; 20L; 30L ] [ 1L; 2L; 3L ] == [ (10L, 1L)
                                                              (20L, 2L)
                                                              (30L, 3L) ]

Stdlib.List.zipShortest [ 10L; 20L; 30L ] [ "a"; "bc"; "d" ] == [ (10L, "a")
                                                                  (20L, "bc")
                                                                  (30L, "d") ]

Stdlib.List.zipShortest [ 10L; 20L ] [ 1L; 2L; 3L ] == [ (10L, 1L); (20L, 2L) ]

Stdlib.List.zipShortest [ 1L; 2L; 3L ] [ 10L; 20L ] == [ (1L, 10L); (2L, 20L) ]

Stdlib.List.zipShortest [ 10L; 20L ] [ "a"; "bc"; "d" ] == [  (10L, "a")
                                                              (20L, "bc") ]

Stdlib.List.zipShortest [ "a"; "bc"; "d" ] [ 10L; 20L ] == [ ("a", 10L)
                                                             ("bc", 20L) ]

Stdlib.List.zipShortest [ "b"; "v"; "z" ] [] == []
Stdlib.List.zipShortest [] [ "b"; "v"; "z" ] == []


Stdlib.List.zip [ 10L; 20L; 30L ] [ 1L; 2L; 3L ] == Stdlib.Option.Option.Some
  ([ (10L, 1L); (20L, 2L); (30L, 3L) ])

Stdlib.List.zip [ 10L; 20L ] [ 1L; 2L; 3L ] == Stdlib.Option.Option.None()

Stdlib.List.zip [] [] == Stdlib.Option.Option.Some([])

Stdlib.List.zip [ Builtin.testRuntimeError "msg" ] [ Some("") ] == Builtin.testDerrorMessage
  "msg"


Stdlib.List.groupByWithKey [ 1L; 2L; 3L; 4L; 5L ] (fun x ->
  Stdlib.Int64.mod x 2L) == [ (1L, [ 1L; 3L; 5L ]); (0L, [ 2L; 4L ]) ]

Stdlib.List.groupByWithKey [ 1L; 2L; 3L; 4L; 5L ] (fun x ->
  Stdlib.Int64.mod x 2L) == [ (1L, [ 1L; 3L; 5L ]); (0L, [ 2L; 4L ]) ]

Stdlib.List.groupByWithKey
  [ "apple"; "banana"; "avocado"; "grape"; "apricot" ]
  (fun s -> Stdlib.String.first s 1L)
== [  ("a", [ "apple"; "avocado"; "apricot" ])
      ("b", [ "banana" ])
      ("g", [ "grape" ]) ]

Stdlib.List.groupByWithKey [ 'a'; 'b'; 'c'; 'a'; 'b' ] (fun c -> c) == [  ('a', [ 'a'; 'a' ])
                                                                          ('b', [ 'b'; 'b' ])
                                                                          ('c', [ 'c' ]) ]

Stdlib.List.groupByWithKey [ 1L; 2L; 3L; 4L; 5L ] (fun x ->
  Stdlib.Int64.mod x 2L == 0L) == [ (false, [ 1L; 3L; 5L ]); (true, [ 2L; 4L ]) ]

Stdlib.List.groupByWithKey [ 1L; 2L; 3L; 4L; 5L ] (fun x ->
  ((Stdlib.Int64.mod x 2L), "test")) == [ ((1L, "test"), [ 1L; 3L; 5L ])
                                          ((0L, "test"), [ 2L; 4L ]) ]

Stdlib.List.groupByWithKey [] (fun x -> x) == []


Stdlib.List.dropLast [ 1L; 2L; 3L; 4L; 5L ] == [ 1L; 2L; 3L; 4L ]
Stdlib.List.dropLast [ 1L ] == []
Stdlib.List.dropLast [] == []

Stdlib.List.chunkBySize [ 1L; 2L; 3L; 4L; 5L ] 2L == Stdlib.Result.Result.Ok
  ([ [ 1L; 2L ]; [ 3L; 4L ]; [ 5L ] ])

Stdlib.List.chunkBySize [ 1L; 2L; 3L; 4L; 5L; 6L ] 3L == Stdlib.Result.Result.Ok
  ([ [ 1L; 2L; 3L ]; [ 4L; 5L; 6L ] ])

Stdlib.List.chunkBySize [ 1L; 2L; 3L ] 1L == Stdlib.Result.Result.Ok
  ([ [ 1L ]; [ 2L ]; [ 3L ] ])

Stdlib.List.chunkBySize [ 1L; 2L ] 3L == Stdlib.Result.Result.Ok([ [ 1L; 2L ] ])

Stdlib.List.chunkBySize [] 4L == Stdlib.Result.Result.Ok([])

Stdlib.List.chunkBySize [ 1L; 2L; 3L; 4L ] 0L == Stdlib.Result.Result.Error
  (Stdlib.List.ChunkBySizeError.SizeMustBeGreaterThanZero())

Stdlib.List.chunkBySize [ 1L; 2L; 3L; 4L ] -1L == Stdlib.Result.Result.Error
  (Stdlib.List.ChunkBySizeError.SizeMustBeGreaterThanZero())


Stdlib.List.splitLast [] == Stdlib.Option.Option.None()
Stdlib.List.splitLast [ 1L ] == Stdlib.Option.Option.Some(([], 1L))
Stdlib.List.splitLast [ 1L; 2L ] == Stdlib.Option.Option.Some(([ 1L ], 2L))
Stdlib.List.splitLast [ 1L; 2L; 3L ] == Stdlib.Option.Option.Some(([ 1L; 2L ], 3L))