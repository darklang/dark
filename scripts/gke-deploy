#!/usr/bin/env bash
. ./scripts/support/assert-in-container "$0" "$@"

set -euo pipefail

DARK_REGION="us-west1"
DARK_PROJECT="balmy-ground-195100"
DARK_CLUSTER="$(< current-cluster)"

DEPLOY_LOCK_BUCKET="gs://darklang-deploy-lock"

PREFIX=""

# Doing this instead of ${CIRCLE_BUILD_URL-manual-deploy} because
# CIRCLE_BUILD_URL='' is the unset case. (Because of the docker run command in
# scripts/builder,)
if [[ "${CIRCLE_BUILD_URL}" == "" ]]; then
  CIRCLE_BUILD_URL='manual-deploy'
fi

HELP="$(cat <<EOF
Usage: $0 [OPTIONS]

A script that deploys the Dark Kubernetes config to a particular cluster.

Options:

  --region=...           The Google cloud region to deploy into (default $DARK_REGION).
  --project=...          The Google cloud project to deploy into (default $DARK_PROJECT).
  --cluster=...          The name of the cluster to deploy to (default $DARK_CLUSTER).
  --help	     	 Display this menu.
EOF
)"

for i in "$@"
do
  case "${i}" in
    --region=*)
      DARK_REGION="${i/--region=/''}"
      ;;
    --project=*)
      DARK_PROJECT="${i/--project=/''}"
      ;;
    --cluster=*)
      DARK_CLUSTER="${i/--cluster=/''}"
      ;;
    --prefix=*)
      PREFIX="${i/--prefix=/''}-"
      ;;
    --help)
      echo "$HELP"
      exit 0
      ;;
    *)
      echo "Unexpected argument: $i"
      echo "$HELP"
      exit 1
      ;;
  esac
done

set -x

ROLLBAR_ACCESS_TOKEN="ac042ea56b054bbdbddbfffaa149004e"
ENVIRONMENT=production
LOCAL_USERNAME="$(grep 'account' ~/.config/gcloud/configurations/config_default | awk '{print $3}' | awk -F "@" '{print $1}')"

GCR="gcr.io/$DARK_PROJECT"

## Only fetch if we haven't just built, which we do on CI
if [[ "$CI" == "" ]]; then
  echo "Not on CI: fetching latest containers"
  ./scripts/gcp-fetch-latest-containers ${PREFIX:+"--prefix=${PREFIX}"} "--project=${DARK_PROJECT}"
else
  echo "On CI: not fetching latest containers"
fi

#############################
# Lock before doing a deploy (don't forget to unlock!)
#############################

deploy_lock_claimed=""

while [[ "${deploy_lock_claimed}" != "true" ]]; do
  if [[ "$CI" == "" ]]; then
    THIS_DEPLOY_LOCKFILE="manual-deploy"
  else
    THIS_DEPLOY_LOCKFILE="$(echo ${CIRCLE_BUILD_URL} | grep -Eo '[0-9]+$')"
  fi
  echo "Lock file: ${THIS_DEPLOY_LOCKFILE}"

  # If there's a manual lock, loop
  if (gsutil ls ${DEPLOY_LOCK_BUCKET}/deploy-lock-manual-deploy); then
    true # loop
  else
    max_deploy_lock=$( (gsutil ls ${DEPLOY_LOCK_BUCKET}/deploy-lock-* || true) \
      | sed 's/.*-//' | sort -nr | head -n 1)

    # if there are no deploy locks, create ours and continue
    if [[ "${max_deploy_lock}" == "" ]]; then
      echo date > "deploy-lock-${THIS_DEPLOY_LOCKFILE}"
      gsutil cp "deploy-lock-${THIS_DEPLOY_LOCKFILE}" "${DEPLOY_LOCK_BUCKET}"
      deploy_lock_claimed="true"
    # if the biggest # is greater than ours, then exit instead of deploying
    # NB: "manual-deploy" is greater than any numeric string, so it will always
    # wait, not exit early
    elif [[ "${max_deploy_lock}" -gt "${THIS_DEPLOY_LOCKFILE}"  ]]; then
      echo "Currently-running deploy ${max_deploy_lock} > ${THIS_DEPLOY_LOCKFILE}, so not deploying."
      exit 1
    # if the biggest # is smaller than ours, loop (we will deploy after)
    else
      true # loop
    fi
  fi

  echo "At $(date), sleeping 5s to wait for deploy lock..."
  sleep 5
done

#########################
# Tell Kubernetes what to do
#########################
IMAGE_ID="$(docker images $GCR/${PREFIX}dark-gcp -q | head -n 1)"
QW_IMAGE_ID="$(docker images $GCR/${PREFIX}dark-gcp-qw -q | head -n 1)"
CRON_IMAGE_ID="$(docker images $GCR/${PREFIX}dark-gcp-cron -q | head -n 1)"
TUNNEL_IMAGE_ID="$(docker images $GCR/${PREFIX}tunnel -q | head -n 1)"

IMAGE="$GCR/${PREFIX}dark-gcp:$IMAGE_ID"
QW_IMAGE="$GCR/${PREFIX}dark-gcp-qw:$QW_IMAGE_ID"
CRON_IMAGE="$GCR/${PREFIX}dark-gcp-cron:$CRON_IMAGE_ID"
TUNNEL_IMAGE="$GCR/${PREFIX}tunnel:$TUNNEL_IMAGE_ID"

# get creds
gcloud container clusters get-credentials "--zone=${DARK_REGION}" \
  "projects/${DARK_PROJECT}/zones/${DARK_REGION}/clusters/${DARK_CLUSTER}"

# env vars (replace existing configmap or make a new one)
(kubectl create configmap gke-dark-prod --from-env-file config/gke-builtwithdark -o yaml --dry-run | kubectl replace -f -) \
  ||  kubectl create configmap gke-dark-prod --from-env-file config/gke-builtwithdark

(kubectl create configmap nginx --from-file=scripts/support/nginx.conf -o yaml --dry-run | kubectl replace -f -) \
  ||  kubectl create configmap nginx --from-file=scripts/support/nginx.conf

CHANGE_CAUSE="'circle=${CIRCLE_BUILD_URL} ; orig-time: $(date)'"

sed -e "s!{IMAGE}!${IMAGE}!" -e "s!{CHANGE_CAUSE}!${CHANGE_CAUSE}!" scripts/support/builtwithdark.yaml.template > builtwithdark.yaml
sed -e "s!{QW_IMAGE}!${QW_IMAGE}!" -e "s!{CHANGE_CAUSE}!${CHANGE_CAUSE}!" scripts/support/queueworker.yaml.template > queueworker.yaml
sed -e "s!{CRON_IMAGE}!${CRON_IMAGE}!" -e "s!{CHANGE_CAUSE}!${CHANGE_CAUSE}!" scripts/support/cronchecker.yaml.template > cronchecker.yaml
sed -e "s!{TUNNEL_IMAGE}!${TUNNEL_IMAGE}!" -e "s!{CHANGE_CAUSE}!${CHANGE_CAUSE}!" scripts/support/tunnel.yaml.template > tunnel.yaml

# make sure deployment matches current understanding
kubectl apply -f builtwithdark.yaml
kubectl apply -f queueworker.yaml
kubectl apply -f cronchecker.yaml
kubectl apply -f tunnel.yaml

#########################
# Tell everyone else what's going on
#########################
curl -s https://api.rollbar.com/api/1/deploy/ \
  -F "access_token=${ROLLBAR_ACCESS_TOKEN}" \
  -F "environment=${ENVIRONMENT}" \
  -F "revision=${IMAGE}" \
  -F "comment=${CIRCLE_BUILD_URL}" \
  -F "local_username=${LOCAL_USERNAME}" > /dev/null
echo "Rollbar notified."

####################
# Unlock post-deploy
####################
gsutil rm "${DEPLOY_LOCK_BUCKET}/deploy-lock-${THIS_DEPLOY_LOCKFILE}"
