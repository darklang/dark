#!/usr/bin/env bash
# shellcheck disable=SC2068
# shellcheck disable=SC2086

# Right now this lives in-repo in scripts/; in the medium term, this should be a
# thing we distribute to customers somehow, and probably not a shell script.

set -euo pipefail

progname=$(basename $0)
dry_run=0

sub_help(){
  cat << EOF > /dev/stdout
Usage: $progname <subcommand> [options]
Subcommands:
assets

For help with a subcommand, run:
$progname <subcommand> -h|--help

NB: at least for now, filenames with spaces will break this script.
EOF
}

sub_assets() {
  set +u
  subsubcommand=$1
  set -u

  CURLCMD=curl
  if ! (command -v $CURLCMD > /dev/null ); then
    echo "Error: $progname $subcommand depends on CURLCMD ($CURLCMD) being installed."
    exit
  fi

  case $subsubcommand in
    "" | "-h" | "--help")
      sub_assets_help
      exit 0
      ;;
    *)
      shift
      sub_assets_${subsubcommand} $@
      if [ $? = 127 ]; then
        echo "Error: '$subcommand' is not a known subcommand of $subcommand." >&2
        echo "     Run '$progname $subcommand --help' for a list of known subcommands." >&2
        exit 1
      fi
      ;;
  esac
}

sub_assets_help(){
  cat << EOF > /dev/stdout
Usage: $progname assets <subsubcommand> [options]
Subsubcommands:
upload

For help with a subsubcommand, run:
$progname assets -h|--help

NB: at least for now, filenames with spaces will break this script.
EOF
}

sub_assets_upload() {
  if (( $# == 0 )); then
    sub_assets_upload_help
    exit 0
  fi

  if ! options=$(getopt -o c:,n: --long user:,password:,host:,canvas:,dry,dry-run -- "$@"); then
    echo "Error: incorrect options provided"
    exit 1
  fi
  eval set -- "$options"

  while true; do
    case $1 in
      "" | "-h" | "--help")
        sub_assets_upload_help
        exit 0
        ;;
      "-c" | "--canvas")
        shift
        canvas=$1
        shift
        ;;
      "-n" | "--name")
        shift
        name=$1
        shift
        ;;
      "--host")
        shift
        host=$1
        shift
        ;;
      "--user")
        shift
        user=$1
        shift
        ;;
      "--password")
        shift
        password=$1
        shift
        ;;
    "--dry" | "--dry-run")
        dry_run=1
        shift
        ;;
      --)
        shift
        break
        ;;
    esac
  done

  if (( $# == 0 )); then
    echo "Error: no path(s) provided."
    exit 1
  fi

  if [[ -z ${user:-} ]]; then
    echo "Error: user is a required flag."
    exit 1
  fi

  if [[ -z ${password:-} ]]; then
    if [[ -z ${DARK_PASSWORD:-} ]]; then
      echo "Error: password is a required flag or environment variable (DARK_PASSWORD)."
      exit 1
    else
      password=$DARK_PASSWORD
    fi
  fi

  if [[ -z ${canvas:-} ]]; then
    echo "Error: canvas is a required flag."
    exit 1
  fi

  name=${name:-main}
  host=${host:-https://darklang.com}

  if ((dry_run == 1)); then
      CURLCMD="echo $CURLCMD"
  fi


  if ((dry_run == 1)); then
      cookie="[redacted]"
      csrf="[redacted]"
  fi

  set +e
  if ! authcurl=$(curl -i -u $user:$password ${host}/a/${canvas} 2>/dev/null |
    grep -o -e '^set-cookie:.*' -e 'csrfToken = ".*"'); then
    echo "Failed to auth (curl)."
    exit 1
  fi
  set -e

  # shellcheck disable=SC2001
  cookie=$(echo $authcurl | sed 's/.*set-cookie: \([^;]*\).*/\1/')
  # shellcheck disable=SC2001
  csrf=$(echo $authcurl | sed 's/.*csrfToken = "\(.*\)".*/\1/')

  if [[ "$cookie" == "" || "$csrf" == "" ]]; then
    echo "Failed to auth (response)."
    exit 1
  fi

  # shellcheck disable=SC2048
  find $* -type f -printf '-F %P=@%p\n' \
      | xargs $CURLCMD -i -X POST -H 'Cookie: '"$cookie"'' -H 'X-CSRF-Token: '"$csrf"'' ${host}/api/${canvas}/static_assets

  exit 1
}

sub_assets_upload_help(){
  cat << EOF > /dev/stdout
Usage: $progname assets upload --canvas=<canvas> [--host=<host>] --user=<user> --password=<password> <path(s)>

You may replace --password with a DARK_PASSWORD environment variable.  (This is your user's password.)

--canvas is the canvas to upload to

--host is optional, intended for dark-internal use only.

NB: at least for now, filenames with spaces will break this script.
EOF
}


set +u
subcommand=$1
set -u

case $subcommand in
  "" | "-h" | "--help")
    sub_help
    exit 0
    ;;
  *)
    shift
    sub_${subcommand} $@
    if [ $? = 127 ]; then
      echo "Error: '$subcommand' is not a known subcommand." >&2
      echo "     Run '$progname --help' for a list of known subcommands." >&2
      exit 1
    fi
    ;;
esac
