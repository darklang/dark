// Tool-related functionality for the Model Context Protocol
// Enables LLMs to perform actions through the server (expose executable functions that can be invoked by the client)

module Darklang =
  module ModelContextProtocol =
    module Tools =
      // <aliases>
      type Json = Stdlib.AltJson.Json
      type ToolDescription = Darklang.ModelContextProtocol.ToolDescription
      type ToolAnnotations = Darklang.ModelContextProtocol.ToolAnnotations
      type ToolId = Darklang.ModelContextProtocol.ToolId
      // </aliases>


      /// Schema for the listTools request
      module ListToolsRequest =
        type ListToolsParams = {
          cursor: Stdlib.Option.Option<String>
        }

        let fromJson (json: Json) : Stdlib.Result.Result<ListToolsParams, String> =
          match json with
          | Object fields ->
            let cursorResult =
              match Stdlib.List.findFirst fields (fun (k, _) -> k == "cursor") with
              | Some ((_, String cursor)) -> Stdlib.Result.Result.OK (Stdlib.Option.Option.Some cursor)
              | Some ((_, Null)) -> Stdlib.Result.Result.Ok Stdlib.Option.Option.None
              | Some ((_, _)) -> Stdlib.Result.Result.Error "cursor must be a string or null"
              | None -> Stdlib.Result.Result.Ok Stdlib.Option.Option.None

            cursorResult |> Stdlib.Result.map (fun cursor -> ListToolsParams { cursor = cursor })
          | _ ->
            Stdlib.Result.Result.Error "params must be an object"


      module ListToolsResponse =
        type ListToolsResponse = {
          tools: List<ToolDescription>
          nextCursor: Stdlib.Option.Option<String>
        }

        module ToolAnnotations =
          let toJson (annotations: ToolAnnotations) : Json =
            let titleJson =
              Stdlib.Option.mapWithDefault annotations.title Json.Null (fun s -> Json.String s)

            let readOnlyHintJson =
              Stdlib.Option.mapWithDefault annotations.readOnlyHint Json.Null (fun b -> Json.Bool b)

            let destructiveHintJson =
              Stdlib.Option.mapWithDefault annotations.destructiveHint Json.Null (fun b -> Json.Bool b)

            let idempotentHintJson =
              Stdlib.Option.mapWithDefault annotations.idempotentHint Json.Null (fun b -> Json.Bool b)

            let openWorldHintJson =
              Stdlib.Option.mapWithDefault annotations.openWorldHint Json.Null (fun b -> Json.Bool b)

            Json.Object [
              ("title", titleJson);
              ("readOnlyHint", readOnlyHintJson);
              ("destructiveHint", destructiveHintJson);
              ("idempotentHint", idempotentHintJson);
              ("openWorldHint", openWorldHintJson)
            ]

        let toJson (response: ListToolsResponse) : Json =
          let toolsJson =
            response.tools
            |> Stdlib.List.map (fun tool ->
              let fields = [
                ("name", Json.String tool.name);
                ("inputSchema", tool.inputSchema)
              ]
              
              let fieldsWithDescription = 
                match tool.description with
                | Some desc -> Stdlib.List.append fields [("description", Json.String desc)]
                | None -> fields

              let fieldsWithOutputSchema =
                match tool.outputSchema with
                | Some schema ->
                    Stdlib.List.append fieldsWithDescription [("outputSchema", schema)]
                | None ->
                    fieldsWithDescription

              let fieldsWithAnnotations =
                match tool.annotations with
                | Some annotations ->
                    Stdlib.List.append
                      fieldsWithOutputSchema
                      [("annotations", ToolAnnotations.toJson annotations)]
                | None ->
                    fieldsWithOutputSchema

              Json.Object fieldsWithAnnotations
            )

          [ Stdlib.Option.Option.Some(("tools", Json.Array toolsJson))
            response.nextCursor |> Stdlib.Option.map (fun c -> ("nextCursor", Json.String c)) ]
          |> Stdlib.Option.values
          |> Json.Object


      module CallToolRequest =
        type CallToolParams = {
          name: ToolId
          arguments: Json // JSON object with tool-specific arguments
        }

        let fromJson (json: Json) : Stdlib.Result.Result<CallToolParams, String> =
          match json with
          | Object fields ->
            let nameResult =
              match Stdlib.List.findFirst fields (fun (k, _) -> k == "name") with
              | Some ((_, String name)) -> Stdlib.Result.Result.Ok name
              | Some ((_, _)) -> Stdlib.Result.Result.Error "name must be a string"
              | None -> Stdlib.Result.Result.Error "name is required"

            let argumentsResult =
              match Stdlib.List.findFirst fields (fun (k, _) -> k == "arguments") with
              | Some ((_, obj)) when Stdlib.AltJson.isObject obj -> Stdlib.Result.Result.Ok obj
              | Some ((_, _)) -> Stdlib.Result.Result.Error "arguments must be an object"
              | None -> Stdlib.Result.Result.Error "arguments is required"

            match (nameResult, argumentsResult) with
            | (Ok name, Ok arguments) ->
                Stdlib.Result.Result.Ok (CallToolParams { name = name; arguments = arguments })
            | (Error e, _) -> Stdlib.Result.Result.Error e
            | (_, Error e) -> Stdlib.Result.Result.Error e
          | _ ->
            Stdlib.Result.Result.Error "params must be an object"


      module CallToolResponse =
        type ContentItem =
          | TextContent of String
          | ImageContent of ImageContent
          | AudioContent of AudioContent
          | ResourceContent of ResourceContent

        type CallToolResult = {
          content: List<ContentItem>
          isError: Bool
        }

        let toJson (result: CallToolResult) : Json =
          let contentJson =
            result.content
            |> Stdlib.List.map ( fun item ->
              match item with
              | TextContent text -> 
                  Json.Object [("type", Json.String "text"); ("text", Json.String text)]
              | ImageContent img ->
                  Json.Object [
                    ("type", Json.String "image"); 
                    ("data", Json.String img.data);
                    ("mimeType", Json.String img.mimeType)
                  ]
              | AudioContent audio ->
                  Json.Object [
                    ("type", Json.String "audio"); 
                    ("data", Json.String audio.data);
                    ("mimeType", Json.String audio.mimeType)
                  ]
              | ResourceContent resource ->
                  Json.Object [
                    ("type", Json.String "resource");
                    ("uri", Json.String resource.uri);
                    ("mimeType", Json.String resource.mimeType);
                    ("text", Json.String resource.text)
                  ]
            )

          Json.Object [
            ("content", Json.Array contentJson);
            ("isError", Json.Bool result.isError)
          ]

