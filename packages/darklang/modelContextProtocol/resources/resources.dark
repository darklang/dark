// Resource-related functionality for the Model Context Protocol
module Darklang.ModelContextProtocol.Resources


// <aliases>
// Json type alias removed to prevent UNIQUE constraint conflicts
// </aliases>


/// Schema for the listResources request
module ListResourcesRequest =
  type ListResourcesParams =
    { cursor: Stdlib.Option.Option<String> }

  let fromJson (json: Json) : Stdlib.Result.Result<ListResourcesParams, String> =
    match json with
    | Object fields ->
      let cursorResult =
        match Stdlib.List.findFirst fields (fun (k, _) -> k == "cursor") with
        | Some ((_, String cursor)) -> Stdlib.Result.Result.Ok (Stdlib.Option.Option.Some cursor)
        | Some ((_, Null)) -> Stdlib.Result.Result.Ok Stdlib.Option.Option.None
        | Some ((_, _)) -> Stdlib.Result.Result.Error "cursor must be a string or null"
        | None -> Stdlib.Result.Result.Ok Stdlib.Option.Option.None

      match cursorResult with
      | Ok cursor ->
          Stdlib.Result.Result.Ok (ListResourcesParams { cursor = cursor })
      | Error err ->
          Stdlib.Result.Result.Error err
    | _ ->
      Stdlib.Result.Result.Error "params must be an object"

module ListResourcesResponse =
  type ResourceDescription =
    { uri: ModelContextProtocol.ResourceUri
      name: String
      description: Stdlib.Option.Option<String>
      mimeType: Stdlib.Option.Option<String> }

  type ListResourcesResponse =
    { resources: List<ResourceDescription>
      nextCursor: Stdlib.Option.Option<String> }

  let toJson (response: ListResourcesResponse) : Json =
    let resourcesJson =
      response.resources
      |> Stdlib.List.map (fun resource ->
        let fields = [
          ("uri", Json.String resource.uri)
          ("name", Json.String resource.name)
        ]

        let fieldsWithDescription =
          match resource.description with
          | Some desc ->
            Stdlib.List.append fields [("description", Json.String desc)]
          | None -> fields

        let fieldsWithMimeType =
          match resource.mimeType with
          | Some mime ->
            Stdlib.List.append fieldsWithDescription [("mimeType", Json.String mime)]
          | None -> fieldsWithDescription

        Json.Object fieldsWithMimeType
      )

    [ Stdlib.Option.Option.Some(("resources", Json.Array resourcesJson))
      response.nextCursor |> Stdlib.Option.map (fun c -> ("nextCursor", Json.String c)) ]
    |> Stdlib.Option.values
    |> Json.Object


/// Schema for the readResource request
module ReadResourceParams =
  type ReadResourceParams =
    { uri: ModelContextProtocol.ResourceUri }

  let fromJson (json: Json) : Stdlib.Result.Result<ReadResourceParams, String> =
    match json with
    | Object fields ->
      match Stdlib.List.findFirst fields (fun (k, _) -> k == "uri") with
      | Some (_, String uri) ->
          Stdlib.Result.Result.Ok (ReadResourceParams { uri = uri })
      | Some (_, _) ->
          Stdlib.Result.Result.Error "uri must be a string"
      | None ->
          Stdlib.Result.Result.Error "uri is required"
    | _ ->
        Stdlib.Result.Result.Error "params must be an object"

  let toJson (params: ReadResourceParams) : Json =
    Json.Object [
      ("uri", Json.String params.uri)
    ]

module ReadResourceResponse =
  type ResourceContent =
    { uri: ModelContextProtocol.ResourceUri
      mimeType: ModelContextProtocol.MimeType
      text: String }

  type ReadResourceResponse =
    { contents: List<ResourceContent> }

  let toJson (response: ReadResourceResponse) : Json =
    let contentsJson =
      response.contents
      |> Stdlib.List.map (fun content ->
        Json.Object [
          ("uri", Json.String content.uri);
          ("mimeType", Json.String content.mimeType);
          ("text", Json.String content.text)
        ]
      )

    Json.Object [
      ("contents", Json.Array contentsJson)
    ]


/// Schema for the listResourceTemplates request
module ListResourceTemplatesRequest =
  type ListResourceTemplatesParams =
    { method: String }

  let fromJson (json: Json) : Stdlib.Result.Result<ListResourceTemplatesParams, String> =
    match json with
    | Object fields ->
      match Stdlib.List.findFirst fields (fun (k, _) -> k == "method") with
      | Some (_, String method) ->
          Stdlib.Result.Result.Ok (ListResourceTemplatesParams { method = method })
      | Some (_, _) ->
          Stdlib.Result.Result.Error "method must be a string"
      | None ->
          Stdlib.Result.Result.Error "method is required"
    | _ ->
        Stdlib.Result.Result.Error "params must be an object"


module ListResourceTemplatesResponse =

  type ResourceTemplateDescription =
    { uriTemplate: ResourceUriTemplate
      name: String
      description: Stdlib.Option.Option<String>
      mimeType: Stdlib.Option.Option<String> }

  type ListResourceTemplatesResponse =
    { resourceTemplates: List<ResourceTemplateDescription> }

  let toJson (response: ListResourceTemplatesResponse) : Json =
    let templatesJson =
      response.resourceTemplates
      |> Stdlib.List.map (fun template ->
        let fields = [
          ("uriTemplate", Json.String template.uriTemplate);
          ("name", Json.String template.name)
        ]

        let fieldsWithDescription =
          match template.description with
          | Some desc ->
            Stdlib.List.append fields [("description", Json.String desc)]
          | None -> fields

        let fieldsWithMimeType =
          match template.mimeType with
          | Some mime ->
            Stdlib.List.append fieldsWithDescription [("mimeType", Json.String mime)]
          | None -> fieldsWithDescription

        Json.Object fieldsWithMimeType
      )

    Json.Object [
      ("resourceTemplates", Json.Array templatesJson)
    ]


/// Helper functions for working with resources
module Helpers =
  /// Check if a URI matches a URI template
  let uriMatchesTemplate (uri: ResourceUri) (template: ResourceUriTemplate) : Bool =
    // Simple implementation - just checks if the URI starts with the template
    // A more sophisticated implementation would handle URI template variables
    Stdlib.String.startsWith uri template

  /// Extract variables from a URI based on a template
  let extractUriVariables (uri: ResourceUri) (template: ResourceUriTemplate) : Stdlib.Option.Option<Dict<String>> =
    // This is a simplified implementation that assumes templates use {varName} syntax
    // A more complete implementation would handle more complex URI template syntax

    // Split both the URI and template into segments
    let uriSegments = Stdlib.String.split uri "/"
    let templateSegments = Stdlib.String.split template "/"

    // If they have different lengths, they don't match
    if Stdlib.List.length uriSegments != Stdlib.List.length templateSegments then
      Stdlib.Option.Option.None
    else
      // Extract variables from each segment
      let variablePairs =
        (Stdlib.List.zip uriSegments templateSegments)
        |> Stdlib.List.filterMap (fun (uriSeg, templateSeg) ->
          // Check if this segment is a variable (enclosed in {})
          if Stdlib.String.startsWith templateSeg "{" && Stdlib.String.endsWith templateSeg "}" then
            // Extract the variable name (remove the {})
            let varName =
              templateSeg
              |> Stdlib.String.dropFirst 1L
              |> Stdlib.String.dropLast 1L

            Stdlib.Option.Option.Some (varName, uriSeg)
          else if uriSeg == templateSeg then
            // This is a static segment that matches
            Stdlib.Option.Option.None
          else
            // This is a static segment that doesn't match
            Stdlib.Option.Option.None
        )

      // Convert the list of pairs to a dictionary
      (Stdlib.Dict.fromList variablePairs)
      |> Stdlib.Option.Option.Some