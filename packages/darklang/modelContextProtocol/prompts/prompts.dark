module Darklang.ModelContextProtocol.Prompts


module ListPromptsRequest =
  type ListPromptsParams = {
    cursor: Stdlib.Option.Option<String>
  }

  let fromJson (json: Json) : Stdlib.Result.Result<ListPromptsParams, String> =
    match json with
    | Object fields ->
      let cursorResult =
        match Stdlib.List.findFirst fields (fun (k, _) -> k == "cursor") with
        | Some ((_, String cursor)) -> Stdlib.Result.Result.Ok (Some cursor)
        | Some ((_, Null)) -> Stdlib.Result.Result.Ok None
        | Some ((_, _)) -> Stdlib.Result.Result.Error "cursor must be a string or null"
        | None -> Stdlib.Result.Result.Ok None

      cursorResult |> Stdlib.Result.map (fun cursor -> ListPromptsParams { cursor = cursor })
    | _ ->
      Stdlib.Result.Result.Error "params must be an object"


module PromptArgument =
  type PromptArgument = {
    name: String
    description: Stdlib.Option.Option<String>
    required: Stdlib.Option.Option<Bool>
  }

  let toJson (arg: PromptArgument) : Json =
    [ Stdlib.Option.Option.Some(("name", Json.String arg.name))
      arg.description |> Stdlib.Option.map (fun d -> ("description", Json.String d))
      arg.required |> Stdlib.Option.map (fun r -> ("required", Json.Bool r)) ]
    |> Stdlib.Option.values
    |> Json.Object

module PromptDescription =
  type PromptDescription = {
    name: String
    description: Stdlib.Option.Option<String>
    arguments: Stdlib.Option.Option<List<PromptArgument.PromptArgument>>
  }

  let toJson (prompt: PromptDescription) : Json =
    let argsJson =
      match prompt.arguments with
      | Some args ->
          Json.Array (args |> Stdlib.List.map PromptArgument.toJson)
      | None -> Json.Array []

    [ Stdlib.Option.Option.Some(("name", Json.String prompt.name))
      prompt.description |> Stdlib.Option.map (fun d -> ("description", Json.String d))
      Stdlib.Option.Option.Some(("arguments", argsJson)) ]
    |> Stdlib.Option.values
    |> Json.Object

module ListPromptsResponse =
  type ListPromptsResult = {
    prompts: List<PromptDescription.PromptDescription>
    nextCursor: Stdlib.Option.Option<String>
  }

  let toJson (result: ListPromptsResult) : Json =
    let promptsJson = result.prompts |> Stdlib.List.map PromptDescription.toJson

    [ Stdlib.Option.Option.Some(("prompts", Json.Array promptsJson))
      result.nextCursor |> Stdlib.Option.map (fun c -> ("nextCursor", Json.String c)) ]
    |> Stdlib.Option.values
    |> Json.Object


module GetPromptRequest =
  type GetPromptParams = {
    name: String
    arguments: Json
  }

  let fromJson (json: Json) : Stdlib.Result.Result<GetPromptParams, String> =
    match json with
    | Object fields ->
      let nameResult =
        match Stdlib.List.findFirst fields (fun (k, _) -> k == "name") with
        | Some ((_, String name)) -> Stdlib.Result.Result.Ok name
        | Some ((_, _)) -> Stdlib.Result.Result.Error "name must be a string"
        | None -> Stdlib.Result.Result.Error "name is required"

      let argsResult =
        match Stdlib.List.findFirst fields (fun (k, _) -> k == "arguments") with
        | Some ((_, args)) -> Stdlib.Result.Result.Ok args
        | None -> Stdlib.Result.Result.Error "arguments is required"

      match (nameResult, argsResult) with
      | (Ok name, Ok args) ->
          Stdlib.Result.Result.Ok (GetPromptParams { name = name; arguments = args })
      | (Error e, _) -> Stdlib.Result.Result.Error e
      | (_, Error e) -> Stdlib.Result.Result.Error e
    | _ ->
        Stdlib.Result.Result.Error "params must be an object"


module GetPromptResponse =
  type MessageRole =
    | User
    | Assistant

  type PromptContent =
    | Text of String
    | Resource of Json // Placeholder for resource content

  type PromptMessage = {
    role: MessageRole
    content: PromptContent
  }

  type GetPromptResult = {
    description: Stdlib.Option.Option<String>
    messages: List<PromptMessage>
  }

  let toJson (result: GetPromptResult) : Json =
    let messagesJson =
      result.messages |> Stdlib.List.map (fun msg ->
        let roleStr =
          match msg.role with
          | User -> "user"
          | Assistant -> "assistant"

        let contentJson =
          match msg.content with
          | Text text -> Json.Object [("type", Json.String "text"); ("text", Json.String text)]
          | Resource res -> Json.Object [("type", Json.String "resource"); ("content", res)]

        Json.Object [
          ("role", Json.String roleStr);
          ("content", contentJson)
        ])

    [ result.description |> Stdlib.Option.map (fun d -> ("description", Json.String d))
      Stdlib.Option.Option.Some(("messages", Json.Array messagesJson)) ]
    |> Stdlib.Option.values
    |> Json.Object
