module Darklang =
  module ModelContextProtocol =
    module Prompts =
      module ListPromptsRequest =
        type ListPromptsParams = {
          cursor: Stdlib.Option.Option<String>
        }

        let fromJson (json: Json) : Stdlib.Result.Result<ListPromptsParams, String> =
          match json with
          | Object fields ->
            let cursorResult =
              match Stdlib.List.findFirst fields (fun (k, _) -> k == "cursor") with
              | Some ((_, String cursor)) -> Stdlib.Result.Result.Ok (Some cursor)
              | Some ((_, Null)) -> Stdlib.Result.Result.Ok None
              | Some ((_, _)) -> Stdlib.Result.Result.Error "cursor must be a string or null"
              | None -> Stdlib.Result.Result.Ok None

            cursorResult |> Stdlib.Result.map (fun cursor -> ListPromptsParams { cursor = cursor })
          | _ ->
            Stdlib.Result.Result.Error "params must be an object"

      module ListPromptsResponse =
        type PromptArgument = {
          name: String
          description: Stdlib.Option.Option<String>
          required: Stdlib.Option.Option<Bool>
        }

        type PromptDescription = {
          name: String
          description: Stdlib.Option.Option<String>
          arguments: Stdlib.Option.Option<List<PromptArgument>>
        }

        type ListPromptsResult = {
          prompts: List<PromptDescription>
          nextCursor: Stdlib.Option.Option<String>
        }

        let toJson (result: ListPromptsResult) : Json =
          let promptsJson =
            result.prompts |> Stdlib.List.map (fun prompt ->
              let argsJson =
                match prompt.arguments with
                | Some args ->
                    Json.Array (args |> Stdlib.List.map (fun arg ->
                      Json.Object [
                        ("name", Json.String arg.name);
                        ("description", Stdlib.Option.mapToJson arg.description);
                        ("required", Stdlib.Option.mapToJson arg.required)
                      ]))
                | None -> Json.Array []

              Json.Object [
                ("name", Json.String prompt.name);
                ("description", Stdlib.Option.mapToJson prompt.description);
                ("arguments", argsJson)
              ])

          Json.Object [
            ("prompts", Json.Array promptsJson);
            ("nextCursor", Stdlib.Option.mapToJson result.nextCursor)
          ]


      module GetPromptRequest =
        type GetPromptParams = {
          name: String
          arguments: Json
        }

        let fromJson (json: Json) : Stdlib.Result.Result<GetPromptParams, String> =
          match json with
          | Object fields ->
            let nameResult =
              match Stdlib.List.findFirst fields (fun (k, _) -> k == "name") with
              | Some ((_, String name)) -> Stdlib.Result.Result.Ok name
              | Some ((_, _)) -> Stdlib.Result.Result.Error "name must be a string"
              | None -> Stdlib.Result.Result.Error "name is required"

            let argsResult =
              match Stdlib.List.findFirst fields (fun (k, _) -> k == "arguments") with
              | Some ((_, args)) -> Stdlib.Result.Result.Ok args
              | None -> Stdlib.Result.Result.Error "arguments is required"

            match (nameResult, argsResult) with
            | (Ok name, Ok args) ->
                Stdlib.Result.Result.Ok (GetPromptParams { name = name; arguments = args })
            | (Error e, _) -> Stdlib.Result.Result.Error e
            | (_, Error e) -> Stdlib.Result.Result.Error e
          | _ ->
              Stdlib.Result.Result.Error "params must be an object"


      module GetPromptResponse =
        type MessageRole =
          | User
          | Assistant

        type PromptContent =
          | Text of String
          | Resource of Json // Placeholder for resource content

        type PromptMessage = {
          role: MessageRole
          content: PromptContent
        }

        type GetPromptResult = {
          description: Stdlib.Option.Option<String>
          messages: List<PromptMessage>
        }

        let toJson (result: GetPromptResult) : Json =
          let messagesJson =
            result.messages |> Stdlib.List.map (fun msg ->
              let roleStr =
                match msg.role with
                | User -> "user"
                | Assistant -> "assistant"

              let contentJson =
                match msg.content with
                | Text text -> Json.Object [("type", Json.String "text"); ("text", Json.String text)]
                | Resource res -> Json.Object [("type", Json.String "resource"); ("content", res)]

              Json.Object [
                ("role", Json.String roleStr);
                ("content", contentJson)
              ])

          Json.Object [
            ("description", Stdlib.Option.mapToJson result.description);
            ("messages", Json.Array messagesJson)
          ]
