// Initialization for the Model Context Protocol
module Darklang.ModelContextProtocol.LifeCycle.InitializeRequest

/// Client capabilities for the Model Context Protocol
type ClientCapabilities =
  { elicitation: Stdlib.Option.Option<Json>
    experimental: Stdlib.Option.Option<Dict<Json>>
    roots: Stdlib.Option.Option<RootsClientCapabilities>
    sampling: Stdlib.Option.Option<Json> }

/// Roots client capabilities
type RootsClientCapabilities =
  { listChanged: Stdlib.Option.Option<Bool> }

/// Parameters for the initialize request
type InitializeParams =
  { clientInfo: Stdlib.Option.Option<ClientInfo>
    capabilities: ClientCapabilities
    trace: Stdlib.Option.Option<TraceLevel> }

/// Client information
type ClientInfo =
  { name: String
    version: Stdlib.Option.Option<String> }

let fromJson (json: Json) : Stdlib.Result.Result<InitializeParams, String> =
  match json with
  | Object fields ->
    // Parse clientInfo if present
    let clientInfoResult =
      match Stdlib.List.findFirst fields (fun (k, _) -> k == "clientInfo") with
      | Some clientInfoEntry ->
        match clientInfoEntry with
        | (_, Object clientInfoFields) ->
          match Stdlib.List.findFirst clientInfoFields (fun (k, _) -> k == "name") with
          | Some nameEntry ->
            match nameEntry with
            | (_, String name) ->
              let version =
                match Stdlib.List.findFirst clientInfoFields (fun (k, _) -> k == "version") with
                | Some versionEntry ->
                  match versionEntry with
                  | (_, String v) -> Stdlib.Option.Option.Some v
                  | _ -> Stdlib.Option.Option.None
                | None -> Stdlib.Option.Option.None

              Stdlib.Result.Result.Ok (Stdlib.Option.Option.Some (ClientInfo { name = name; version = version }))
            | _ -> Stdlib.Result.Result.Error "clientInfo.name must be a string"
          | None -> Stdlib.Result.Result.Error "clientInfo.name is required"
        | (_, _) -> Stdlib.Result.Result.Error "clientInfo must be an object"
      | None -> Stdlib.Result.Result.Ok Stdlib.Option.Option.None

    // Parse capabilities (required)
    let capabilitiesResult =
      match Stdlib.List.findFirst fields (fun (k, _) -> k == "capabilities") with
      | Some capEntry ->
        match capEntry with
        | (_, Object capFields) ->
          // Parse elicitation
          let elicitation =
            match Stdlib.List.findFirst capFields (fun (k, _) -> k == "elicitation") with
            | Some (_, json) -> Stdlib.Option.Option.Some json
            | None -> Stdlib.Option.Option.None

          // Parse experimental
          let experimental =
            match Stdlib.List.findFirst capFields (fun (k, _) -> k == "experimental") with
            | Some (_, Object expFields) ->
              let dict = Stdlib.List.fold Stdlib.Dict.empty expFields (fun acc (key, value) ->
                Stdlib.Dict.set acc key value
              )
              Stdlib.Option.Option.Some dict
            | _ -> Stdlib.Option.Option.None

          // Parse roots
          let roots =
            match Stdlib.List.findFirst capFields (fun (k, _) -> k == "roots") with
            | Some (_, Object rootFields) ->
              let listChanged =
                match Stdlib.List.findFirst rootFields (fun (k, _) -> k == "listChanged") with
                | Some (_, Bool b) -> Stdlib.Option.Option.Some b
                | _ -> Stdlib.Option.Option.None
              Stdlib.Option.Option.Some (RootsClientCapabilities { listChanged = listChanged })
            | _ -> Stdlib.Option.Option.None

          // Parse sampling
          let sampling =
            match Stdlib.List.findFirst capFields (fun (k, _) -> k == "sampling") with
            | Some (_, json) -> Stdlib.Option.Option.Some json
            | None -> Stdlib.Option.Option.None

          Stdlib.Result.Result.Ok (ClientCapabilities {
            elicitation = elicitation;
            experimental = experimental;
            roots = roots;
            sampling = sampling
          })
        | (_, _) -> Stdlib.Result.Result.Error "capabilities must be an object"
      | None -> Stdlib.Result.Result.Error "capabilities is required"

    // Parse trace if present
    let traceResult =
      match Stdlib.List.findFirst fields (fun (k, _) -> k == "trace") with
      | Some (_, String s) ->
        match TraceLevel.fromString s with
        | Ok level -> Stdlib.Result.Result.Ok (Stdlib.Option.Option.Some level)
        | Error e -> Stdlib.Result.Result.Error e
      | Some _ -> Stdlib.Result.Result.Error "trace must be a string"
      | None -> Stdlib.Result.Result.Ok Stdlib.Option.Option.None

    // Combine all results
    match (clientInfoResult, capabilitiesResult, traceResult) with
    | (Ok clientInfo, Ok capabilities, Ok trace) ->
        Stdlib.Result.Result.Ok (InitializeParams { clientInfo = clientInfo; capabilities = capabilities; trace = trace })
    | (Error e, _, _) -> Stdlib.Result.Result.Error e
    | (_, Error e, _) -> Stdlib.Result.Result.Error e
    | (_, _, Error e) -> Stdlib.Result.Result.Error e
  | _ -> Stdlib.Result.Result.Error "params must be an object"

let toJson (params: InitializeParams) : Json =
  // Build capabilities object
  let capabilitiesFields =
    [ params.capabilities.elicitation |> Stdlib.Option.map (fun e -> ("elicitation", e))

      params.capabilities.experimental |> Stdlib.Option.map (fun exp ->
        ("experimental", (Stdlib.Dict.toList exp) |> Json.Object))

      params.capabilities.roots |> Stdlib.Option.map (fun roots ->
        let rootsFields =
          [ roots.listChanged |> Stdlib.Option.map (fun lc -> ("listChanged", Json.Bool lc)) ]
          |> Stdlib.Option.values
        ("roots", Json.Object rootsFields))

      params.capabilities.sampling |> Stdlib.Option.map (fun s -> ("sampling", s)) ]
    |> Stdlib.Option.values

  // Build all top-level fields
  [ params.clientInfo |> Stdlib.Option.map (fun info ->
      let infoFields =
        [ Stdlib.Option.Option.Some(("name", Json.String info.name))
          info.version |> Stdlib.Option.map (fun v -> ("version", Json.String v)) ]
        |> Stdlib.Option.values
      ("clientInfo", Json.Object infoFields))

    Stdlib.Option.Option.Some(("capabilities", Json.Object capabilitiesFields))

    params.trace |> Stdlib.Option.map (fun t ->
      ("trace", Json.String (TraceLevel.toString t))) ]
  |> Stdlib.Option.values
  |> Json.Object

/// Result of the initialize request
module InitializeResult =
  type InitializeResult =
    { protocolVersion: String
      serverInfo: ServerInfo
      capabilities: ServerCapabilities
      instructions: Stdlib.Option.Option<String> }

  let toJson (result: InitializeResult) : Json =
    // Build capabilities object
    let capabilitiesFields =
      [ result.capabilities.resources |> Stdlib.Option.map (fun res ->
          let resFields =
            [ res.listChanged |> Stdlib.Option.map (fun lc -> ("listChanged", Json.Bool lc))
              res.subscribe |> Stdlib.Option.map (fun s -> ("subscribe", Json.Bool s)) ]
            |> Stdlib.Option.values
          ("resources", Json.Object resFields))
        
        result.capabilities.tools |> Stdlib.Option.map (fun tools ->
          let toolFields =
            [ tools.listChanged |> Stdlib.Option.map (fun lc -> ("listChanged", Json.Bool lc)) ]
            |> Stdlib.Option.values
          ("tools", Json.Object toolFields))
        
        result.capabilities.prompts |> Stdlib.Option.map (fun prompts ->
          let promptFields =
            [ prompts.listChanged |> Stdlib.Option.map (fun lc -> ("listChanged", Json.Bool lc)) ]
            |> Stdlib.Option.values
          ("prompts", Json.Object promptFields))
        
        result.capabilities.logging |> Stdlib.Option.map (fun logging ->
          ("logging", logging))
        
        result.capabilities.completions |> Stdlib.Option.map (fun completions ->
          ("completions", completions))
        
        result.capabilities.experimental |> Stdlib.Option.map (fun exp ->
          ("experimental", (Stdlib.Dict.toList exp) |> Json.Object)) ]
      |> Stdlib.Option.values

    // Build all fields
    [ Stdlib.Option.Option.Some(("protocolVersion", Json.String result.protocolVersion))
      
      Stdlib.Option.Option.Some(("serverInfo", Json.Object [
        ("name", Json.String result.serverInfo.name);
        ("version", Json.String result.serverInfo.version)
      ]))
      
      Stdlib.Option.Option.Some(("capabilities", Json.Object capabilitiesFields))
      
      result.instructions |> Stdlib.Option.map (fun i -> ("instructions", Json.String i)) ]
    |> Stdlib.Option.values
    |> Json.Object