module Darklang =
  module LanguageTools =
    module WrittenTypesToProgramTypes =
      let gid () : Int64 =
        // TODO: fix upper range here
        Stdlib.Int64.random 0L 922337203685477580L

      let gtlid () : UInt64 =
        Stdlib.UInt64.random 0UL 9223372036854775807UL


      module Identifiers =
        module Type =
          let toPT (typ: WrittenTypes.TypeIdentifier) : String = typ.name

        module QualifiedType =
          let toPT
            (onMissing: NameResolver.OnMissing)
            (pm: ProgramTypes.PackageManager.PackageManager)
            (owner: String)
            (currentModule: List<String>)
            (i: WrittenTypes.QualifiedTypeIdentifier)
            : (ProgramTypes.NameResolution<ProgramTypes.FQTypeName.FQTypeName> *
              List<WrittenTypes.TypeReference.TypeReference>)
            =
            let typeArgs =
              Stdlib.List.map i.typeArgs (fun t ->
                TypeReference.toPT onMissing pm owner currentModule t)

            let nameToResolve =
              Stdlib.List.append
                (Stdlib.List.map i.modules (fun (m, _) -> m.name))
                [ i.typ |> Type.toPT ]

            let typeName =
              NameResolver.TypeName.resolve
                onMissing
                pm
                owner
                currentModule
                (WrittenTypes.Name.Unresolved(i.range, nameToResolve))

            (typeName, typeArgs)


        module Const =
          let toPT (c: WrittenTypes.ConstantIdentifier) : String = c.name

        module ConstOrFn =
          let toPT (c: WrittenTypes.ConstantOrFnIdentifier) : String = c.name


        module QualifiedConstOrFn =
          type ConstOrFn =
            | Const of
              ProgramTypes.NameResolution<ProgramTypes.FQConstantName.FQConstantName>
            | Fn of ProgramTypes.NameResolution<ProgramTypes.FQFnName.FQFnName>

          let toPT
            (onMissing: NameResolver.OnMissing)
            (pm: ProgramTypes.PackageManager.PackageManager)
            (owner: String)
            (currentModule: List<String>)
            (c: WrittenTypes.QualifiedConstantOrFnIdentifier)
            : Stdlib.Result.Result<ConstOrFn, ProgramTypes.NameResolution<ProgramTypes.FQConstantName.FQConstantName>> =
            let nameToResolve =
              Stdlib.List.append
                (Stdlib.List.map c.modules (fun (id, _) -> id.name))
                [ c.constantOrFn |> ConstOrFn.toPT ]

            let isConstant =
              NameResolver.ConstantName.resolve
                onMissing
                pm
                owner
                currentModule
                (WrittenTypes.Name.Unresolved(c.range, nameToResolve))

            let isFn =
              NameResolver.FnName.resolve
                onMissing
                pm
                owner
                currentModule
                (WrittenTypes.Name.Unresolved(c.range, nameToResolve))

            match isFn with
            | Ok _ -> isFn |> ConstOrFn.Fn |> Stdlib.Result.Result.Ok
            | Error _ ->
              match isConstant with
              | Ok _ -> isConstant |> ConstOrFn.Const |> Stdlib.Result.Result.Ok
              | Error _ -> isConstant

        module Fn =
          let toPT (fn: WrittenTypes.FnIdentifier) : String = fn.name

        module QualifiedFn =
          let toPT
            (onMissing: NameResolver.OnMissing)
            (pm: ProgramTypes.PackageManager.PackageManager)
            (owner: String)
            (currentModule: List<String>)
            (i: WrittenTypes.QualifiedFnIdentifier)
            : ProgramTypes.NameResolution<ProgramTypes.FQFnName.FQFnName> =
            let nameToResolve =
              Stdlib.List.append
                (Stdlib.List.map i.modules (fun (m, _) -> m.name))
                [ i.fn.name ]

            NameResolver.FnName.resolve
              onMissing
              pm
              owner
              currentModule
              (WrittenTypes.Name.Unresolved(i.range, nameToResolve))


      module TypeReference =
        module Builtin =
          let toPT
            (onMissing: NameResolver.OnMissing)
            (pm: ProgramTypes.PackageManager.PackageManager)
            (owner: String)
            (currentModule: List<String>)
            (t: WrittenTypes.TypeReference.Builtin)
            : ProgramTypes.TypeReference =
            match t with
            | TUnit _range -> ProgramTypes.TypeReference.TUnit
            | TBool _range -> ProgramTypes.TypeReference.TBool
            | TInt8 _range -> ProgramTypes.TypeReference.TInt8
            | TUInt8 _range -> ProgramTypes.TypeReference.TUInt8
            | TInt16 _range -> ProgramTypes.TypeReference.TInt16
            | TUInt16 _range -> ProgramTypes.TypeReference.TUInt16
            | TInt32 _range -> ProgramTypes.TypeReference.TInt32
            | TUInt32 _range -> ProgramTypes.TypeReference.TUInt32
            | TInt64 _range -> ProgramTypes.TypeReference.TInt64
            | TUInt64 _range -> ProgramTypes.TypeReference.TUInt64
            | TInt128 _range -> ProgramTypes.TypeReference.TInt128
            | TUInt128 _range -> ProgramTypes.TypeReference.TUInt128
            | TFloat _range -> ProgramTypes.TypeReference.TFloat
            | TChar _range -> ProgramTypes.TypeReference.TChar
            | TString _range -> ProgramTypes.TypeReference.TString
            | TDateTime _range -> ProgramTypes.TypeReference.TDateTime
            | TUuid _range -> ProgramTypes.TypeReference.TUuid

            | TList(_range, _, _, typ, _) ->
              let typ = TypeReference.toPT onMissing pm owner currentModule typ
              ProgramTypes.TypeReference.TList(typ)

            | TDict(_range, _, _, valueType, _) ->
              let valueType =
                TypeReference.toPT onMissing pm owner currentModule valueType

              ProgramTypes.TypeReference.TDict valueType

            | TTuple(_range, firstType, _, secondType, restTypes, _, _) ->
              let firstType =
                TypeReference.toPT onMissing pm owner currentModule firstType

              let secondType =
                TypeReference.toPT onMissing pm owner currentModule secondType

              let restTypes =
                Stdlib.List.map restTypes (fun (_, t) ->
                  TypeReference.toPT onMissing pm owner currentModule t)

              ProgramTypes.TypeReference.TTuple(firstType, secondType, restTypes)

            | TFn(_range, args, returnType) ->
              let args =
                Stdlib.List.map args (fun (t, _) ->
                  TypeReference.toPT onMissing pm owner currentModule t)

              let returnType =
                TypeReference.toPT onMissing pm owner currentModule returnType

              ProgramTypes.TypeReference.TFn(args, returnType)

            | TDB(_range, _, _, typ, _) ->
              let typ = TypeReference.toPT onMissing pm owner currentModule typ
              ProgramTypes.TypeReference.TDB typ

            | TVariable(_range, _, (_, name)) ->
              ProgramTypes.TypeReference.TVariable name

        let toPT
          (onMissing: NameResolver.OnMissing)
          (pm: ProgramTypes.PackageManager.PackageManager)
          (owner: String)
          (currentModule: List<String>)
          (t: WrittenTypes.TypeReference.TypeReference)
          : ProgramTypes.TypeReference =
          match t with
          | Builtin b -> Builtin.toPT onMissing pm owner currentModule b
          | QualifiedName qn ->
            let (typeName, typeArgs) =
              Identifiers.QualifiedType.toPT onMissing pm owner currentModule qn

            ProgramTypes.TypeReference.TCustomType(typeName, typeArgs)


      module InfixFnName =
        let toPT (infix: WrittenTypes.InfixFnName) : ProgramTypes.InfixFnName =
          match infix with
          | ArithmeticPlus -> ProgramTypes.InfixFnName.ArithmeticPlus
          | ArithmeticMinus -> ProgramTypes.InfixFnName.ArithmeticMinus
          | ArithmeticMultiply -> ProgramTypes.InfixFnName.ArithmeticMultiply
          | ArithmeticDivide -> ProgramTypes.InfixFnName.ArithmeticDivide
          | ArithmeticModulo -> ProgramTypes.InfixFnName.ArithmeticModulo
          | ArithmeticPower -> ProgramTypes.InfixFnName.ArithmeticPower
          | ComparisonGreaterThan -> ProgramTypes.InfixFnName.ComparisonGreaterThan
          | ComparisonGreaterThanOrEqual ->
            ProgramTypes.InfixFnName.ComparisonGreaterThanOrEqual
          | ComparisonLessThan -> ProgramTypes.InfixFnName.ComparisonLessThan
          | ComparisonLessThanOrEqual ->
            ProgramTypes.InfixFnName.ComparisonLessThanOrEqual
          | ComparisonEquals -> ProgramTypes.InfixFnName.ComparisonEquals
          | ComparisonNotEquals -> ProgramTypes.InfixFnName.ComparisonNotEquals
          | StringConcat -> ProgramTypes.InfixFnName.StringConcat

      module BinaryOperation =
        let toPT
          (binop: WrittenTypes.BinaryOperation)
          : ProgramTypes.BinaryOperation =
          match binop with
          | BinOpAnd -> ProgramTypes.BinaryOperation.BinOpAnd
          | BinOpOr -> ProgramTypes.BinaryOperation.BinOpOr

      module Infix =
        let toPT (infix: WrittenTypes.Infix) : ProgramTypes.Infix =
          match infix with
          | InfixFnCall op -> ProgramTypes.Infix.InfixFnCall(InfixFnName.toPT op)
          | BinOp op -> ProgramTypes.Infix.BinOp(BinaryOperation.toPT op)


      module Expr =
        module LetPattern =
          let toPT (p: WrittenTypes.LetPattern) : ProgramTypes.LetPattern =
            match p with
            | LPUnit _ -> ProgramTypes.LetPattern.LPUnit(gid ())
            | LPVariable(_, name) -> ProgramTypes.LetPattern.LPVariable(gid (), name)
            | LPTuple(_, first, _, second, rest, _, _) ->
              let first = toPT first
              let second = toPT second
              let rest = Stdlib.List.map rest (fun (_, p) -> toPT p)

              ProgramTypes.LetPattern.LPTuple(gid (), first, second, rest)

        module MatchPattern =
          let toPT
            (onMissing: NameResolver.OnMissing)
            (p: WrittenTypes.MatchPattern)
            : ProgramTypes.MatchPattern =
            match p with
            | MPUnit _ -> ProgramTypes.MatchPattern.MPUnit(gid ())
            | MPBool(_, b) -> ProgramTypes.MatchPattern.MPBool(gid (), b)
            | MPInt8(_, (_, i), _) -> ProgramTypes.MatchPattern.MPInt8(gid (), i)
            | MPUInt8(_, (_, i), _) -> ProgramTypes.MatchPattern.MPUInt8(gid (), i)
            | MPInt16(_, (_, i), _) -> ProgramTypes.MatchPattern.MPInt16(gid (), i)
            | MPUInt16(_, (_, i), _) -> ProgramTypes.MatchPattern.MPUInt16(gid (), i)
            | MPInt32(_, (_, i), _) -> ProgramTypes.MatchPattern.MPInt32(gid (), i)
            | MPUInt32(_, (_, i), _) -> ProgramTypes.MatchPattern.MPUInt32(gid (), i)
            | MPInt64(_, (_, i), _) -> ProgramTypes.MatchPattern.MPInt64(gid (), i)
            | MPUInt64(_, (_, i), _) -> ProgramTypes.MatchPattern.MPUInt64(gid (), i)
            | MPInt128(_, (_, i), _) -> ProgramTypes.MatchPattern.MPInt128(gid (), i)
            | MPUInt128(_, (_, i), _) ->
              ProgramTypes.MatchPattern.MPUInt128(gid (), i)
            | MPFloat(_, s, w, f) ->
              ProgramTypes.MatchPattern.MPFloat(gid (), s, w, f)
            | MPString(_, contents, _, _) ->
              match contents with
              | None -> ProgramTypes.MatchPattern.MPString(gid (), "")
              | Some((_, s)) -> ProgramTypes.MatchPattern.MPString(gid (), s)
            | MPChar(_, c, _, _) ->
              match c with
              | None -> ProgramTypes.MatchPattern.MPChar(gid (), "")
              | Some((_, c)) -> ProgramTypes.MatchPattern.MPChar(gid (), c)

            | MPList(_, contents, _, _) ->
              ProgramTypes.MatchPattern.MPList(
                gid (),
                Stdlib.List.map contents (fun (p, _) -> toPT onMissing p)
              )
            | MPListCons(_, head, tail, _) ->
              ProgramTypes.MatchPattern.MPListCons(
                gid (),
                toPT onMissing head,
                toPT onMissing tail
              )
            | MPTuple(_, first, _, second, rest, _, _) ->
              ProgramTypes.MatchPattern.MPTuple(
                gid (),
                toPT onMissing first,
                toPT onMissing second,
                Stdlib.List.map rest (fun (_, p) -> toPT onMissing p)
              )
            | MPEnum(_, caseName, fields) ->
              let caseName = caseName |> Stdlib.Tuple2.second
              let fields = Stdlib.List.map fields (fun p -> toPT onMissing p)

              ProgramTypes.MatchPattern.MPEnum(gid (), caseName, fields)

            | MPVariable(_, name) ->
              ProgramTypes.MatchPattern.MPVariable(gid (), name)

        module PipeExpr =
          let toPT
            (onMissing: NameResolver.OnMissing)
            (pm: ProgramTypes.PackageManager.PackageManager)
            (owner: String)
            (currentModule: List<String>)
            (pipeExpr: WrittenTypes.PipeExpr)
            : ProgramTypes.PipeExpr =
            match pipeExpr with
            | EPipeInfix(_, (_, infix), right) ->
              let right = Expr.toPT onMissing pm owner currentModule right

              ProgramTypes.PipeExpr.EPipeInfix(gid (), Infix.toPT infix, right)

            | EPipeLambda(_, pats, body, _, _) ->
              let body = Expr.toPT onMissing pm owner currentModule body
              let pats = Stdlib.List.map pats (fun p -> LetPattern.toPT p)

              ProgramTypes.PipeExpr.EPipeLambda(gid (), pats, body)

            | EPipeEnum(_, (sr, typeName), (_, caseName), fields, _) ->

              let typeName =
                NameResolver.TypeName.resolve
                  onMissing
                  pm
                  owner
                  currentModule
                  (WrittenTypes.Name.Unresolved sr typeName)

              let fields =
                Stdlib.List.map fields (fun e ->
                  Expr.toPT onMissing pm owner currentModule e)

              ProgramTypes.PipeExpr.EPipeEnum(gid (), typeName, caseName, fields)

            // TODO: rename to EPipeVariableOrFnCall
            | EPipeFnCall(_, fnName, typeArgs, args) ->
              let (range, name) =
                match fnName with
                | Unresolved(range, fnName) -> (range, fnName)

              let resolved =
                NameResolver.FnName.resolve
                  onMissing
                  pm
                  owner
                  currentModule
                  (WrittenTypes.Name.Unresolved(range, name))

              let typeArgs =
                Stdlib.List.map typeArgs (fun t ->
                  TypeReference.toPT onMissing pm owner currentModule t)

              let args =
                Stdlib.List.map args (fun a ->
                  Expr.toPT onMissing pm owner currentModule a)

              match resolved with
              | Ok _ ->
                ProgramTypes.PipeExpr.EPipeFnCall(gid (), resolved, typeArgs, args)
              | Error _ ->
                let name = name |> Stdlib.List.last |> Builtin.unwrap
                ProgramTypes.PipeExpr.EPipeVariable(gid (), name, args)


        let toPT
          (onMissing: NameResolver.OnMissing)
          (pm: ProgramTypes.PackageManager.PackageManager)
          (owner: String)
          (currentModule: List<String>)
          (e: WrittenTypes.Expr)
          : ProgramTypes.Expr =
          match e with
          // simple
          | EUnit _ -> ProgramTypes.Expr.EUnit(gid ())

          | EBool(_, b) -> ProgramTypes.Expr.EBool(gid (), b)
          | EInt8(_, (_, i), _) -> ProgramTypes.Expr.EInt8(gid (), i)
          | EUInt8(_, (_, i), _) -> ProgramTypes.Expr.EUInt8(gid (), i)
          | EInt16(_, (_, i), _) -> ProgramTypes.Expr.EInt16(gid (), i)
          | EUInt16(_, (_, i), _) -> ProgramTypes.Expr.EUInt16(gid (), i)
          | EInt32(_, (_, i), _) -> ProgramTypes.Expr.EInt32(gid (), i)
          | EUInt32(_, (_, i), _) -> ProgramTypes.Expr.EUInt32(gid (), i)
          | EInt64(_, (_, i), _) -> ProgramTypes.Expr.EInt64(gid (), i)
          | EUInt64(_, (_, i), _) -> ProgramTypes.Expr.EUInt64(gid (), i)
          | EInt128(_, (_, i), _) -> ProgramTypes.Expr.EInt128(gid (), i)
          | EUInt128(_, (_, i), _) -> ProgramTypes.Expr.EUInt128(gid (), i)
          | EFloat(_, s, w, f) -> ProgramTypes.Expr.EFloat(gid (), s, w, f)
          | EString(_, _, contents, _, _) ->
            let segment =
              contents
              |> Stdlib.List.map (fun s ->
                match s with
                | StringText(_, s) -> ProgramTypes.StringSegment.StringText s
                | StringInterpolation(_, expr, _, _) ->
                  ProgramTypes.StringSegment.StringInterpolation(
                    Expr.toPT onMissing pm owner currentModule expr
                  ))

            ProgramTypes.Expr.EString(gid (), segment)

          | EChar(_, c, _, _) ->
            match c with
            | None -> ProgramTypes.Expr.EChar(gid (), "")
            | Some((_, c)) -> ProgramTypes.Expr.EChar(gid (), c)

          | EList(_, contents, _, _) ->
            ProgramTypes.Expr.EList(
              gid (),
              Stdlib.List.map contents (fun (expr, _) ->
                toPT onMissing pm owner currentModule expr)
            )

          | EDict(_, contents, _, _, _) ->
            ProgramTypes.Expr.EDict(
              gid (),
              Stdlib.List.map contents (fun (_, k, v) ->
                let (_, k) = k
                (k, toPT onMissing pm owner currentModule v))
            )

          | ETuple(_, first, _, second, rest, _, _) ->
            let first = toPT onMissing pm owner currentModule first
            let second = toPT onMissing pm owner currentModule second

            let rest =
              Stdlib.List.map rest (fun (_, e) ->
                toPT onMissing pm owner currentModule e)

            ProgramTypes.Expr.ETuple(gid (), first, second, rest)

          | ERecord(_, typeName, fields, _, _) ->
            let typeName =
              NameResolver.TypeName.resolve onMissing pm owner currentModule typeName

            let fields =
              Stdlib.List.map fields (fun (_, name, typeName) ->
                let fieldName = name |> Stdlib.Tuple2.second
                (fieldName, toPT onMissing pm owner currentModule typeName))

            ProgramTypes.Expr.ERecord(gid (), typeName, fields)

          | ERecordUpdate(_, record, updates, _, _, _) ->
            let record = toPT onMissing pm owner currentModule record

            let updates =
              updates
              |> Stdlib.List.map (fun (name, _, expr) ->
                let name = name |> Stdlib.Tuple2.second
                (name, toPT onMissing pm owner currentModule expr))

            ProgramTypes.Expr.ERecordUpdate(gid (), record, updates)

          | EEnum(_, (sr, typeName), (_, caseName), fields, _) ->
            let typeName =
              NameResolver.TypeName.resolve
                onMissing
                pm
                owner
                currentModule
                (WrittenTypes.Name.Unresolved sr typeName)

            let fields =
              Stdlib.List.map fields (fun expr ->
                toPT onMissing pm owner currentModule expr)

            ProgramTypes.Expr.EEnum(gid (), typeName, caseName, fields)

          // declaring and accessing variables
          | ELet(_, pat, rhs, body, _, _) ->
            ProgramTypes.Expr.ELet(
              gid (),
              LetPattern.toPT pat,
              toPT onMissing pm owner currentModule rhs,
              toPT onMissing pm owner currentModule body
            )

          | EVariable(range, var) ->
            let unresolved = WrittenTypes.Name.Unresolved(range, [ var ])

            let constant =
              NameResolver.ConstantName.resolve
                onMissing
                pm
                owner
                currentModule
                unresolved

            match constant with
            | Ok _ -> ProgramTypes.Expr.EConstant(gid (), constant)
            | Error _ -> ProgramTypes.Expr.EVariable (gid ()) var

          | EConstantOrFn(_, id) ->
            let constantOrFn =
              Identifiers.QualifiedConstOrFn.toPT onMissing pm owner currentModule id

            match constantOrFn with
            | Ok(Const c) -> ProgramTypes.Expr.EConstant(gid (), c)
            | Ok(Fn f) -> ProgramTypes.Expr.EFnName(gid (), f)
            | Error _ ->
              // CLEANUP: Rethink this solution. It was added to allow failure during the first pass of parsing, where names aren't yet resolved
              ProgramTypes.Expr.EVariable (gid ()) id.constantOrFn.name

          | EFieldAccess(_, expr, (_, fieldName), _) ->
            ProgramTypes.Expr.EFieldAccess(
              gid (),
              toPT onMissing pm owner currentModule expr,
              fieldName
            )

          | EIf(_, cond, thenExpr, elseExpr, _, _, _) ->
            let elseExpr =
              elseExpr
              |> Stdlib.Option.map (fun es ->
                Expr.toPT onMissing pm owner currentModule es)

            ProgramTypes.Expr.EIf(
              gid (),
              toPT onMissing pm owner currentModule cond,
              toPT onMissing pm owner currentModule thenExpr,
              elseExpr
            )

          | EMatch(_, expr, cases, _, _) ->
            let cases =
              Stdlib.List.map cases (fun case ->
                let pat =
                  MatchPattern.toPT onMissing (Stdlib.Tuple3.second case.pat)

                let whenCondition =
                  case.whenCondition
                  |> Stdlib.Option.map (fun (_, e) ->
                    toPT onMissing pm owner currentModule e)

                let rhs = toPT onMissing pm owner currentModule case.rhs

                ProgramTypes.MatchCase
                  { pat = pat
                    whenCondition = whenCondition
                    rhs = rhs })

            ProgramTypes.Expr.EMatch(
              gid (),
              toPT onMissing pm owner currentModule expr,
              cases
            )

          | EPipe(_, expr, pipeExpr) ->
            let pipeExpr =
              pipeExpr
              |> Stdlib.List.map (fun (_, e) ->
                PipeExpr.toPT onMissing pm owner currentModule e)

            ProgramTypes.Expr.EPipe(
              gid (),
              toPT onMissing pm owner currentModule expr,
              pipeExpr
            )

          // fn calls
          | EInfix(_, (_, op), left, right) ->
            let infix = Infix.toPT op

            ProgramTypes.Expr.EInfix(
              gid (),
              infix,
              toPT onMissing pm owner currentModule left,
              toPT onMissing pm owner currentModule right
            )

          | ELambda(_, pats, body, _, _) ->
            let pats = Stdlib.List.map pats (fun p -> LetPattern.toPT p)
            let body = Expr.toPT onMissing pm owner currentModule body

            ProgramTypes.Expr.ELambda(gid (), pats, body)

          | EFnName(_, fnName) ->
            let fnName =
              Identifiers.QualifiedFn.toPT onMissing pm owner currentModule fnName

            ProgramTypes.Expr.EFnName(gid (), fnName)

          | EApply(_, fn, typeArgs, args) ->
            let fn = toPT onMissing pm owner currentModule fn

            let typeArgs =
              Stdlib.List.map typeArgs (fun t ->
                TypeReference.toPT onMissing pm owner currentModule t)

            let args =
              Stdlib.List.map args (fun a -> toPT onMissing pm owner currentModule a)

            ProgramTypes.Expr.EApply(gid (), fn, typeArgs, args)


      module Const =
        let toPT
          (onMissing: NameResolver.OnMissing)
          (pm: ProgramTypes.PackageManager.PackageManager)
          (owner: String)
          (currentModule: List<String>)
          (c: WrittenTypes.Const)
          : ProgramTypes.Const =
          match c with
          | CUnit _ -> ProgramTypes.Const.CUnit
          | CBool(_, b) -> ProgramTypes.Const.CBool(b)
          | CInt8(_, (_, i), _) -> ProgramTypes.Const.CInt8(i)
          | CUInt8(_, (_, i), _) -> ProgramTypes.Const.CUInt8(i)
          | CInt16(_, (_, i), _) -> ProgramTypes.Const.CInt16(i)
          | CUInt16(_, (_, i), _) -> ProgramTypes.Const.CUInt16(i)
          | CInt32(_, (_, i), _) -> ProgramTypes.Const.CInt32(i)
          | CUInt32(_, (_, i), _) -> ProgramTypes.Const.CUInt32(i)
          | CInt64(_, (_, i), _) -> ProgramTypes.Const.CInt64(i)
          | CUInt64(_, (_, i), _) -> ProgramTypes.Const.CUInt64(i)
          | CInt128(_, (_, i), _) -> ProgramTypes.Const.CInt128(i)
          | CUInt128(_, (_, i), _) -> ProgramTypes.Const.CUInt128(i)
          | CFloat(_, s, w, f) -> ProgramTypes.Const.CFloat(s, w, f)
          | CString(_, contents, _, _) ->
            match contents with
            | None -> ProgramTypes.Const.CString([])
            | Some((_, s)) -> ProgramTypes.Const.CString(s)
          | CChar(_, c, _, _) ->
            match c with
            | None -> ProgramTypes.Const.CChar("")
            | Some((_, c)) -> ProgramTypes.Const.CChar(c)

          | CList(_, contents, _, _) ->
            ProgramTypes.Const.CList(
              Stdlib.List.map contents (fun (c, _) ->
                toPT onMissing pm owner currentModule c)
            )

          | CDict(_, contents, _, _, _) ->
            ProgramTypes.Const.CDict(
              Stdlib.List.map contents (fun (_, k, v) ->
                let (_, k) = k
                (k, toPT onMissing pm owner currentModule v))
            )

          | CTuple(_, first, _, second, rest, _, _) ->
            let first = toPT onMissing pm owner currentModule first
            let second = toPT onMissing pm owner currentModule second

            let rest =
              Stdlib.List.map rest (fun (_, c) ->
                toPT onMissing pm owner currentModule c)

            ProgramTypes.Const.CTuple(first, second, rest)

          | CEnum(_, (sr, typeName), (_, caseName), fields, _) ->
            let typeName =
              NameResolver.TypeName.resolve
                onMissing
                pm
                owner
                currentModule
                (WrittenTypes.Name.Unresolved sr typeName)

            let fields =
              Stdlib.List.map fields (fun c ->
                toPT onMissing pm owner currentModule c)

            ProgramTypes.Const.CEnum(typeName, caseName, fields)


      module ModuleDeclaration =
        let combineSubmodules
          (submodules: List<ProgramTypes.Definitions>)
          : ProgramTypes.Definitions =
          let init =
            ProgramTypes.Definitions
              { types = []
                constants = []
                fns = []
                exprs = [] }

          submodules
          |> Stdlib.List.fold init (fun acc m ->
            ProgramTypes.Definitions
              { types = acc.types |> Stdlib.List.append m.types
                constants = acc.constants |> Stdlib.List.append m.constants
                fns = acc.fns |> Stdlib.List.append m.fns
                exprs = acc.exprs |> Stdlib.List.append m.exprs })

        let submoduleToPT
          (onMissing: NameResolver.OnMissing)
          (pm: ProgramTypes.PackageManager.PackageManager)
          (owner: String)
          (modules: List<String>)
          (submodule: WrittenTypes.ModuleDeclaration.ModuleDeclaration)
          : ProgramTypes.Definitions =
          let (_, m) = submodule.name
          let modules = Stdlib.List.append modules [ m ]

          let types =
            submodule.declarations
            |> Stdlib.List.filterMap (fun d ->
              match d with
              | Type t ->
                Stdlib.Option.Option.Some(
                  TypeDeclaration.toPackageTypePT onMissing pm owner modules t
                )
              | _ -> Stdlib.Option.Option.None)

          let fns =
            submodule.declarations
            |> Stdlib.List.filterMap (fun d ->
              match d with
              | Function f ->
                Stdlib.Option.Option.Some(
                  FunctionDeclaration.toPackageFnPT onMissing pm owner modules f
                )
              | _ -> Stdlib.Option.Option.None)

          let constants =
            submodule.declarations
            |> Stdlib.List.filterMap (fun d ->
              match d with
              | Constant c ->
                Stdlib.Option.Option.Some(
                  ConstantDeclaration.toPackageConstPT onMissing pm owner modules c
                )
              | _ -> Stdlib.Option.Option.None)

          let exprs =
            submodule.declarations
            |> Stdlib.List.filterMap (fun d ->
              match d with
              | Expr e ->
                let expr = Expr.toPT onMissing pm owner modules e
                let modules = Stdlib.List.push modules owner
                Stdlib.Option.Option.Some((expr, modules))
              | _ -> Stdlib.Option.Option.None)

          let submodules =
            submodule.declarations
            |> Stdlib.List.filterMap (fun d ->
              match d with
              | SubModule m ->
                Stdlib.Option.Option.Some(
                  submoduleToPT onMissing pm owner modules m
                )
              | _ -> Stdlib.Option.Option.None)

          let submodules = combineSubmodules submodules

          ProgramTypes.Definitions
            { types = types |> Stdlib.List.append submodules.types
              constants = constants |> Stdlib.List.append submodules.constants
              fns = fns |> Stdlib.List.append submodules.fns
              exprs = exprs |> Stdlib.List.append submodules.exprs }


        let toPT
          (onMissing: NameResolver.OnMissing)
          (pm: ProgramTypes.PackageManager.PackageManager)
          (currentModule: List<String>)
          (d: WrittenTypes.ModuleDeclaration.ModuleDeclaration)
          : ProgramTypes.Definitions =
          let (_, owner) = d.name

          let types =
            d.declarations
            |> Stdlib.List.filterMap (fun d ->
              match d with
              | Type t ->
                Stdlib.Option.Option.Some(
                  TypeDeclaration.toPackageTypePT onMissing pm owner currentModule t
                )
              | _ -> Stdlib.Option.Option.None)

          let fns =
            d.declarations
            |> Stdlib.List.filterMap (fun d ->
              match d with
              | Function f ->
                Stdlib.Option.Option.Some(
                  FunctionDeclaration.toPackageFnPT
                    onMissing
                    pm
                    owner
                    currentModule
                    f
                )
              | _ -> Stdlib.Option.Option.None)

          let constants =
            d.declarations
            |> Stdlib.List.filterMap (fun d ->
              match d with
              | Constant c ->
                Stdlib.Option.Option.Some(
                  ConstantDeclaration.toPackageConstPT
                    onMissing
                    pm
                    owner
                    currentModule
                    c
                )
              | _ -> Stdlib.Option.Option.None)

          let init =
            ProgramTypes.Definitions
              { types = []
                constants = []
                fns = []
                exprs = [] }

          let submodules =
            d.declarations
            |> Stdlib.List.filterMap (fun d ->
              match d with
              | SubModule m ->
                Stdlib.Option.Option.Some(
                  submoduleToPT onMissing pm owner currentModule m
                )
              | _ -> Stdlib.Option.Option.Some init)

          let submodules = ModuleDeclaration.combineSubmodules submodules

          let exprs =
            d.declarations
            |> Stdlib.List.filterMap (fun d ->
              match d with
              | Expr e ->
                let expr = Expr.toPT onMissing pm owner currentModule e
                Stdlib.Option.Option.Some((expr, [ owner ]))
              | _ -> Stdlib.Option.Option.None)

          ProgramTypes.Definitions
            { types = types |> Stdlib.List.append submodules.types
              constants = constants |> Stdlib.List.append submodules.constants
              fns = fns |> Stdlib.List.append submodules.fns
              exprs = exprs |> Stdlib.List.append submodules.exprs }


      module TypeDeclaration =
        module RecordField =
          let toPT
            (onMissing: NameResolver.OnMissing)
            (pm: ProgramTypes.PackageManager.PackageManager)
            (currentModule: List<String>)
            (f: WrittenTypes.TypeDeclaration.RecordField)
            : ProgramTypes.TypeDeclaration.RecordField =
            let (_, name) = f.name

            ProgramTypes.TypeDeclaration.RecordField
              { name = name
                typ = TypeReference.toPT onMissing pm owner currentModule f.typ
                description = "" }

        module EnumField =
          let toPT
            (onMissing: NameResolver.OnMissing)
            (pm: ProgramTypes.PackageManager.PackageManager)
            (currentModule: List<String>)
            (f: WrittenTypes.TypeDeclaration.EnumField)
            : ProgramTypes.TypeDeclaration.EnumField =
            let label = f.label |> Stdlib.Option.map Stdlib.Tuple2.second

            ProgramTypes.TypeDeclaration.EnumField
              { typ = TypeReference.toPT onMissing pm owner currentModule f.typ
                label = label
                description = "" }

        module EnumCase =
          let toPT
            (onMissing: NameResolver.OnMissing)
            (pm: ProgramTypes.PackageManager.PackageManager)
            (currentModule: List<String>)
            (c: WrittenTypes.TypeDeclaration.EnumCase)
            : ProgramTypes.TypeDeclaration.EnumCase =
            let (_, name) = c.name

            let fields =
              Stdlib.List.map c.fields (fun f ->
                EnumField.toPT onMissing pm currentModule f)

            ProgramTypes.TypeDeclaration.EnumCase
              { name = name
                fields = fields
                description = "" }

        module Definition =
          let toPT
            (onMissing: NameResolver.OnMissing)
            (pm: ProgramTypes.PackageManager.PackageManager)
            (owner: String)
            (currentModule: List<String>)
            (d: WrittenTypes.TypeDeclaration.Definition)
            : ProgramTypes.TypeDeclaration.Definition =

            match d with
            | Alias typ ->
              let typ = TypeReference.toPT onMissing pm owner currentModule typ
              ProgramTypes.TypeDeclaration.Definition.Alias typ

            | Record fields ->
              let fields =
                Stdlib.List.map fields (fun (f, _) ->
                  RecordField.toPT onMissing pm currentModule f)

              ProgramTypes.TypeDeclaration.Definition.Record fields

            | Enum cases ->
              let cases =
                Stdlib.List.map cases (fun (_, c) ->
                  EnumCase.toPT onMissing pm currentModule c)

              ProgramTypes.TypeDeclaration.Definition.Enum cases

        let toPT
          (onMissing: NameResolver.OnMissing)
          (pm: ProgramTypes.PackageManager.PackageManager)
          (owner: String)
          (currentModule: List<String>)
          (d: WrittenTypes.TypeDeclaration.TypeDeclaration)
          : ProgramTypes.TypeDeclaration.TypeDeclaration =
          let def = Definition.toPT onMissing pm owner currentModule d.definition

          ProgramTypes.TypeDeclaration.TypeDeclaration
            { typeParams =
                d.typeParams |> Stdlib.List.map (fun p -> p |> Stdlib.Tuple2.second)
              definition = def }


        let toPackageTypePT
          (onMissing: NameResolver.OnMissing)
          (pm: ProgramTypes.PackageManager.PackageManager)
          (owner: String)
          (modules: List<String>)
          (d: WrittenTypes.TypeDeclaration.TypeDeclaration)
          : ProgramTypes.PackageType.PackageType =
          ProgramTypes.PackageType.PackageType
            // TODO: when relevant, use PackageIDs defined in F# land
            { id = Stdlib.Uuid.generate ()
              name =
                ProgramTypes.PackageType.Name
                  { owner = owner
                    modules = modules
                    name = d.name.name }
              description = ""
              declaration = toPT onMissing pm owner modules d
              deprecated = ProgramTypes.Deprecation.NotDeprecated }


      module ConstantDeclaration =
        let toPackageConstPT
          (onMissing: NameResolver.OnMissing)
          (pm: ProgramTypes.PackageManager.PackageManager)
          (owner: String)
          (modules: List<String>)
          (d: WrittenTypes.ConstantDeclaration.ConstantDeclaration)
          : ProgramTypes.PackageConstant.PackageConstant =
          ProgramTypes.PackageConstant.PackageConstant
            { id = Stdlib.Uuid.generate ()
              name =
                ProgramTypes.PackageConstant.Name
                  { owner = owner
                    modules = modules
                    name = d.name.name }
              body = Const.toPT onMissing pm owner modules d.body
              description = ""
              deprecated = ProgramTypes.Deprecation.NotDeprecated }


      module FunctionDeclaration =
        module Parameter =
          let toPackageFnParamPT
            (onMissing: NameResolver.OnMissing)
            (pm: ProgramTypes.PackageManager.PackageManager)
            (owner: String)
            (currentModule: List<String>)
            (p: WrittenTypes.FnDeclaration.Parameter)
            : ProgramTypes.PackageFn.Parameter =

            match p with
            | Unit p ->
              ProgramTypes.PackageFn.Parameter
                { name = "_" // TODO ok?
                  typ = ProgramTypes.TypeReference.TUnit
                  description = "" }

            | Normal p ->
              ProgramTypes.PackageFn.Parameter
                { name = p.name.name
                  typ = TypeReference.toPT onMissing pm owner currentModule p.typ
                  description = "" }

        let toPackageFnPT
          (onMissing: NameResolver.OnMissing)
          (pm: ProgramTypes.PackageManager.PackageManager)
          (owner: String)
          (modules: List<String>)
          (fn: WrittenTypes.FnDeclaration.FnDeclaration)
          : ProgramTypes.PackageFn.PackageFn =
          let typeParams =
            fn.typeParams |> Stdlib.List.map (fun p -> p |> Stdlib.Tuple2.second)

          ProgramTypes.PackageFn.PackageFn
            // TODO: when relevant, use PacakgeIDs defined in F# land
            { id = Stdlib.Uuid.generate ()
              name =
                ProgramTypes.PackageFn.Name
                  { owner = owner
                    modules = modules
                    name = fn.name.name }
              typeParams = typeParams
              parameters =
                fn.parameters
                |> Stdlib.List.map (fun p ->
                  Parameter.toPackageFnParamPT onMissing pm owner modules p)
              returnType =
                TypeReference.toPT onMissing pm owner modules fn.returnType
              description = ""
              deprecated = ProgramTypes.Deprecation.NotDeprecated
              body = Expr.toPT onMissing pm owner modules fn.body }


      let sourceFile
        (source: WrittenTypes.SourceFile.SourceFile)
        : ProgramTypes.SourceFile.SourceFile =
        let pm = PackageManager.pm ()
        // CLEANUP potentially complain about unparsable stuff?
        ProgramTypes.SourceFile.SourceFile
          { declarations =
              source.declarations
              |> Stdlib.List.map (fun decl ->
                match decl with
                | Type t ->
                  ProgramTypes.SourceFile.Declaration.Type(
                    TypeDeclaration.toPackageTypePT
                      NameResolver.OnMissing.Allow
                      pm
                      "Tests"
                      []
                      t
                  )

                | Constant c ->
                  ProgramTypes.SourceFile.Declaration.Constant(
                    ConstantDeclaration.toPackageConstPT
                      NameResolver.OnMissing.Allow
                      pm
                      "Tests"
                      []
                      c
                  )

                | Function f ->
                  ProgramTypes.SourceFile.Declaration.Function(
                    FunctionDeclaration.toPackageFnPT
                      NameResolver.OnMissing.Allow
                      pm
                      "Tests"
                      []
                      f
                  )

                | Module m ->
                  ProgramTypes.SourceFile.Declaration.Module(
                    ModuleDeclaration.toPT NameResolver.OnMissing.Allow pm [] m
                  ))

            exprsToEval =
              source.exprsToEval
              |> Stdlib.List.map (fun e ->
                Expr.toPT NameResolver.OnMissing.Allow pm "" [] e) }


      let parsedFileAsSourceFile
        (parsedFile: WrittenTypes.ParsedFile)
        : ProgramTypes.SourceFile.SourceFile =
        match parsedFile with
        | SourceFile source -> sourceFile source