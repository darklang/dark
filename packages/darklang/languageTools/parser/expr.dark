module Darklang =
  module LanguageTools =
    module Parser =
      module Expr =
        let parseBoolLiteral
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          let b =
            // TODO: error-handling
            match getText node with
            | "true" -> true |> Stdlib.Result.Result.Ok
            | "false" -> false |> Stdlib.Result.Result.Ok
            | _ -> createUnparseableError node

          match b with
          | Ok b ->
            (WrittenTypes.Expr.EBool(node.range, b)) |> Stdlib.Result.Result.Ok
          | Error _ -> createUnparseableError node


        // Helper function for parseIntLiteral
        let parseIntByType
          (intText: String)
          (typ: String)
          : Stdlib.Result.Result<_res, _err> =
          match typ with
          | "int8_literal" -> Stdlib.Int8.parse intText
          | "uint8_literal" -> Stdlib.UInt8.parse intText
          | "int16_literal" -> Stdlib.Int16.parse intText
          | "uint16_literal" -> Stdlib.UInt16.parse intText
          | "int32_literal" -> Stdlib.Int32.parse intText
          | "uint32_literal" -> Stdlib.UInt32.parse intText
          | "int64_literal" -> Stdlib.Int64.parse intText
          | "uint64_literal" -> Stdlib.UInt64.parse intText
          | "int128_literal" -> Stdlib.Int128.parse intText
          | "uint128_literal" -> Stdlib.UInt128.parse intText
          | _ -> Stdlib.Result.Result.Error $"Unsupported integer type: {typ}"

        let parseIntLiteral
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          let supportedInts =
            [ "int8_literal"
              "uint8_literal"
              "int16_literal"
              "uint16_literal"
              "int32_literal"
              "uint32_literal"
              "int64_literal"
              "uint64_literal"
              "int128_literal"
              "uint128_literal" ]

          if (Stdlib.List.member_v0 supportedInts node.typ) then
            let intPart = findField node "digits"
            let suffixPart = findField node "suffix"

            match intPart, suffixPart with
            | Ok intPart, Ok sfx ->
              let intText = getText intPart

              match parseIntByType intText node.typ with
              | Ok parsedValue ->
                let intPart = (intPart.range, parsedValue)

                let expr =
                  match node.typ with
                  | "int8_literal" ->
                    WrittenTypes.Expr.EInt8(node.range, intPart, sfx.range)
                  | "uint8_literal" ->
                    WrittenTypes.Expr.EUInt8(node.range, intPart, sfx.range)
                  | "int16_literal" ->
                    WrittenTypes.Expr.EInt16(node.range, intPart, sfx.range)
                  | "uint16_literal" ->
                    WrittenTypes.Expr.EUInt16(node.range, intPart, sfx.range)
                  | "int32_literal" ->
                    WrittenTypes.Expr.EInt32(node.range, intPart, sfx.range)
                  | "uint32_literal" ->
                    WrittenTypes.Expr.EUInt32(node.range, intPart, sfx.range)
                  | "int64_literal" ->
                    WrittenTypes.Expr.EInt64(node.range, intPart, sfx.range)
                  | "uint64_literal" ->
                    WrittenTypes.Expr.EUInt64(node.range, intPart, sfx.range)
                  | "int128_literal" ->
                    WrittenTypes.Expr.EInt128(node.range, intPart, sfx.range)
                  | "uint128_literal" ->
                    WrittenTypes.Expr.EUInt128(node.range, intPart, sfx.range)
                  | _ -> createUnparseableError node

                expr |> Stdlib.Result.Result.Ok

              | Error _ -> createUnparseableError node

          else
            createUnparseableError node


        let parseFloatLiteral
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          let floatStr = getText node

          match Stdlib.Float.parse floatStr with
          | Ok floatValue ->
            let (sign, whole, remainder) =
              let (sign, unsignedFloat) =
                if Stdlib.String.startsWith floatStr "-" then
                  (Sign.Negative, Stdlib.String.dropFirst floatStr 1L)
                else
                  (Sign.Positive, floatStr)

              let parts = Stdlib.String.split unsignedFloat "."

              let whole = parts |> Stdlib.List.head |> Stdlib.Option.withDefault "0"

              let remainder =
                parts
                |> Stdlib.List.tail
                |> Stdlib.Option.withDefault [ "0" ]
                |> Stdlib.List.head
                |> Stdlib.Option.withDefault "0"

              (sign, whole, remainder)

            (WrittenTypes.Expr.EFloat(node.range, sign, whole, remainder))
            |> Stdlib.Result.Result.Ok

          | Error _ -> createUnparseableError node


        let parseStringLiteral
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          let openQuoteNode = findField node "symbol_open_quote"
          let closeQuoteNode = findField node "symbol_close_quote"

          let contents =
            findAndParseOptional node "content" (fun stringPart ->
              (stringPart.range, stringPart.text) |> Stdlib.Result.Result.Ok)

          match openQuoteNode, closeQuoteNode with
          | Ok openQuote, Ok closeQuote ->
            (WrittenTypes.Expr.EString(
              node.range,
              contents,
              openQuote.range,
              closeQuote.range
            ))
            |> Stdlib.Result.Result.Ok

          | _ -> createUnparseableError node


        let parseCharLiteral
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          let openQuoteNode = findField node "symbol_open_single_quote"

          let charNode =
            findAndParseOptional node "content" (fun charPart ->
              (charPart.range, charPart.text) |> Stdlib.Result.Result.Ok)

          let closeQuoteNode = findField node "symbol_close_single_quote"

          match openQuoteNode, closeQuoteNode with
          | Ok openQuote, Ok closeQuote ->
            (WrittenTypes.Expr.EChar(
              node.range,
              charNode,
              openQuote.range,
              closeQuote.range
            ))
            |> Stdlib.Result.Result.Ok

          | _ -> createUnparseableError node


        let parseListLiteral
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          let openBracketNode = findField node "symbol_open_bracket"
          let closeBracketNode = findField node "symbol_close_bracket"

          let listContents =
            node
            |> findNodeByFieldName "content"
            |> Stdlib.Option.map (fun contentsNode ->
              contentsNode.children
              |> Stdlib.List.chunkBySize 2L
              |> Builtin.unwrap
              |> Stdlib.List.map (fun exprSymbolPair ->
                match exprSymbolPair with
                | [ exprNode; symbol ] ->
                  match Expr.parse exprNode with
                  | Ok e ->
                    (e, Stdlib.Option.Option.Some symbol.range)
                    |> Stdlib.Result.Result.Ok
                  | Error _ -> createUnparseableError contentsNode

                | [ exprNode ] ->
                  match Expr.parse exprNode with
                  | Ok e ->
                    (e, Stdlib.Option.Option.None) |> Stdlib.Result.Result.Ok
                  | Error _ -> createUnparseableError exprNode

                | _ -> createUnparseableError contentsNode)

              |> Stdlib.Result.collect)

            |> Stdlib.Option.withDefault (Stdlib.Result.Result.Ok [])

          match openBracketNode, listContents, closeBracketNode with
          | Ok openBracket, Ok listContents, Ok closeBracket ->
            (WrittenTypes.Expr.EList(
              node.range,
              listContents,
              openBracket.range,
              closeBracket.range
            ))
            |> Stdlib.Result.Result.Ok

          | _ -> createUnparseableError node


        let parseDictLiteral
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          let keywordDictNode = findField node "keyword_dict"
          let openBraceNode = findField node "symbol_open_brace"

          let dictContents =
            node
            |> findNodeByFieldName "content"
            |> Stdlib.Option.map (fun contentsNode ->
              contentsNode.children
              |> Stdlib.List.chunkBySize 2L
              |> Builtin.unwrap
              |> Stdlib.List.map (fun dictSeparatorPair ->
                match dictSeparatorPair with
                | [ dictPairNode; _separator ] ->
                  let keyNode =
                    findAndParseRequired dictPairNode "key" (fun node ->
                      (Parser.getText node) |> Stdlib.Result.Result.Ok)

                  let symbolEqualsNode = findField dictPairNode "symbol_equals"

                  let valueNode =
                    findAndParseRequired dictPairNode "value" Expr.parse

                  match (keyNode, symbolEqualsNode, valueNode) with
                  | (Ok key, Ok symbolEquals, Ok value) ->
                    (symbolEquals, key, value) |> Stdlib.Result.Result.Ok
                  | _ -> createUnparseableError dictPairNode

                | [ dictPairNode ] ->
                  let keyNode =
                    findAndParseRequired dictPairNode "key" (fun node ->
                      (Parser.getText node) |> Stdlib.Result.Result.Ok)

                  let symbolEqualsNode = findField dictPairNode "symbol_equals"

                  let valueNode =
                    findAndParseRequired dictPairNode "value" Expr.parse

                  match (keyNode, symbolEqualsNode, valueNode) with
                  | (Ok key, Ok symbolEquals, Ok value) ->
                    (symbolEquals, key, value) |> Stdlib.Result.Result.Ok
                  | _ -> createUnparseableError dictPairNode
                | _ -> createUnparseableError contentsNode)

              |> Stdlib.Result.collect)

            |> Stdlib.Option.withDefault (Stdlib.Result.Result.Ok [])

          let closeBraceNode = findField node "symbol_close_brace"

          match keywordDictNode, openBraceNode, dictContents, closeBraceNode with
          | Ok keywordDict, Ok openBrace, Ok dictContents, Ok closeBrace ->
            (WrittenTypes.Expr.EDict(
              node.range,
              dictContents,
              keywordDict.range,
              openBrace.range,
              closeBrace.range
            ))
            |> Stdlib.Result.Result.Ok

          | _ -> createUnparseableError node


        let parseTupleLiteral
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          let openParenNode = findField node "symbol_left_paren"
          let first = findAndParseRequired node "first" Expr.parse
          let second = findAndParseRequired node "second" Expr.parse

          let rest =
            (findNodeByFieldName node "rest")
            |> Stdlib.Option.map (fun restNode ->
              restNode.children
              |> Stdlib.List.chunkBySize 2L
              |> Builtin.unwrap
              |> Stdlib.List.map (fun symbolExprPair ->
                match symbolExprPair with
                | [ symbol; exprNode ] ->
                  match Expr.parse exprNode with
                  | Ok expr -> (symbol.range, expr) |> Stdlib.Result.Result.Ok
                  | Error _ -> createUnparseableError exprNode

                | [ exprNode ] ->
                  match Expr.parse exprNode with
                  | Ok expr ->
                    (Stdlib.Option.Option.None, expr) |> Stdlib.Result.Result.Ok
                  | Error _ -> createUnparseableError exprNode
                | _ -> createUnparseableError restNode)

              |> Stdlib.Result.collect)

            |> Stdlib.Option.withDefault (Stdlib.Result.Result.Ok [])

          let commaSymbol = findField node "symbol_comma"
          let closeParenNode = findField node "symbol_right_paren"

          match openParenNode, first, commaSymbol, second, rest, closeParenNode with
          | Ok openParen, Ok first, Ok symComma, Ok second, Ok rest, Ok closeParen ->
            (WrittenTypes.Expr.ETuple(
              node.range,
              first,
              symComma.range,
              second,
              rest,
              openParen.range,
              closeParen.range
            ))
            |> Stdlib.Result.Result.Ok

          | _ -> createUnparseableError node


        let parseRecordLiteral
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          let typeNameNode = findField node "type_name"
          let openBraceNode = findField node "symbol_open_brace"

          let recordContents =
            node
            |> findNodeByFieldName "content"
            |> Stdlib.Option.map (fun contentsNode ->
              contentsNode.children
              |> Stdlib.List.chunkBySize 2L
              |> Builtin.unwrap
              |> Stdlib.List.map (fun recordSeparatorPair ->
                match recordSeparatorPair with
                | [ recordPairNode; _separator ] ->
                  let fieldNode =
                    findAndParseRequired recordPairNode "field" (fun node ->
                      (node.range, node.text) |> Stdlib.Result.Result.Ok)

                  let symbolEqualsNode = findField recordPairNode "symbol_equals"

                  let valueNode =
                    findAndParseRequired recordPairNode "value" Expr.parse

                  match fieldNode, symbolEqualsNode, valueNode with
                  | Ok field, Ok symEquals, Ok value ->
                    (symEquals, field, value) |> Stdlib.Result.Result.Ok
                  | _ -> createUnparseableError recordPairNode

                | [ recordPairNode ] ->
                  let fieldNode =
                    findAndParseRequired recordPairNode "field" (fun node ->
                      (node.range, node.text) |> Stdlib.Result.Result.Ok)

                  let symbolEqualsNode = findField recordPairNode "symbol_equals"

                  let valueNode =
                    findAndParseRequired recordPairNode "value" Expr.parse

                  match fieldNode, symbolEqualsNode, valueNode with
                  | Ok field, Ok symEquals, Ok value ->
                    (symEquals, field, value) |> Stdlib.Result.Result.Ok
                  | _ -> createUnparseableError recordPairNode

                | _ -> createUnparseableError contentsNode)

              |> Stdlib.Result.collect)

            |> Stdlib.Option.withDefault (Stdlib.Result.Result.Ok [])

          let closeBraceNode = findField node "symbol_close_brace"

          match typeNameNode, openBraceNode, recordContents, closeBraceNode with
          | Ok typeName, Ok openBrace, Ok recordContents, Ok closeBrace ->
            let typeNameNode =
              Darklang.LanguageTools.WrittenTypes.Name.Unresolved(
                typeName.range,
                [ typeName.text ]
              )

            (WrittenTypes.Expr.ERecord(
              node.range,
              typeNameNode,
              recordContents,
              openBrace.range,
              closeBrace.range
            ))
            |> Stdlib.Result.Result.Ok

          | _ -> createUnparseableError node


        let parseRecordUpdate
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          let openBrace = findField node "symbol_open_brace"
          let closeBrace = findField node "symbol_close_brace"
          let recordExpr = findAndParseRequired node "record" Expr.parse
          let keywordWith = findField node "keyword_with"

          let fieldUpdates =
            (findNodeByFieldName node "field_updates")
            |> Stdlib.Option.map (fun fieldUpdatesNode ->
              fieldUpdatesNode.children
              |> Stdlib.List.chunkBySize 2L
              |> Builtin.unwrap
              |> Stdlib.List.map (fun fieldSeparatorPair ->
                match fieldSeparatorPair with
                | [ fieldNode; _separator ] ->
                  let fieldNameNode =
                    findAndParseRequired fieldNode "field_name" (fun node ->
                      ((node.range, node.text)) |> Stdlib.Result.Result.Ok)

                  let symbolEqualsNode = findField fieldNode "symbol_equals"

                  let valueNode = findAndParseRequired fieldNode "value" Expr.parse

                  match fieldNameNode, symbolEqualsNode, valueNode with
                  | Ok fieldName, Ok symEquals, Ok value ->
                    ((fieldName, symEquals.range, value))
                    |> Stdlib.Result.Result.Ok
                  | _ -> createUnparseableError fieldNode

                | [ fieldNode ] ->
                  let fieldNameNode =
                    findAndParseRequired fieldNode "field_name" (fun node ->
                      ((node.range, node.text)) |> Stdlib.Result.Result.Ok)

                  let symbolEqualsNode = findField fieldNode "symbol_equals"

                  let valueNode = findAndParseRequired fieldNode "value" Expr.parse

                  match fieldNameNode, symbolEqualsNode, valueNode with
                  | Ok fieldName, Ok symEquals, Ok value ->
                    ((fieldName, symEquals.range, value))
                    |> Stdlib.Result.Result.Ok
                  | _ -> createUnparseableError fieldNode

                | _ -> createUnparseableError fieldUpdatesNode)

              |> Stdlib.Result.collect)

            |> Stdlib.Option.withDefault (
              Stdlib.Result.Result.Error "field_updates not found"
            )

          match openBrace, closeBrace, recordExpr, keywordWith, fieldUpdates with
          | Ok openBrace,
            Ok closeBrace,
            Ok recordExpr,
            Ok keywordWith,
            Ok fieldUpdates ->
            (WrittenTypes.Expr.ERecordUpdate(
              node.range,
              recordExpr,
              fieldUpdates,
              openBrace.range,
              closeBrace.range,
              keywordWith.range
            ))
            |> Stdlib.Result.Result.Ok

          | _ -> createUnparseableError node


        let parseEnumLiteral
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          let typeNameNode = findField node "type_name"
          let symbolDotNode = findField node "symbol_dot"
          let caseNameNode = findField node "case_name"

          let enumFieldsNode =
            (findNodeByFieldName node "enum_fields")
            |> Stdlib.Option.map (fun enumFieldsNode ->
              enumFieldsNode.children
              |> Stdlib.List.map (fun child -> Expr.parse child)
              |> Stdlib.Result.collect)

            |> Stdlib.Option.withDefault (Stdlib.Result.Result.Ok [])

          match typeNameNode, symbolDotNode, caseNameNode, enumFieldsNode with
          | Ok typeNameNode, Ok symbolDotNode, Ok caseNameNode, Ok enumFieldsNode ->
            (WrittenTypes.Expr.EEnum(
              node.range,
              (typeNameNode.range, [ typeNameNode.text ]),
              (caseNameNode.range, caseNameNode.text),
              enumFieldsNode,
              symbolDotNode.range
            ))
            |> Stdlib.Result.Result.Ok

          | _ -> createUnparseableError node


        let parseLetExpr
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          let keywordLetNode = findField node "keyword_let"
          let identifierNode = findField node "identifier"
          let symbolEqualsNode = findField node "symbol_equals"
          let expr = findAndParseRequired node "expr" Expr.parse
          let body = findAndParseRequired node "body" Expr.parse

          match keywordLetNode, identifierNode, symbolEqualsNode, expr, body with
          | Ok keywordLet, Ok identifier, Ok symbolEquals, Ok expr, Ok body ->
            (WrittenTypes.Expr.ELet(
              node.range,
              WrittenTypes.LetPattern.LPVariable(identifier.range, identifier.text),
              expr,
              body,
              keywordLet.range,
              symbolEquals.range
            ))
            |> Stdlib.Result.Result.Ok

          | _ -> createUnparseableError node


        let parseFieldAccess
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          let expr = findAndParseRequired node "expr" Expr.parseCase
          let symbolDotNode = findField node "symbol_dot"
          let fieldName = findField node "field_name"

          match expr, symbolDotNode, fieldName with
          | Ok expr, Ok symbolDot, Ok field ->
            (WrittenTypes.Expr.EFieldAccess(
              node.range,
              expr,
              (field.range, field.text),
              symbolDot.range
            ))
            |> Stdlib.Result.Result.Ok

          | _ -> createUnparseableError node


        let parseInfixOperation
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          let leftArg = findAndParseRequired node "left" Expr.parse
          let operatorNode = findField node "operator"

          let operator =
            // TODO revisit error-handling here
            match operatorNode with
            | Ok operatorNode ->
              match getText operatorNode with
              | "+" ->
                WrittenTypes.Infix.InfixFnCall
                  WrittenTypes.InfixFnName.ArithmeticPlus
              | "-" ->
                WrittenTypes.Infix.InfixFnCall
                  WrittenTypes.InfixFnName.ArithmeticMinus
              | "*" ->
                WrittenTypes.Infix.InfixFnCall
                  WrittenTypes.InfixFnName.ArithmeticMultiply
              | "/" ->
                WrittenTypes.Infix.InfixFnCall
                  WrittenTypes.InfixFnName.ArithmeticDivide
              | "%" ->
                WrittenTypes.Infix.InfixFnCall
                  WrittenTypes.InfixFnName.ArithmeticModulo
              | "^" ->
                WrittenTypes.Infix.InfixFnCall
                  WrittenTypes.InfixFnName.ArithmeticPower
              | ">" ->
                WrittenTypes.Infix.InfixFnCall
                  WrittenTypes.InfixFnName.ComparisonGreaterThan
              | ">=" ->
                WrittenTypes.Infix.InfixFnCall
                  WrittenTypes.InfixFnName.ComparisonGreaterThanOrEqual
              | "<" ->
                WrittenTypes.Infix.InfixFnCall
                  WrittenTypes.InfixFnName.ComparisonLessThan
              | "<=" ->
                WrittenTypes.Infix.InfixFnCall
                  WrittenTypes.InfixFnName.ComparisonLessThanOrEqual
              | "==" ->
                WrittenTypes.Infix.InfixFnCall
                  WrittenTypes.InfixFnName.ComparisonEquals
              | "!=" ->
                WrittenTypes.Infix.InfixFnCall
                  WrittenTypes.InfixFnName.ComparisonNotEquals
              | "&&" ->
                WrittenTypes.Infix.BinOp WrittenTypes.BinaryOperation.BinOpAnd
              | "||" -> WrittenTypes.Infix.BinOp WrittenTypes.BinaryOperation.BinOpOr
              | "++" ->
                WrittenTypes.Infix.InfixFnCall WrittenTypes.InfixFnName.StringConcat
              | _ -> createUnparseableError node

            | _ -> createUnparseableError node

          let rightArg = findAndParseRequired node "right" Expr.parse

          match leftArg, operatorNode, rightArg with
          | Ok leftArg, Ok operatorNode, Ok rightArg ->
            (WrittenTypes.Expr.EInfix(
              node.range,
              ((operatorNode.range, operator)),
              leftArg,
              rightArg
            ))
            |> Stdlib.Result.Result.Ok

          | _ -> createUnparseableError node


        let parseLetPattern
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.LetPattern, WrittenTypes.Unparseable> =
          match node.children with
          | [ child ] ->
            match child.typ with
            | "unit" ->
              (WrittenTypes.LetPattern.LPUnit(child.range))
              |> Stdlib.Result.Result.Ok
            | "variable_identifier" ->
              (WrittenTypes.LetPattern.LPVariable(child.range, getText child))
              |> Stdlib.Result.Result.Ok
            | "lp_tuple" ->
              let openParenNode = findField child "symbol_left_paren"
              let first = findAndParseRequired child "first" Expr.parseLetPattern
              let second = findAndParseRequired child "second" Expr.parseLetPattern

              let rest =
                (findNodeByFieldName child "rest")
                |> Stdlib.Option.map (fun restNode ->
                  restNode.children
                  |> Stdlib.List.chunkBySize 2L
                  |> Builtin.unwrap
                  |> Stdlib.List.map (fun symbolExprPair ->
                    match symbolExprPair with
                    | [ symbol; exprNode ] ->
                      match Expr.parseLetPattern exprNode with
                      | Ok expr -> (symbol.range, expr) |> Stdlib.Result.Result.Ok
                      | Error _ -> createUnparseableError exprNode

                    | [ exprNode ] ->
                      match Expr.parseLetPattern exprNode with
                      | Ok expr ->
                        (Stdlib.Option.Option.None, expr)
                        |> Stdlib.Result.Result.Ok
                      | Error _ -> createUnparseableError exprNode
                    | _ -> createUnparseableError restNode)

                  |> Stdlib.Result.collect)

                |> Stdlib.Option.withDefault (Stdlib.Result.Result.Ok [])

              let commaSymbol = findField child "symbol_comma"
              let closeParenNode = findField child "symbol_right_paren"

              match
                openParenNode, first, commaSymbol, second, rest, closeParenNode
              with
              | Ok openParen,
                Ok first,
                Ok symComma,
                Ok second,
                Ok rest,
                Ok closeParen ->
                (WrittenTypes.LetPattern.LPTuple(
                  child.range,
                  first,
                  symComma.range,
                  second,
                  rest,
                  openParen.range,
                  closeParen.range
                ))
                |> Stdlib.Result.Result.Ok

              | _ -> createUnparseableError child

          | _ -> createUnparseableError child


        let parseLambda
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          let keywordFun = findField node "keyword_fun"

          let paramsNode =
            match findField node "pats" with
            | Ok paramsNode ->
              paramsNode.children
              |> Stdlib.List.map (fun pat -> parseLetPattern pat)
              |> Stdlib.Result.collect

            | _ -> createUnparseableError node

          let arrowNode = findField node "symbol_arrow"
          let bodyNode = findAndParseRequired node "body" Expr.parse

          match keywordFun, paramsNode, arrowNode, bodyNode with
          | Ok keywordFun, Ok paramsNode, Ok arrowNode, Ok bodyNode ->
            (WrittenTypes.Expr.ELambda(
              node.range,
              paramsNode,
              bodyNode,
              keywordFun.range,
              arrowNode.range
            ))
            |> Stdlib.Result.Result.Ok

          | _ -> createUnparseableError node


        let parseIfExpression
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          let keywordIfNode = findField node "keyword_if"
          let conditionNode = findAndParseRequired node "condition" Expr.parse
          let keywordThenNode = findField node "keyword_then"
          let thenNode = findAndParseRequired node "then_expression" Expr.parse

          let keywordElseNodeRange =
            findAndParseOptional node "keyword_else" (fun node ->
              node.range |> Stdlib.Result.Result.Ok)

          let elseNode = findAndParseOptional node "else_expression" Expr.parse

          match keywordIfNode, conditionNode, keywordThenNode, thenNode with
          | Ok keywordIf, Ok condition, Ok keywordThen, Ok thenNode ->
            (WrittenTypes.Expr.EIf(
              node.range,
              condition,
              thenNode,
              elseNode,
              keywordIf.range,
              keywordThen.range,
              keywordElseNodeRange
            ))
            |> Stdlib.Result.Result.Ok

          | _ -> createUnparseableError node


        let parseMatchCase
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.MatchCase, WrittenTypes.Unparseable> =
          let pipeSym = findField node "symbol_pipe"

          let pattern =
            findAndParseRequired node "pattern" MatchPattern.parseMatchPattern

          let arrowSym = findField node "symbol_arrow"
          let rhs = findAndParseRequired node "rhs" Expr.parse

          let whenKeywordNode =
            findAndParseOptional node "when_keyword" (fun node ->
              node.range |> Stdlib.Result.Result.Ok)

          let guardExprNode = findAndParseOptional node "guard_expr" Expr.parse

          let guardExpr =
            match whenKeywordNode, guardExprNode with
            | Some whenKeyword, Some guardExpr ->
              (whenKeyword, guardExpr) |> Stdlib.Option.Option.Some
            | _ -> Stdlib.Option.Option.None

          match pipeSym, pattern, arrowSym, rhs with
          | Ok pipe, Ok pattern, Ok arrow, Ok rhs ->
            (WrittenTypes.MatchCase
              { pat = (pipe.range, pattern, arrow.range)
                whenCondition = guardExpr
                rhs = rhs })
            |> Stdlib.Result.Result.Ok

          | _ -> createUnparseableError node


        let parseMatchExpression
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          let keywordMatchNode = findField node "keyword_match"
          let exprNode = findAndParseRequired node "arg" Expr.parse
          let keywordWithNode = findField node "keyword_with"

          let cases =
            node.children
            |> Stdlib.List.filter (fun c ->
              match c.fieldName with
              | Some fName -> fName == "cases"
              | None -> false)
            |> Stdlib.List.map (fun c -> parseMatchCase c)
            |> Stdlib.Result.collect

          match keywordMatchNode, exprNode, keywordWithNode, cases with
          | Ok keywordMatch, Ok expr, Ok keywordWith, Ok cases ->
            (WrittenTypes.Expr.EMatch(
              node.range,
              expr,
              cases,
              keywordMatch.range,
              keywordWith.range
            ))
            |> Stdlib.Result.Result.Ok

          | _ -> createUnparseableError node


        let parsePipeExpression
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          let expr = findAndParseRequired node "expr" Expr.parse

          let pipeExpr =
            (findNodeByFieldName node "pipe_exprs")
            |> Stdlib.Option.map (fun pipeExprNode ->
              pipeExprNode.children
              |> Stdlib.List.chunkBySize 2L
              |> Builtin.unwrap
              |> Stdlib.List.map (fun symbolPipeExprPair ->
                match symbolPipeExprPair with
                | [ pipeSymbol; pipeExpr ] ->
                  match PipeExpr.parse pipeExpr with
                  | Ok pipeExpr ->
                    (pipeSymbol.range, pipeExpr) |> Stdlib.Result.Result.Ok
                  | Error _ -> createUnparseableError pipeExpr
                | _ -> createUnparseableError pipeExprNode)

              |> Stdlib.Result.collect)

            // CLEANUP: should error instead of returning an empty list?
            |> Stdlib.Option.withDefault (Stdlib.Result.Result.Ok [])

          match expr, pipeExpr with
          | Ok expr, Ok pipeExpr ->
            (WrittenTypes.Expr.EPipe(node.range, expr, pipeExpr))
            |> Stdlib.Result.Result.Ok
          | _ -> createUnparseableError node


        let parseFunctionCall
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          let fnNameNode =
            findAndParseRequired node "fn" Identifiers.parseQualifiedFunction

          let args =
            node.children
            |> Stdlib.List.filter (fun c ->
              match c.fieldName with
              | Some fName -> fName == "args"
              | None -> false)
            |> Stdlib.List.map Expr.parse
            |> Stdlib.Result.collect

          match fnNameNode, args with
          | Ok fnName, Ok args ->
            let typeArgs = fnName.typeArgs
            let fnName = WrittenTypes.Expr.EFnName(node.range, fnName)

            (WrittenTypes.Expr.EApply(node.range, fnName, typeArgs, args))
            |> Stdlib.Result.Result.Ok

          | _ -> createUnparseableError node


        /// this parses one of the Expr cases
        let parseCase
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          match node.typ with
          // simple
          | "paren_expression" -> findAndParseRequired node "expr" Expr.parse
          | "simple_expression" ->
            match node.children with
            | [ single ] -> parseCase single
            | _ -> createUnparseableError node

          | "unit" -> (WrittenTypes.Expr.EUnit node.range) |> Stdlib.Result.Result.Ok
          | "bool_literal" -> parseBoolLiteral node
          | "int8_literal" -> parseIntLiteral node
          | "uint8_literal" -> parseIntLiteral node
          | "int16_literal" -> parseIntLiteral node
          | "uint16_literal" -> parseIntLiteral node
          | "int32_literal" -> parseIntLiteral node
          | "uint32_literal" -> parseIntLiteral node
          | "int64_literal" -> parseIntLiteral node
          | "uint64_literal" -> parseIntLiteral node
          | "int128_literal" -> parseIntLiteral node
          | "uint128_literal" -> parseIntLiteral node
          | "float_literal" -> parseFloatLiteral node
          | "string_literal" -> parseStringLiteral node
          | "char_literal" -> parseCharLiteral node

          | "list_literal" -> parseListLiteral node
          | "dict_literal" -> parseDictLiteral node
          | "tuple_literal" -> parseTupleLiteral node

          | "record_literal" -> parseRecordLiteral node
          | "record_update" -> parseRecordUpdate node
          | "enum_literal" -> parseEnumLiteral node

          // assigning and accessing variables
          | "let_expression" -> parseLetExpr node
          | "variable_identifier" ->
            (WrittenTypes.Expr.EVariable(node.range, getText node))
            |> Stdlib.Result.Result.Ok

          | "field_access" -> parseFieldAccess node

          | "if_expression" -> parseIfExpression node
          | "match_expression" -> parseMatchExpression node
          | "pipe_expression" -> parsePipeExpression node

          // fn calls
          | "infix_operation" -> parseInfixOperation node
          | "lambda_expression" -> parseLambda node
          | "apply" -> parseFunctionCall node

          | _ -> createUnparseableError node


        /// this parses the 'container' of an expression
        let parse
          (node: ParsedNode)
          : Stdlib.Result.Result<WrittenTypes.Expr, WrittenTypes.Unparseable> =
          if node.typ == "expression" then
            match node.children with
            | [ single ] -> parseCase single
            | _ -> createUnparseableError node
          elif node.typ == "simple_expression" then
            parseCase node
          elif node.typ == "paren_expression" then
            findAndParseRequired node "expr" Expr.parse
          else
            createUnparseableErrorMsg node $"Unsupported expression type: {node.typ}"