module Darklang.LanguageTools.Parser.CliScript


type WTCliScriptModule =
  { owner: String
    name: String
    types: List<LanguageTools.WrittenTypes.TypeDeclaration.TypeDeclaration>
    values:
      List<LanguageTools.WrittenTypes.ValueDeclaration.ValueDeclaration>
    fns: List<LanguageTools.WrittenTypes.FnDeclaration.FnDeclaration>
    submodules:
      List<LanguageTools.WrittenTypes.ModuleDeclaration.ModuleDeclaration>
    exprs: List<LanguageTools.WrittenTypes.Expr> }

type PTCliScriptModule =
  { types: List<LanguageTools.ProgramTypes.PackageType.PackageType>
    values:
      List<LanguageTools.ProgramTypes.PackageValue.PackageValue>
    fns: List<LanguageTools.ProgramTypes.PackageFn.PackageFn>
    submodules: List<LanguageTools.ProgramTypes.Definitions>
    exprs: List<LanguageTools.ProgramTypes.Expr> }

let parseDecls
  (owner: String)
  (scriptName: String)
  (source: LanguageTools.WrittenTypes.ParsedFile)
  : Stdlib.Result.Result<WTCliScriptModule, String> =
  match source with
  | SourceFile source ->
    let types =
      source.declarations
      |> Stdlib.List.filterMap (fun decl ->
        match decl with
        | Type t -> Stdlib.Option.Option.Some t
        | _ -> Stdlib.Option.Option.None)

    let values =
      source.declarations
      |> Stdlib.List.filterMap (fun decl ->
        match decl with
        | Value v -> Stdlib.Option.Option.Some v
        | _ -> Stdlib.Option.Option.None)

    let fns =
      source.declarations
      |> Stdlib.List.filterMap (fun decl ->
        match decl with
        | Function f -> Stdlib.Option.Option.Some f
        | _ -> Stdlib.Option.Option.None)

    let submodules =
      source.declarations
      |> Stdlib.List.filterMap (fun decl ->
        match decl with
        | Module m -> Stdlib.Option.Option.Some m
        | _ -> Stdlib.Option.Option.None)

    let exprs = source.exprsToEval

    Stdlib.Result.Result.Ok(
      WTCliScriptModule
        { owner = owner
          name = scriptName
          types = types
          values = values
          fns = fns
          submodules = submodules
          exprs = exprs }
    )

  | _ -> Stdlib.Result.Result.Error "Invalid source file"


let toPT
  (onMissing: NameResolver.OnMissing)
  (pm: ProgramTypes.PackageManager.PackageManager)
  (wt: WTCliScriptModule)
  : (PTCliScriptModule * List<Parser.Range * ProgramTypes.NameResolutionError>)
  =
  let modules = if wt.name == "" then [] else [ wt.name ]

  let (types, unresolvedNamesInTypes) =
    wt.types
    |> Stdlib.List.map (fun t ->
      LanguageTools.WrittenTypesToProgramTypes.TypeDeclaration.toPackageTypePT
        onMissing
        pm
        wt.owner
        modules
        t)
    |> Stdlib.List.unzip

  let (values, unresolvedNamesInValues) =
    wt.values
    |> Stdlib.List.map (fun c ->
      WrittenTypesToProgramTypes.ValueDeclaration.toPackageValuePT
        onMissing
        pm
        wt.owner
        [ wt.name ]
        c)
    |> Stdlib.List.unzip

  let (fns, unresolvedNamesInFns) =
    wt.fns
    |> Stdlib.List.map (fun f ->
      WrittenTypesToProgramTypes.FunctionDeclaration.toPackageFnPT
        onMissing
        pm
        wt.owner
        modules
        f)
    |> Stdlib.List.unzip

  let (submodules, unresolvedNamesInSubModules) =
    wt.submodules
    |> Stdlib.List.map (fun m ->
      WrittenTypesToProgramTypes.ModuleDeclaration.submoduleToPT
        onMissing
        pm
        wt.owner
        modules
        m)
    |> Stdlib.List.unzip
  let unresolvedNamesInSubModules = Stdlib.List.flatten unresolvedNamesInSubModules

  let (exprs, unresolvedNamesInExprs) =
    wt.exprs
    |> Stdlib.List.map (fun e ->
      LanguageTools.WrittenTypesToProgramTypes.Expr.toPT
        onMissing
        pm
        wt.owner
        modules
        e)
    |> Stdlib.List.unzip
  let unresolvedNamesInExprs = Stdlib.List.flatten unresolvedNamesInExprs

  let unresolvedNames =
    Stdlib.List.flatten
      [ unresolvedNamesInTypes |> Stdlib.List.flatten
        unresolvedNamesInValues |> Stdlib.List.flatten
        unresolvedNamesInFns |> Stdlib.List.flatten
        unresolvedNamesInSubModules
        unresolvedNamesInExprs ]

  (PTCliScriptModule
    { types = types
      values = values
      fns = fns
      submodules = submodules
      exprs = exprs },
    unresolvedNames)


let parse
  (owner: String)
  (scriptName: String)
  (onMissing: NameResolver.OnMissing)
  (pm: ProgramTypes.PackageManager.PackageManager)
  (filename: String)
  (source: String)
  : Stdlib.Result.Result<(PTCliScriptModule * List<Parser.Range * ProgramTypes.NameResolutionError>), String> =
  match source |> LanguageTools.Parser.TestParsing.initialParse with
  | Error e -> Stdlib.Result.Result.Error e
  | Ok parsedFile ->
    match parseDecls owner scriptName parsedFile with
    | Error e -> Stdlib.Result.Result.Error e
    | Ok moduleWT ->
      let (result, unresolvedNames) = toPT onMissing pm moduleWT

      // Note: We only do a single pass of toPT now.
      // The old code did two passes to preserve IDs, but that relied on
      // .name fields that no longer exist. Since CLI scripts are temporary
      // and not persisted to the database, fresh IDs are fine.
      Stdlib.Result.Result.Ok ((result, unresolvedNames))


let pmWithExtras
  (owner: String)
  (scriptName: String)
  (onMissing: NameResolver.OnMissing)
  (pm: ProgramTypes.PackageManager.PackageManager)
  (filename: String)
  (source: String)
  : Stdlib.Result.Result<ProgramTypes.PackageManager.PackageManager, String> =
  match source |> LanguageTools.Parser.TestParsing.initialParse with
  | Error e -> Stdlib.Result.Result.Error e
  | Ok parsedFile ->
    match parseDecls owner scriptName parsedFile with
    | Error e -> Stdlib.Result.Result.Error e
    | Ok moduleWT ->
      let (initialParse, _) = toPT onMissing pm moduleWT

      let types =
        Stdlib.List.append
          initialParse.types
          (initialParse.submodules
            |> Stdlib.List.map (fun m -> m.types)
            |> Stdlib.List.flatten)

      let values =
        Stdlib.List.append
          initialParse.values
          (initialParse.submodules
          |> Stdlib.List.map (fun m -> m.values)
          |> Stdlib.List.flatten)

      let fns =
        Stdlib.List.append
          initialParse.fns
          (initialParse.submodules
            |> Stdlib.List.map (fun m -> m.fns)
            |> Stdlib.List.flatten)

      // Wrap entities with dummy locations for withExtras
      let typesWithLocations =
        types
        |> Stdlib.List.map (fun t ->
          ProgramTypes.LocatedItem
            { entity = t
              location =
                ProgramTypes.PackageLocation
                  { owner = owner
                    modules = if scriptName == "" then [] else [ scriptName ]
                    name = Stdlib.Uuid.toString t.id } })

      let valuesWithLocations =
        values
        |> Stdlib.List.map (fun v ->
          ProgramTypes.LocatedItem
            { entity = v
              location =
                ProgramTypes.PackageLocation
                  { owner = owner
                    modules = if scriptName == "" then [] else [ scriptName ]
                    name = Stdlib.Uuid.toString v.id } })

      let fnsWithLocations =
        fns
        |> Stdlib.List.map (fun f ->
          ProgramTypes.LocatedItem
            { entity = f
              location =
                ProgramTypes.PackageLocation
                  { owner = owner
                    modules = if scriptName == "" then [] else [ scriptName ]
                    name = Stdlib.Uuid.toString f.id } })

      (ProgramTypes.PackageManager.withExtras
        pm
        typesWithLocations
        valuesWithLocations
        fnsWithLocations)
      |> Stdlib.Result.Result.Ok
