module Darklang.LanguageTools.Parser.CliScript


type WTCliScriptModule =
  { owner: String
    name: String
    types: List<LanguageTools.WrittenTypes.TypeDeclaration.TypeDeclaration>
    values:
      List<LanguageTools.WrittenTypes.ValueDeclaration.ValueDeclaration>
    fns: List<LanguageTools.WrittenTypes.FnDeclaration.FnDeclaration>
    submodules:
      List<LanguageTools.WrittenTypes.ModuleDeclaration.ModuleDeclaration>
    exprs: List<LanguageTools.WrittenTypes.Expr> }

type PTCliScriptModule =
  { types: List<LanguageTools.ProgramTypes.PackageType.PackageType>
    values:
      List<LanguageTools.ProgramTypes.PackageValue.PackageValue>
    fns: List<LanguageTools.ProgramTypes.PackageFn.PackageFn>
    submodules: List<LanguageTools.ProgramTypes.Definitions>
    exprs: List<LanguageTools.ProgramTypes.Expr> }

let parseDecls
  (owner: String)
  (scriptName: String)
  (source: LanguageTools.WrittenTypes.ParsedFile)
  : Stdlib.Result.Result<WTCliScriptModule, String> =
  match source with
  | SourceFile source ->
    // Check for unparseable content (e.g., invalid syntax like `!true`)
    match source.unparseableStuff with
    | first :: _ ->
      let errorText = first.source.text
      let errorRange = first.source.range
      let lineNum = (Stdlib.Int64.add errorRange.start.row 1L) |> Stdlib.Int64.toString
      let colNum = errorRange.start.column |> Stdlib.Int64.toString
      let note =
        match first.note with
        | Some n -> $": {n}"
        | None -> ""

      Stdlib.Result.Result.Error
        $"Parse error at line {lineNum}, column {colNum}: unexpected '{errorText}'{note}"

    | [] ->
      let types =
        source.declarations
        |> Stdlib.List.filterMap (fun decl ->
          match decl with
          | Type t -> Stdlib.Option.Option.Some t
          | _ -> Stdlib.Option.Option.None)

      let values =
        source.declarations
        |> Stdlib.List.filterMap (fun decl ->
          match decl with
          | Value v -> Stdlib.Option.Option.Some v
          | _ -> Stdlib.Option.Option.None)

      let fns =
        source.declarations
        |> Stdlib.List.filterMap (fun decl ->
          match decl with
          | Function f -> Stdlib.Option.Option.Some f
          | _ -> Stdlib.Option.Option.None)

      let submodules =
        source.declarations
        |> Stdlib.List.filterMap (fun decl ->
          match decl with
          | Module m -> Stdlib.Option.Option.Some m
          | _ -> Stdlib.Option.Option.None)

      let exprs = source.exprsToEval

      Stdlib.Result.Result.Ok(
        WTCliScriptModule
          { owner = owner
            name = scriptName
            types = types
            values = values
            fns = fns
            submodules = submodules
            exprs = exprs }
      )

  | _ -> Stdlib.Result.Result.Error "Invalid source file"


/// Helper to process a list of declarations and split results into separate lists (entities, ops, unresolved names)
let processDecls
  (items: List<'a>)
  (processFn: 'a -> ('entity * List<ProgramTypes.PackageOp> * List<Parser.Range * ProgramTypes.NameResolutionError>))
  : (List<'entity> * List<List<ProgramTypes.PackageOp>> * List<List<Parser.Range * ProgramTypes.NameResolutionError>>) =
  let results = items |> Stdlib.List.map processFn

  let entities = results |> Stdlib.List.map (fun (e, _, _) -> e)
  let ops = results |> Stdlib.List.map (fun (_, ops, _) -> ops)
  let unresolvedNames = results |> Stdlib.List.map (fun (_, _, u) -> u)

  (entities, ops, unresolvedNames)


let toPT
  (onMissing: NameResolver.OnMissing)
  (pm: ProgramTypes.PackageManager.PackageManager)
  (wt: WTCliScriptModule)
  : (PTCliScriptModule *
    List<ProgramTypes.PackageOp> *
    List<Parser.Range * ProgramTypes.NameResolutionError>)
  =
  let modules = if wt.name == "" then [] else [ wt.name ]

  // Process types and generate ops
  let (types, typeOps, typeUnresolvedNames) =
    processDecls wt.types (fun t ->
      let typeName = t.name.name

      let (pt, unresolvedNames) =
        LanguageTools.WrittenTypesToProgramTypes.TypeDeclaration.toPackageTypePT
          onMissing
          pm
          wt.owner
          modules
          t

      let location =
        ProgramTypes.PackageLocation
          { owner = wt.owner; modules = modules; name = typeName }

      let ops =
        [ ProgramTypes.PackageOp.AddType pt
          ProgramTypes.PackageOp.SetTypeName(pt.id, location) ]

      (pt, ops, unresolvedNames))

  // Process values and generate ops
  let (values, valueOps, valueUnresolvedNames) =
    processDecls wt.values (fun v ->
      let valueName = v.name.name

      let (pv, unresolvedNames) =
        WrittenTypesToProgramTypes.ValueDeclaration.toPackageValuePT
          onMissing
          pm
          wt.owner
          modules
          v

      let location =
        ProgramTypes.PackageLocation
          { owner = wt.owner; modules = modules; name = valueName }

      let ops =
        [ ProgramTypes.PackageOp.AddValue pv
          ProgramTypes.PackageOp.SetValueName(pv.id, location) ]

      (pv, ops, unresolvedNames))

  // Process functions and generate ops
  let (fns, fnOps, fnUnresolvedNames) =
    processDecls wt.fns (fun f ->
      let fnName = f.name.name

      let (pf, unresolvedNames) =
        WrittenTypesToProgramTypes.FunctionDeclaration.toPackageFnPT
          onMissing
          pm
          wt.owner
          modules
          f

      let location =
        ProgramTypes.PackageLocation
          { owner = wt.owner; modules = modules; name = fnName }

      let ops =
        [ ProgramTypes.PackageOp.AddFn pf
          ProgramTypes.PackageOp.SetFnName(pf.id, location) ]

      (pf, ops, unresolvedNames))

  // Process submodules recursively with ops
  let (submodules, submoduleOps, submoduleUnresolvedNames) =
    processDecls wt.submodules (fun m ->
      let (_, submoduleName) = m.name
      let extendedModules = Stdlib.List.append modules [ submoduleName ]

      WrittenTypesToProgramTypes.moduleDeclarationWithOpsHelper
        pm
        wt.owner
        extendedModules
        m)


  let (exprs, unresolvedNamesInExprs) =
    wt.exprs
    |> Stdlib.List.map (fun e ->
      LanguageTools.WrittenTypesToProgramTypes.Expr.toPT
        onMissing
        pm
        wt.owner
        modules
        LanguageTools.WrittenTypesToProgramTypes.defaultContext
        e)
    |> Stdlib.List.unzip

  // Collect all ops
  let allOps =
    Stdlib.List.flatten
      [ typeOps |> Stdlib.List.flatten
        valueOps |> Stdlib.List.flatten
        fnOps |> Stdlib.List.flatten
        submoduleOps |> Stdlib.List.flatten ]

  // Collect all unresolved names
  let unresolvedNames =
    Stdlib.List.flatten
      [ typeUnresolvedNames |> Stdlib.List.flatten
        valueUnresolvedNames |> Stdlib.List.flatten
        fnUnresolvedNames |> Stdlib.List.flatten
        submoduleUnresolvedNames |> Stdlib.List.flatten
        unresolvedNamesInExprs |> Stdlib.List.flatten ]

  (PTCliScriptModule
    { types = types
      values = values
      fns = fns
      submodules = submodules
      exprs = exprs },
    allOps,
    unresolvedNames)


let parse
  (owner: String)
  (scriptName: String)
  (onMissing: NameResolver.OnMissing)
  (pm: ProgramTypes.PackageManager.PackageManager)
  (filename: String)
  (source: String)
  : Stdlib.Result.Result<(PTCliScriptModule * List<Parser.Range * ProgramTypes.NameResolutionError>), String> =
  match source |> LanguageTools.Parser.TestParsing.initialParse with
  | Error e -> Stdlib.Result.Result.Error e
  | Ok parsedFile ->
    match parseDecls owner scriptName parsedFile with
    | Error e -> Stdlib.Result.Result.Error e
    | Ok moduleWT ->
      // First pass: parse and generate ops (allowing unresolved names)
      let (initialParse, firstPassOps, _) =
        toPT NameResolver.OnMissing.Allow pm moduleWT

      // Create PM with first pass ops for second pass
      let pm = ProgramTypes.PackageManager.withExtraOps pm firstPassOps

      // Second pass: re-parse with updated PackageManager
      let (result, _, unresolvedNames) = toPT onMissing pm moduleWT

      let adjustedTypes =
        (Stdlib.List.zip result.types initialParse.types)
        |> Stdlib.Option.mapWithDefault result.types (fun zipped ->
          zipped
          |> Stdlib.List.map (fun tuple ->
            let (newType, originalType) = tuple
            { newType with id = originalType.id }))

      let adjustedValues =
        (Stdlib.List.zip result.values initialParse.values)
        |> Stdlib.Option.mapWithDefault result.values (fun zipped ->
          zipped
          |> Stdlib.List.map (fun tuple ->
            let (newValue, originalValue) = tuple
            { newValue with id = originalValue.id }))

      let adjustedFns =
        (Stdlib.List.zip result.fns initialParse.fns)
        |> Stdlib.Option.mapWithDefault result.fns (fun zipped ->
          zipped
          |> Stdlib.List.map (fun tuple ->
            let (newFn, originalFn) = tuple
            { newFn with id = originalFn.id }))

      let adjustedSubmodules =
        (Stdlib.List.zip result.submodules initialParse.submodules)
        |> Stdlib.Option.mapWithDefault result.submodules (fun zipped ->
          zipped
          |> Stdlib.List.map (fun tuple ->
            let (newSub, originalSub) = tuple

            let subTypes =
              (Stdlib.List.zip newSub.types originalSub.types)
              |> Stdlib.Option.mapWithDefault newSub.types (fun z ->
                z
                |> Stdlib.List.map (fun t ->
                  let (newT, origT) = t
                  { newT with id = origT.id }))

            let subValues =
              (Stdlib.List.zip newSub.values originalSub.values)
              |> Stdlib.Option.mapWithDefault newSub.values (fun z ->
                z
                |> Stdlib.List.map (fun v ->
                  let (newV, origV) = v
                  { newV with id = origV.id }))

            let subFns =
              (Stdlib.List.zip newSub.fns originalSub.fns)
              |> Stdlib.Option.mapWithDefault newSub.fns (fun z ->
                z
                |> Stdlib.List.map (fun f ->
                  let (newF, origF) = f
                  { newF with id = origF.id }))

            ProgramTypes.Definitions
              { types = subTypes
                values = subValues
                fns = subFns
                exprs = newSub.exprs }))

      let adjusted =
        PTCliScriptModule
          { types = adjustedTypes
            values = adjustedValues
            fns = adjustedFns
            submodules = adjustedSubmodules
            exprs = result.exprs }

      Stdlib.Result.Result.Ok ((adjusted, unresolvedNames))


let pmWithExtras
  (owner: String)
  (scriptName: String)
  (onMissing: NameResolver.OnMissing)
  (pm: ProgramTypes.PackageManager.PackageManager)
  (filename: String)
  (source: String)
  : Stdlib.Result.Result<ProgramTypes.PackageManager.PackageManager, String> =
  match source |> LanguageTools.Parser.TestParsing.initialParse with
  | Error e -> Stdlib.Result.Result.Error e
  | Ok parsedFile ->
    match parseDecls owner scriptName parsedFile with
    | Error e -> Stdlib.Result.Result.Error e
    | Ok moduleWT ->
      let (_, ops, _) = toPT onMissing pm moduleWT

      (ProgramTypes.PackageManager.withExtraOps pm ops)
      |> Stdlib.Result.Result.Ok
