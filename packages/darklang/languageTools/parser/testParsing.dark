module Darklang.LanguageTools.Parser.TestParsing


let initialParse
  (code: String)
  : Stdlib.Result.Result<WrittenTypes.ParsedFile, String> =
  code
  |> LanguageTools.Parser.parseToSimplifiedTree
  |> LanguageTools.Parser.parseFromTree

// TODO: maybe use a proper type instead of string?
let parsePTExpr
  (branchID: Stdlib.Option.Option<ProgramTypes.BranchID>)
  (code: String)
  : Stdlib.Result.Result<ProgramTypes.Expr, String> =
  match code |> TestParsing.initialParse with
  | Ok sourceFile ->
    let exprs =
      match sourceFile with
      | SourceFile s -> s.exprsToEval
      | _ -> []

    let onMissing = LanguageTools.NameResolver.OnMissing.Allow
    let pm = LanguageTools.PackageManager.pm ()

    match exprs with
    | [ expr ] ->
      let (expr, _) =
        WrittenTypesToProgramTypes.Expr.toPT
          branchID
          onMissing
          pm
          ""
          []
          (WrittenTypesToProgramTypes.Context { currentFnName = Stdlib.Option.Option.None; argMap = Stdlib.Dict.empty })
          expr

      expr |> Stdlib.Result.Result.Ok
    | _ ->
      "Expected exactly one expression to be parsed"
      |> Stdlib.Result.Result.Error
  | Error e -> Stdlib.Result.Result.Error e

let parsePTSourceFile
  (code: String)
  (branchID: Stdlib.Option.Option<ProgramTypes.BranchID>)
  : Stdlib.Result.Result<ProgramTypes.SourceFile.SourceFile, String> =
  match code |> TestParsing.initialParse with
  | Ok parsedFile ->
    parsedFile
    |> WrittenTypesToProgramTypes.parsedFileAsSourceFile branchID
    |> Stdlib.Tuple3.first
    |> Stdlib.Result.Result.Ok
  | Error e -> Stdlib.Result.Result.Error e

let parsePTSourceFileWithOps
  (branchID: Stdlib.Option.Option<ProgramTypes.BranchID>)
  (code: String)
  : Stdlib.Result.Result<
    (ProgramTypes.SourceFile.SourceFile *
      List<ProgramTypes.PackageOp>),
    String
  > =
  match code |> TestParsing.initialParse with
  | Ok parsedFile ->
    let (sourceFile, ops, _unresolvedNames) =
      parsedFile |> WrittenTypesToProgramTypes.parsedFileAsSourceFile branchID

    (sourceFile, ops) |> Stdlib.Result.Result.Ok
  | Error e -> Stdlib.Result.Result.Error e

let parseAndPrettyPrint
  (branchID: Stdlib.Option.Option<ProgramTypes.BranchID>)
  (code: String)
  : Stdlib.Result.Result<String, String> =
  match code |> TestParsing.parsePTSourceFile branchID with
  | Ok sourceFile ->
    sourceFile
    |> PrettyPrinter.ProgramTypes.sourceFile
    |> Stdlib.Result.Result.Ok
  | Error e -> Stdlib.Result.Result.Error e