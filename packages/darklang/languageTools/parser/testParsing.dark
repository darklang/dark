module Darklang.LanguageTools.Parser.TestParsing


let initialParse
  (code: String)
  : Stdlib.Result.Result<WrittenTypes.ParsedFile, String> =
  code
  |> parseToSimplifiedTree
  |> parseFromTree


// TODO: maybe use a proper type instead of string?
let parsePTExpr
  (code: String)
  : Stdlib.Result.Result<ProgramTypes.Expr, String> =
  match code |> TestParsing.initialParse with
  | Ok sourceFile ->
    let exprs =
      match sourceFile with
      | SourceFile s -> s.exprsToEval
      | _ -> []

    let onMissing = NameResolver.OnMissing.Allow
    let pm = PackageManager.pm ()

    match exprs with
    | [ expr ] ->
      let (expr, _) =
        WrittenTypesToProgramTypes.Expr.toPT
          onMissing
          pm
          ""
          []
          WrittenTypesToProgramTypes.defaultContext
          expr

      expr |> Stdlib.Result.Result.Ok
    | _ ->
      "Expected exactly one expression to be parsed"
      |> Stdlib.Result.Result.Error
  | Error e -> Stdlib.Result.Result.Error e


let parsePTSourceFileWithOps
  (code: String)
  : Stdlib.Result.Result<
    (ProgramTypes.SourceFile.SourceFile * List<ProgramTypes.PackageOp>),
    String
  > =
  match code |> TestParsing.initialParse with
  | Ok parsedFile ->
    let (sourceFile, ops, _unresolvedNames) =
      parsedFile |> WrittenTypesToProgramTypes.parsedFileAsSourceFile

    (sourceFile, ops) |> Stdlib.Result.Result.Ok
  | Error e -> Stdlib.Result.Result.Error e
