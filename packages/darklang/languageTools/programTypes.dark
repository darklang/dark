module Darklang.LanguageTools.ProgramTypes


/// Used to name where type/function/etc lives, eg a User module, or a Package module.
module FQTypeName =
  type Package = Uuid
  type FQTypeName = Package of Package

module FQValueName =
  type Builtin = { name: String; version: Int32 }
  type Package = Uuid

  type FQValueName =
    | Builtin of Builtin
    | Package of Package

module FQFnName =
  type Builtin = { name: String; version: Int32 }
  type Package = Uuid

  type FQFnName =
    | Builtin of Builtin
    | Package of Package


type NameResolutionError =
  | NotFound of List<String>
  | InvalidName of List<String>

type NameResolution<'a> = Stdlib.Result.Result<'a, NameResolutionError>


/// Darklang's available types (int, List<T>, user-defined types, etc.)
type TypeReference =
  // A named variable, eg `a` in `List<a>`, matches anything
  | TVariable of String

  | TUnit
  | TBool
  | TInt8
  | TUInt8
  | TInt16
  | TUInt16
  | TInt32
  | TUInt32
  | TInt64
  | TUInt64
  | TInt128
  | TUInt128
  | TFloat
  | TChar
  | TString
  | TDateTime
  | TUuid

  | TList of TypeReference
  | TTuple of TypeReference * TypeReference * List<TypeReference>
  | TDict of TypeReference

  | TCustomType of
    NameResolution<FQTypeName.FQTypeName> *
    typeArgs: List<TypeReference>

  | TDB of TypeReference

  // TODO: this should be an NEList
  | TFn of List<TypeReference> * TypeReference



type LetPattern =
  | LPUnit of ID
  | LPVariable of ID * name: String
  | LPTuple of
    ID *
    first: LetPattern *
    second: LetPattern *
    theRest: List<LetPattern>


/// Used for pattern matching in a match statement
type MatchPattern =
  | MPVariable of ID * String

  | MPUnit of ID
  | MPBool of ID * Bool
  | MPInt8 of ID * Int8
  | MPUInt8 of ID * UInt8
  | MPInt16 of ID * Int16
  | MPUInt16 of ID * UInt16
  | MPInt32 of ID * Int32
  | MPUInt32 of ID * UInt32
  | MPInt64 of ID * Int64
  | MPUInt64 of ID * UInt64
  | MPInt128 of ID * Int128
  | MPUInt128 of ID * UInt128
  | MPFloat of ID * Sign * String * String
  | MPChar of ID * String
  | MPString of ID * String

  | MPList of ID * List<MatchPattern>
  | MPListCons of ID * head: MatchPattern * tail: MatchPattern

  | MPTuple of ID * MatchPattern * MatchPattern * List<MatchPattern>

  | MPEnum of ID * caseName: String * fieldPats: List<MatchPattern>

  | MPOr of ID * List<MatchPattern>

type BinaryOperation =
  | BinOpAnd
  | BinOpOr


type InfixFnName =
  | ArithmeticPlus
  | ArithmeticMinus
  | ArithmeticMultiply
  | ArithmeticDivide
  | ArithmeticModulo
  | ArithmeticPower
  | ComparisonGreaterThan
  | ComparisonGreaterThanOrEqual
  | ComparisonLessThan
  | ComparisonLessThanOrEqual
  | ComparisonEquals
  | ComparisonNotEquals
  | StringConcat

type Infix =
  | InfixFnCall of InfixFnName
  | BinOp of BinaryOperation


type StringSegment =
  | StringText of String
  | StringInterpolation of Expr


type PipeExpr =
  | EPipeVariable of ID * String * List<Expr>

  | EPipeLambda of ID * List<LetPattern> * Expr

  | EPipeInfix of ID * Infix * Expr

  | EPipeFnCall of
    ID *
    NameResolution<FQFnName.FQFnName> *
    typeArgs: List<TypeReference> *
    args: List<Expr>

  | EPipeEnum of
    ID *
    typeName: NameResolution<FQTypeName.FQTypeName> *
    caseName: String *
    fields: List<Expr>


type MatchCase =
  { pat: MatchPattern
    whenCondition: Stdlib.Option.Option<Expr>
    rhs: Expr }



/// Expressions - the main part of the language.
type Expr =
  | EUnit of ID

  // simple data

  | EBool of ID * Bool

  | EInt8 of ID * Int8
  | EUInt8 of ID * UInt8
  | EInt16 of ID * Int16
  | EUInt16 of ID * UInt16
  | EInt32 of ID * Int32
  | EUInt32 of ID * UInt32
  | EInt64 of ID * Int64
  | EUInt64 of ID * UInt64
  | EInt128 of ID * Int128
  | EUInt128 of ID * UInt128

  // Allow the user to have arbitrarily big numbers, even if they don't make sense as
  // floats. The float is split as we want to preserve what the user entered.
  // Strings are used as numbers lose the leading zeros (eg 7.00007)
  | EFloat of ID * Sign * String * String

  /// A character is an Extended Grapheme Cluster (hence why we use a String). This
  /// is equivalent to one screen-visible "character" in Unicode.
  | EChar of ID * String

  | EString of ID * List<StringSegment>


  // structures of data
  | EList of ID * List<Expr>

  | EDict of ID * List<String * Expr>

  | ETuple of ID * Expr * Expr * List<Expr>

  | ERecord of
    ID *
    typeName: NameResolution<FQTypeName.FQTypeName> *
    typeArgs: List<TypeReference> *
    fields: List<String * Expr>

  | EEnum of
    ID *
    typeName: NameResolution<FQTypeName.FQTypeName> *
    typeArgs : List<TypeReference> *
    caseName: String *
    fields: List<Expr>

  // declaring and accessing variables
  | ELet of ID * LetPattern * Expr * Expr
  | ERecordFieldAccess of ID * Expr * String
  | EVariable of ID * String
  | EArg of ID * Int64
  | EValue of ID * NameResolution<FQValueName.FQValueName>

  // control flow
  | EIf of
    ID *
    cond: Expr *
    thenExpr: Expr *
    elseExpr: Stdlib.Option.Option<Expr>

  | EMatch of ID * arg: Expr * cases: List<MatchCase>

  | EPipe of ID * Expr * List<PipeExpr>


  // function calls
  | EInfix of ID * Infix * Expr * Expr

  | ELambda of ID * List<LetPattern> * Expr

  // TODO do typeArgs actually apply here?
  // they definitely don't _always_ make sense.
  | EApply of ID * Expr * typeArgs: List<TypeReference> * args: List<Expr>

  | EFnName of ID * NameResolution<FQFnName.FQFnName>

  | ERecordUpdate of ID * record: Expr * updates: List<String * Expr>

  | EStatement of ID * first: Expr * next: Expr

  | ESelf of ID

module Expr =
  let toID (expr: Expr) : ID =
    match expr with
    | EUnit id
    | EBool(id, _)
    | EInt8(id, _)
    | EUInt8(id, _)
    | EInt16(id, _)
    | EUInt16(id, _)
    | EInt32(id, _)
    | EUInt32(id, _)
    | EInt64(id, _)
    | EUInt64(id, _)
    | EInt128(id, _)
    | EUInt128(id, _)
    | EFloat(id, _, _, _)
    | EChar(id, _)
    | EString(id, _)
    | ELet(id, _, _, _)
    | EIf(id, _, _, _)
    | EInfix(id, _, _, _)
    | ELambda(id, _, _)
    | ERecordFieldAccess(id, _, _)
    | EVariable(id, _)
    | EArg(id, _)
    | EValue(id, _)
    | EFnName(id, _)
    | EApply(id, _, _, _)
    | EList(id, _)
    | EDict(id, _)
    | ETuple(id, _, _, _)
    | EPipe(id, _, _)
    | ERecord(id, _, _, _)
    | EEnum(id, _, _, _, _)
    | EMatch(id, _, _)
    | ERecordUpdate(id, _, _)
    | EStatement(id, _, _)
    | ESelf id -> id


// Used to mark whether a function/type has been deprecated, and if so,
// details about possible replacements/alternatives, and reasoning
type Deprecation<'name> =
  | NotDeprecated

  /// The exact same thing is available under a new, preferred name
  | RenamedTo of 'name

  /// This has been deprecated and has a replacement we can suggest
  | ReplacedBy of 'name

  /// This has been deprecated and not replaced, provide a message for the user
  | DeprecatedBecause of String


type PackageLocation =
  { owner: String
    modules: List<String>
    name: String }

let parsePackageLocation (nameToParse: String): PackageLocation =
  let parts = Stdlib.String.split nameToParse "."
  match parts with
  | owner :: rest ->
    let rev = Stdlib.List.reverse rest
    match rev with
    | name :: rest ->
      PackageLocation
        { owner = owner
          modules = Stdlib.List.reverse rest
          name = name }
    | [] ->
      // CLEANUP: This case should be handled better
      // Just an owner name with no module/entity name
      // Return a location pointing to the owner itself
      PackageLocation
        { owner = owner
          modules = []
          name = "" }
  | [] ->
    // Empty name (shouldn't happen, but handle it)
    PackageLocation { owner = ""; modules = []; name = "" }

type BranchID = Uuid

/// A package entity paired with its location
type LocatedItem<'entity> =
  { entity: 'entity
    location: PackageLocation }


/// A stdlib-, user-, or package- defined type (an alias, record, or enum)
module TypeDeclaration =
  type RecordField =
    { name: String
      typ: TypeReference
      description: String }

  type EnumField =
    { typ: TypeReference
      label: Stdlib.Option.Option<String>
      description: String }

  type EnumCase =
    { name: String
      fields: List<EnumField>
      description: String }

  type Definition =
    | Alias of TypeReference
    | Record of List<RecordField>
    | Enum of List<EnumCase>

  type TypeDeclaration =
    { typeParams: List<String>
      definition: Definition }




// Package space
module PackageType =
  type PackageType =
    { id: FQTypeName.Package
      declaration: TypeDeclaration.TypeDeclaration
      description: String
      deprecated: Deprecation<FQTypeName.FQTypeName> }

module PackageValue =
  type PackageValue =
    { id: Uuid
      body: Expr
      description: String
      deprecated: Deprecation<FQValueName.FQValueName> }

module PackageFn =
  type Parameter =
    { name: String
      typ: TypeReference
      description: String }

  type PackageFn =
    { id: FQFnName.Package
      body: Expr
      typeParams: List<String>
      parameters: List<Parameter>
      returnType: TypeReference
      description: String
      deprecated: Deprecation<FQFnName.FQFnName> }

// CLEANUP: Packages type commented out - only used during loading process
// type Packages =
//   { types: List<PackageType.PackageType>
//     values: List<PackageValue.PackageValue>
//     fns: List<PackageFn.PackageFn> }


type PackageOp =
  | AddType of PackageType.PackageType
  | AddValue of PackageValue.PackageValue
  | AddFn of PackageFn.PackageFn
  | SetTypeName of FQTypeName.Package * PackageLocation
  | SetValueName of FQValueName.Package * PackageLocation
  | SetFnName of FQFnName.Package * PackageLocation


module Search =
  /// The type of entity to search for
  type EntityType =
    | Type
    | Module
    | Fn
    | Value

  /// How deep to search in the module hierarchy
  type SearchDepth =
    | OnlyDirectDescendants
    | AllDescendants

  /// Query parameters for searching packages
  type SearchQuery =
    {
      /// i.e. "Darklang.Stdlib"
      currentModule: List<String>

      /// i.e. "List" or "map"
      text: String

      searchDepth: SearchDepth

      /// empty list implies 'any'
      entityTypes: List<EntityType>

      /// if true, require exact matches for names and modules instead of fuzzy matching
      exactMatch: Bool
    }

  /// Results from a package search
  type SearchResults =
    { submodules: List<List<String>> // [ [ "List"]; ["String"; "List"] ]
      types : List<LocatedItem<ProgramTypes.PackageType.PackageType>>
      values : List<LocatedItem<ProgramTypes.PackageValue.PackageValue>>
      fns : List<LocatedItem<ProgramTypes.PackageFn.PackageFn>> }




/// Functionality written in Dark stored and managed outside of user space
///
/// Note: It may be tempting to think the `getX` fns shouldn't return Options,
/// but there's a chance of Local <-> Cloud not being fully in sync,
/// for whatever reasons.
///
/// Visibility rules:
/// - Approved items are visible to everyone
module PackageManager =
  type PackageManager =
    { findType: PackageLocation -> Stdlib.Option.Option<FQTypeName.Package>
      findValue: PackageLocation -> Stdlib.Option.Option<FQValueName.Package>
      findFn: PackageLocation -> Stdlib.Option.Option<FQFnName.Package>

      getType:
        FQTypeName.Package -> Stdlib.Option.Option<PackageType.PackageType>
      getValue:
        FQValueName.Package
          -> Stdlib.Option.Option<PackageValue.PackageValue>
      getFn: FQFnName.Package -> Stdlib.Option.Option<PackageFn.PackageFn>

      search: Search.SearchQuery -> Search.SearchResults }


  /// Allows you to side-load a few 'extras' in-memory, along
  /// the normal fetching functionality. (Mostly helpful for tests)
  let withExtras
    (pm: PackageManager.PackageManager)
    (types: List<LocatedItem<PackageType.PackageType>>)
    (values: List<LocatedItem<PackageValue.PackageValue>>)
    (fns: List<LocatedItem<PackageFn.PackageFn>>)
    : PackageManager.PackageManager =
    PackageManager.PackageManager
      { findType =
          fun location ->
            match types |> Stdlib.List.findFirst (fun t -> t.location == location) with
            | Some t -> Stdlib.Option.Option.Some t.entity.id
            | None -> pm.findType location
        findValue =
          fun location ->
            match values |> Stdlib.List.findFirst (fun v -> v.location == location) with
            | Some v -> Stdlib.Option.Option.Some v.entity.id
            | None -> pm.findValue location
        findFn =
          fun location ->
            match fns |> Stdlib.List.findFirst (fun f -> f.location == location) with
            | Some f -> Stdlib.Option.Option.Some f.entity.id
            | None -> pm.findFn location

        getType =
          fun id ->
            match types |> Stdlib.List.findFirst (fun t -> t.entity.id == id) with
            | Some t -> Stdlib.Option.Option.Some t.entity
            | None -> pm.getType id
        getValue =
          fun id ->
            match values |> Stdlib.List.findFirst (fun v -> v.entity.id == id) with
            | Some v -> Stdlib.Option.Option.Some v.entity
            | None -> pm.getValue id
        getFn =
          fun id ->
            match fns |> Stdlib.List.findFirst (fun f -> f.entity.id == id) with
            | Some f -> Stdlib.Option.Option.Some f.entity
            | None -> pm.getFn id

        search = pm.search }


  /// Create a PackageManager from PackageOps, combining with an existing PM
  let withExtraOps
    (basePM: PackageManager.PackageManager)
    (ops: List<PackageOp>)
    : PackageManager.PackageManager =
    let typesByID =
      ops
      |> Stdlib.List.filterMap (fun op ->
        match op with
        | AddType t -> Stdlib.Option.Option.Some((t.id, t))
        | _ -> Stdlib.Option.Option.None)

    let valuesByID =
      ops
      |> Stdlib.List.filterMap (fun op ->
        match op with
        | AddValue v -> Stdlib.Option.Option.Some((v.id, v))
        | _ -> Stdlib.Option.Option.None)

    let fnsByID =
      ops
      |> Stdlib.List.filterMap (fun op ->
        match op with
        | AddFn f -> Stdlib.Option.Option.Some((f.id, f))
        | _ -> Stdlib.Option.Option.None)

    let typeLocationMap =
      ops
      |> Stdlib.List.filterMap (fun op ->
        match op with
        | SetTypeName (id, loc) -> Stdlib.Option.Option.Some((loc, id))
        | _ -> Stdlib.Option.Option.None)

    let valueLocationMap =
      ops
      |> Stdlib.List.filterMap (fun op ->
        match op with
        | SetValueName (id, loc) -> Stdlib.Option.Option.Some((loc, id))
        | _ -> Stdlib.Option.Option.None)

    let fnLocationMap =
      ops
      |> Stdlib.List.filterMap (fun op ->
        match op with
        | SetFnName (id, loc) -> Stdlib.Option.Option.Some((loc, id))
        | _ -> Stdlib.Option.Option.None)

    // Create PackageManager that looks up in ops first, then falls back to basePM
    PackageManager.PackageManager
      { findType =
          fun location ->
            match typeLocationMap
                  |> Stdlib.List.findFirst (fun tuple ->
                    let (loc, _) = tuple
                    loc == location) with
            | Some tuple ->
              let (_, id) = tuple
              Stdlib.Option.Option.Some id
            | None -> basePM.findType location

        findValue =
          fun location ->
            match valueLocationMap
                  |> Stdlib.List.findFirst (fun tuple ->
                    let (loc, _) = tuple
                    loc == location) with
            | Some tuple ->
              let (_, id) = tuple
              Stdlib.Option.Option.Some id
            | None -> basePM.findValue location

        findFn =
          fun location ->
            match fnLocationMap
                  |> Stdlib.List.findFirst (fun tuple ->
                    let (loc, _) = tuple
                    loc == location) with
            | Some tuple ->
              let (_, id) = tuple
              Stdlib.Option.Option.Some id
            | None -> basePM.findFn location

        getType =
          fun id ->
            match typesByID
                  |> Stdlib.List.findFirst (fun tuple ->
                    let (tid, _) = tuple
                    tid == id) with
            | Some tuple ->
              let (_, t) = tuple
              Stdlib.Option.Option.Some t
            | None -> basePM.getType id

        getValue =
          fun id ->
            match valuesByID
                  |> Stdlib.List.findFirst (fun tuple ->
                    let (vid, _) = tuple
                    vid == id) with
            | Some tuple ->
              let (_, v) = tuple
              Stdlib.Option.Option.Some v
            | None -> basePM.getValue id

        getFn =
          fun id ->
            match fnsByID
                  |> Stdlib.List.findFirst (fun tuple ->
                    let (fid, _) = tuple
                    fid == id) with
            | Some tuple ->
              let (_, f) = tuple
              Stdlib.Option.Option.Some f
            | None -> basePM.getFn id

        search = basePM.search }


type Definitions =
  { types: List<PackageType.PackageType>
    values: List<PackageValue.PackageValue>
    fns: List<PackageFn.PackageFn>
    // TODO db and handlers
    exprs: List<Expr * List<String>> }

// User/Canvas space
type DB =
  { tlid: TLID
    name: String
    version: Int32
    typ: TypeReference }


type Secret =
  { name: String
    value: String
    version: Int32 }


module Handler =
  type CronInterval =
    | EveryDay
    | EveryWeek
    | EveryFortnight
    | EveryHour
    | Every12Hours
    | EveryMinute

  type Spec =
    | HTTP of route: String * method: String
    | Worker of name: String
    | Cron of name: String * interval: CronInterval
    | REPL of name: String

  type Handler = { tlid: TLID; ast: Expr; spec: Spec }


// module Toplevel =
//   type T =
//     | TLDB of DB
//     | TLHandler of Handler.Handler

//   let toTLID (tl : T) : tlid =
//     match tl with
//     | TLDB db -> db.tlid
//     | TLHandler h -> h.tlid

module SourceFile =
  type Declaration =
    | Type of PackageType.PackageType
    | Value of PackageValue.PackageValue
    | Function of PackageFn.PackageFn
    // db and handlers
    | Module of Definitions // re-evaluate if this makes sense to be here

  type SourceFile =
    { declarations: List<Declaration>
      exprsToEval: List<Expr> }