/// For interacting with the "dark matter",
/// where package items (types, values, fns, etc) are maintained.
/// i.e. the packages + manager
///
/// Of note, this is the Dev-time PackageManager, not the Runtime PackageManager.
module Darklang.LanguageTools.PackageManager


module Type =
  let find
    (accountID: Stdlib.Option.Option<Uuid>)
    (branchID: Stdlib.Option.Option<Uuid>)
    (location: ProgramTypes.PackageLocation)
    : Stdlib.Option.Option<Uuid> =
    Builtin.pmFindType accountID branchID location

  let get
    (id: Uuid)
    : Stdlib.Option.Option<ProgramTypes.PackageType.PackageType> =
    Builtin.pmGetType id

  let getWithLocation
    (accountID: Stdlib.Option.Option<Uuid>)
    (branchID: Stdlib.Option.Option<Uuid>)
    (id: Uuid)
    : Stdlib.Option.Option<
      ProgramTypes.LocatedItem<ProgramTypes.PackageType.PackageType>> =
    match Builtin.pmGetType id with
    | Some entity ->
      match Builtin.pmGetLocationByType accountID branchID id with
      | Some location ->
        Stdlib.Option.Option.Some(
          ProgramTypes.LocatedItem { entity = entity; location = location }
        )
      | None -> Stdlib.Option.Option.None
    | None -> Stdlib.Option.Option.None


module Value =
  let find
    (accountID: Stdlib.Option.Option<Uuid>)
    (branchID: Stdlib.Option.Option<Uuid>)
    (location: ProgramTypes.PackageLocation)
    : Stdlib.Option.Option<Uuid> =
    Builtin.pmFindValue accountID branchID location

  let get
    (id: Uuid)
    : Stdlib.Option.Option<ProgramTypes.PackageValue.PackageValue> =
    Builtin.pmGetValue id

  let getWithLocation
    (accountID: Stdlib.Option.Option<Uuid>)
    (branchID: Stdlib.Option.Option<Uuid>)
    (id: Uuid)
    : Stdlib.Option.Option<
      ProgramTypes.LocatedItem<ProgramTypes.PackageValue.PackageValue>> =
    match Builtin.pmGetValue id with
    | Some entity ->
      match Builtin.pmGetLocationByValue accountID branchID id with
      | Some location ->
        Stdlib.Option.Option.Some(
          ProgramTypes.LocatedItem { entity = entity; location = location }
        )
      | None -> Stdlib.Option.Option.None
    | None -> Stdlib.Option.Option.None


module Function =
  let find
    (accountID: Stdlib.Option.Option<Uuid>)
    (branchID: Stdlib.Option.Option<Uuid>)
    (location: ProgramTypes.PackageLocation)
    : Stdlib.Option.Option<Uuid> =
    Builtin.pmFindFn accountID branchID location

  let get (id: Uuid) : Stdlib.Option.Option<ProgramTypes.PackageFn.PackageFn> =
    Builtin.pmGetFn id

  let getWithLocation
    (accountID: Stdlib.Option.Option<Uuid>)
    (branchID: Stdlib.Option.Option<Uuid>)
    (id: Uuid)
    : Stdlib.Option.Option<
      ProgramTypes.LocatedItem<ProgramTypes.PackageFn.PackageFn>> =
    match Builtin.pmGetFn id with
    | Some entity ->
      match Builtin.pmGetLocationByFn accountID branchID id with
      | Some location ->
        Stdlib.Option.Option.Some(
          ProgramTypes.LocatedItem { entity = entity; location = location }
        )
      | None -> Stdlib.Option.Option.None
    | None -> Stdlib.Option.Option.None


module Search =
  let search
    (accountID: Stdlib.Option.Option<Uuid>)
    (branchID: Stdlib.Option.Option<Uuid>)
    (query: ProgramTypes.Search.SearchQuery)
    : ProgramTypes.Search.SearchResults =
    let searchResults = Builtin.pmSearch accountID branchID query

    ProgramTypes.Search.SearchResults
      { submodules = searchResults.submodules
        types = searchResults.types
        values = searchResults.values
        fns = searchResults.fns }

// CLEANUP: update this to a value rather than a function, once we have support for value records
let pm () : ProgramTypes.PackageManager.PackageManager =
  ProgramTypes.PackageManager.PackageManager
    { findType = PackageManager.Type.find
      findValue = PackageManager.Value.find
      findFn = PackageManager.Function.find

      getFn = PackageManager.Function.get
      getValue = PackageManager.Value.get
      getType = PackageManager.Type.get

      search = PackageManager.Search.search }