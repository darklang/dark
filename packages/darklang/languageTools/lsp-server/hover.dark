module Darklang.LanguageTools.LspServer.Hover


let getTextAtRange
  (text: String)
  (range: WrittenTypes.Range)
  : Stdlib.Option.Option<String> =
  let startLine = range.start.row
  let startColumn = range.start.column
  let endColumn = range.end_.column

  let lines = text |> Stdlib.String.split "\n"
  let textLines = lines |> Stdlib.List.getAt startLine

  match textLines with
  | Some line ->
    line
    |> Stdlib.String.slice startColumn endColumn
    |> Stdlib.Option.Option.Some

  | None -> Stdlib.Option.Option.None


let handleHoverRequest
  (state: LspState)
  (requestId: JsonRPC.RequestId)
  (params: LanguageServerProtocol.Hover.HoverRequest.HoverParams.HoverParams)
  : LspState =
  /// Find the document in scope
  match Stdlib.Dict.get state.documentsInScope params.textDocument.uri with
  | None ->
    log $"WARNING: document not found in scope for hover: {params.textDocument.uri}"

    // Send empty hover response
    let response =
      (JsonRPC.Response.Error.make
        (Stdlib.Option.Option.Some requestId)
        JsonRPC.Response.Error.KnownErrorCodes.internalError
        $"Document not found: {params.textDocument.uri}"
        Stdlib.Option.Option.None)
      |> Stdlib.AltJson.format

    logAndSendToClient response
    state

  | Some doc ->
    //get position
    let position = params.position

    /// Get the parsed document
    let parsed = doc |> (fun doc -> doc.parsed)

    let onMissing = LanguageTools.NameResolver.OnMissing.Allow
    let pm = LanguageTools.PackageManager.pm ()

    // Extract owner and modules from URI to provide correct parsing context
    let (owner, scriptName) =
      if Stdlib.String.startsWith params.textDocument.uri "darkfs:/" then
        let pathPart =
          // TODO: remove magic
          params.textDocument.uri
          |> Stdlib.String.dropFirst 8L // Remove "darkfs:/"
          |> Stdlib.String.dropLast 5L // Remove ".dark"

        if Stdlib.String.startsWith pathPart "script/" then
          ("LspHover", "")
        else
          let parts = Stdlib.String.split pathPart "."

          match parts with
          | [] -> ("LspHover", "")
          | [ owner ] -> (owner, "")
          | owner :: rest ->
            let moduleParts = Stdlib.List.dropLast rest
            let scriptName = Stdlib.String.join moduleParts "."
            (owner, scriptName)
      else
        ("LspHover", "")

    let pmWithExtras =
      match Parser.CliScript.pmWithExtras owner scriptName onMissing pm "" doc.text with
      | Ok pm -> pm
      | Error _ -> pm // fallback to original pm on error

    /// Find the node at the hover position, and get the hover information
    let currentModules =
      if scriptName == "" then [] else Stdlib.String.split scriptName "."

    let info =
      match parsed with
      | Ok(SourceFile s) ->
        let decls =
          HoverInformation.collectNodeHoverInfoAtPos
            s.declarations
            position
            pmWithExtras
            owner
            currentModules

        // First try to find a declaration at the position, then try to find expressions
        match decls with
        | Some _ -> decls
        | None ->
          s.exprsToEval
          |> Stdlib.List.filterMap (fun e ->
            HoverInformation.collectExpressionHoverInfoAtPos
              e
              position
              pmWithExtras
              owner
              currentModules)
          |> Stdlib.List.head

      | _ -> Stdlib.Option.Option.None


    /// Get the text, metadata, and description for the hover
    let (hoveringOn, metadata, description) =
      match info with
      | Some i ->
        let text =
          doc
          |> (fun doc -> doc.text)
          |> (fun text ->
            match getTextAtRange text i.range with
            | Some t -> t
            | None -> "something went wrong")

        let metadata =
          i.metadata |> Stdlib.Option.withDefault "No metadata available"

        let description =
          match i.description with
          | Some d -> "\n\nDescription: \n\n" ++ d
          | None -> "no description available"

        (text, metadata, description)

      | None -> ("", "No metadata available", "No description available") // TODO: remove this, we shouldn't show hover if there's no info


    // Create a hover response with Markdown content
    let hover =
      LanguageServerProtocol.Hover.Hover
        { contents =
            LanguageServerProtocol.MarkupContent
              { kind = LanguageServerProtocol.MarkupKind.Markdown
                value =
                  (HoverInformation.createCodeSnippet hoveringOn)
                  ++ "\n\n"
                  ++ metadata
                  ++ "\n\n"
                  ++ description }

          range = Stdlib.Option.Option.None }

    let response =
      hover
      |> LanguageServerProtocol.Hover.toJson
      |> (fun r ->
        JsonRPC.Response.Ok.make (Stdlib.Option.Option.Some requestId) r)
      |> Stdlib.AltJson.format

    logAndSendToClient response
    state