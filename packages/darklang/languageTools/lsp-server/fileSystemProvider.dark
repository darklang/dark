module Darklang =
  module LanguageTools =
    module LspServer =
      module FileSystemProvider =
        type FileType =
          | File
          | Directory
          | SymbolicLink

        type FileSystemErrorType =
          | FileNotFound
          | FileExists
          | FileNotADirectory
          | FileIsADirectory
          | NoPermissions
          | Unavailable
          | Other

        type FileSystemProviderClientCapabilities = { queryable: Bool }

        type URI = String

        module FileSystemProviderOptions =
          type FileSystemProviderOptions =
            { scheme: String
              caseSensitive: Bool
              readonly: Bool }

          let toJson (options: FileSystemProviderOptions) : Json =
            [ Stdlib.Option.Option.Some(("scheme", Json.String options.scheme))
              Stdlib.Option.Option.Some(
                ("caseSensitive", Json.Bool options.caseSensitive)
              )
              Stdlib.Option.Option.Some(("readonly", Json.Bool options.readonly)) ]
            |> Stdlib.Option.values
            |> Json.Object


        module ReadFile =
          let method = "fileSystem/read"

          module ReadFileParams =
            type ReadFileParams = { uri: URI }

            let fromJson
              (json: Json)
              : Stdlib.Result.Result<ReadFileParams, String> =
              match json with
              | Object fields ->
                match
                  Stdlib.List.findFirst fields (fun (key, _) -> key == "uri")
                with
                | Some((_, String uri)) ->
                  (ReadFileParams { uri = uri }) |> Stdlib.Result.Result.Ok
                | _ -> Stdlib.Result.Result.Error "Expected uri"
              | _ -> Stdlib.Result.Result.Error "Expected object"


          module ReadFileResponse =
            type ReadFileResponse = { content: String }

            let toJson (r: ReadFileResponse) : Json =
              [ Stdlib.Option.Option.Some(("content", Json.String r.content)) ]
              |> Stdlib.Option.values
              |> Json.Object


          let handleReadFileRequest
            (state: LspState)
            (requestId: JsonRPC.RequestId)
            (params: ReadFileParams.ReadFileParams)
            : LspState =
            // Remove the darklang:// prefix and the .dark suffix from the URI, (e.g.darklang://type/Darklang/Stdlib/Option/Option.dark)
            let uri =
              params.uri |> Stdlib.String.dropFirst 11L |> Stdlib.String.dropLast 5L

            let parts = uri |> Stdlib.String.split "/"

            let elementType = parts |> Stdlib.List.head |> Builtin.unwrap

            let nameForLookup =
              parts |> Stdlib.List.tail |> Builtin.unwrap |> Stdlib.String.join "."

            let pm = LanguageTools.PackageManager.pm ()
            // e.g.type/Darklang/Stdlib/Option/Option
            match elementType with
            | "type" ->
              let findType = pm.findType
              let getType = pm.getType

              match findType nameForLookup with
              | Some id ->
                let typ = getType id

                let prettyPrintedType =
                  match typ with
                  | Some typ -> typ |> PrettyPrinter.ProgramTypes.packageType

                  | None -> "Type not found"

                let responseJson =
                  (ReadFileResponse.ReadFileResponse { content = prettyPrintedType })
                  |> ReadFileResponse.toJson
                  |> (fun r ->
                    JsonRPC.Response.Ok.make
                      (Stdlib.Option.Option.Some(requestId))
                      r)
                  |> Stdlib.AltJson.format

                logAndSendToClient responseJson

                // send a showDocument request
                let showDocRequestString =
                  ShowDocument.makeShowDocumentRequest params.uri requestId

                logAndSendToClient showDocRequestString
                state

              | None ->
                let responseJson =
                  (ReadFileResponse.ReadFileResponse { content = "Type not found" })
                  |> ReadFileResponse.toJson
                  |> (fun r ->
                    JsonRPC.Response.Ok.make
                      (Stdlib.Option.Option.Some(requestId))
                      r)
                  |> Stdlib.AltJson.format

                logAndSendToClient responseJson

                // send a showDocument request (the content will be "Type not found")
                let showDocRequestString =
                  ShowDocument.makeShowDocumentRequest params.uri requestId

                logAndSendToClient showDocRequestString
                state

            // e.g. function/Darklang/Stdlib/Option/map
            | "function" ->
              let findFn = pm.findFn
              let getFn = pm.getFn

              match findFn nameForLookup with
              | Some id ->
                let fn = getFn id

                let prettyPrintedFn =
                  match fn with
                  | Some fn -> fn |> PrettyPrinter.ProgramTypes.packageFn

                  | None -> "Function not found"

                let responseJson =
                  (ReadFileResponse.ReadFileResponse { content = prettyPrintedFn })
                  |> ReadFileResponse.toJson
                  |> (fun r ->
                    JsonRPC.Response.Ok.make
                      (Stdlib.Option.Option.Some(requestId))
                      r)
                  |> Stdlib.AltJson.format

                logAndSendToClient responseJson

                // send a showDocument request
                let showDocRequestString =
                  ShowDocument.makeShowDocumentRequest params.uri requestId

                logAndSendToClient showDocRequestString
                state

              | None ->
                let responseJson =
                  (ReadFileResponse.ReadFileResponse
                    { content = "Function not found" })
                  |> ReadFileResponse.toJson
                  |> (fun r ->
                    JsonRPC.Response.Ok.make
                      (Stdlib.Option.Option.Some(requestId))
                      r)
                  |> Stdlib.AltJson.format

                logAndSendToClient responseJson

                // send a showDocument request
                let showDocRequestString =
                  ShowDocument.makeShowDocumentRequest params.uri requestId

                logAndSendToClient showDocRequestString
                state

            // e.g. constant/Darklang/Stdlib/List/empty
            | "constant" ->
              let findConst = pm.findConstant
              let getConst = pm.getConstant

              match findConst nameForLookup with
              | Some id ->
                let constant = getConst id

                let prettyPrintedConst =
                  match constant with
                  | Some constant ->
                    constant |> PrettyPrinter.ProgramTypes.packageConstant

                  | None -> "Constant not found"

                let responseJson =
                  (ReadFileResponse.ReadFileResponse { content = prettyPrintedConst })
                  |> ReadFileResponse.toJson
                  |> (fun r ->
                    JsonRPC.Response.Ok.make
                      (Stdlib.Option.Option.Some(requestId))
                      r)
                  |> Stdlib.AltJson.format

                logAndSendToClient responseJson

                // send a showDocument request
                let showDocRequestString =
                  ShowDocument.makeShowDocumentRequest params.uri requestId

                logAndSendToClient showDocRequestString
                state

              | None ->
                let responseJson =
                  (ReadFileResponse.ReadFileResponse
                    { content = "Constant not found" })
                  |> ReadFileResponse.toJson
                  |> (fun r ->
                    JsonRPC.Response.Ok.make
                      (Stdlib.Option.Option.Some(requestId))
                      r)
                  |> Stdlib.AltJson.format

                logAndSendToClient responseJson

                // send a showDocument request
                let showDocRequestString =
                  ShowDocument.makeShowDocumentRequest params.uri requestId

                logAndSendToClient showDocRequestString
                state

            | elem ->
              let responseJson =
                (ReadFileResponse.ReadFileResponse
                  { content = $"Unknown element {elem}" })
                |> ReadFileResponse.toJson
                |> (fun r ->
                  JsonRPC.Response.Ok.make (Stdlib.Option.Option.Some(requestId)) r)
                |> Stdlib.AltJson.format

              logAndSendToClient responseJson
              // send a showDocument request
              let showDocRequestString =
                ShowDocument.makeShowDocumentRequest params.uri requestId

              logAndSendToClient showDocRequestString

              state


        module WriteFile =
          let method = "fileSystem/write"

          module WriteFileOptions =
            type WriteFileOptions =
              {
                // If a new file should be created
                create: Bool
                // If a pre-existing file should be overwritten
                overwrite: Bool }

          module WriteFileParams =
            type WriteFileParams =
              {
                // The existing file
                uri: URI
                // The new content of the file `base64` encoded
                content: String
                // Options to define if missing files should or must be created
                options: WriteFileOptions.WriteFileOptions }


            let fromJson
              (json: Json)
              : Stdlib.Result.Result<WriteFileParams, String> =
              match json with
              | Object fields ->
                let uri =
                  match
                    Stdlib.List.findFirst fields (fun (key, _) -> key == "uri")
                  with
                  | Some((_, String uri)) -> Stdlib.Result.Result.Ok uri
                  | _ -> Stdlib.Result.Result.Error "Expected uri"

                let content =
                  match
                    Stdlib.List.findFirst fields (fun (key, _) -> key == "content")
                  with
                  | Some((_, String content)) -> Stdlib.Result.Result.Ok content
                  | _ -> Stdlib.Result.Result.Error "Expected content"

                let options =
                  match
                    Stdlib.List.findFirst fields (fun (key, _) -> key == "options")
                  with
                  | Some((_, Object options)) ->
                    let create =
                      match
                        Stdlib.List.findFirst options (fun (key, _) ->
                          key == "create")
                      with
                      | Some((_, Bool create)) -> Stdlib.Result.Result.Ok create
                      | _ -> Stdlib.Result.Result.Error "Expected create option"

                    let overwrite =
                      match
                        Stdlib.List.findFirst options (fun (key, _) ->
                          key == "overwrite")
                      with
                      | Some((_, Bool overwrite)) ->
                        Stdlib.Result.Result.Ok overwrite
                      | _ -> Stdlib.Result.Result.Error "Expected overwrite option"

                    match (create, overwrite) with
                    | (Ok create, Ok overwrite) ->
                      (WriteFileOptions.WriteFileOptions
                        { create = create
                          overwrite = overwrite })
                      |> Stdlib.Result.Result.Ok
                    | _ -> Stdlib.Result.Result.Error "Invalid options"
                  | _ -> Stdlib.Result.Result.Error "Expected options object"

                match (uri, content, options) with
                | (Ok uri, Ok content, Ok options) ->
                  (WriteFileParams
                    { uri = uri
                      content = content
                      options = options })
                  |> Stdlib.Result.Result.Ok
                | _ -> Stdlib.Result.Result.Error "Invalid params"
              | _ -> Stdlib.Result.Result.Error "Expected object"


          let handleWriteFileRequest
            (state: LspState)
            (requestId: JsonRPC.RequestId)
            (params: WriteFileParams.WriteFileParams)
            : LspState =
            let responseJson =
              (JsonRPC.Response.Ok.make
                (Stdlib.Option.Option.Some(requestId))
                (Json.String "TODO: parse and create an edit for the file"))
              |> Stdlib.AltJson.format

            logAndSendToClient responseJson
            state


        module FileChange =
          type DidChangeFileParams = { changes: List<FileChangeEvent> }

          type FileChangeType =
            | Changed
            | Created
            | Deleted

          let encodeFileChangeType (t: FileChangeType) : Int64 =
            match t with
            | Changed -> 1L
            | Created -> 2L
            | Deleted -> 3L

          type FileChangeEvent = { uri: URI; typ: FileChangeType }


        module Delete =
          let method = "fileSystem/delete"

          module DeleteFileOptions =
            type DeleteFileOptions =
              {
                /// Delete the content recursively if a folder is denoted
                recursive: Bool
              }

          module DeleteFileParams =
            type DeleteFileParams =
              {
                /// The uri of the file or folder to delete
                uri: URI
                /// Defines if deletion of folders is recursive
                options: DeleteFileOptions.DeleteFileOptions
              }

            let fromJson
              (json: Json)
              : Stdlib.Result.Result<DeleteFileParams, String> =
              match json with
              | Object fields ->
                let uri =
                  match
                    Stdlib.List.findFirst fields (fun (key, _) -> key == "uri")
                  with
                  | Some((_, String uri)) -> Stdlib.Result.Result.Ok uri
                  | _ -> Stdlib.Result.Result.Error "Expected uri"

                let options =
                  match
                    Stdlib.List.findFirst fields (fun (key, _) -> key == "options")
                  with
                  | Some((_, Object options)) ->
                    let recursive =
                      match
                        Stdlib.List.findFirst options (fun (key, _) ->
                          key == "recursive")
                      with
                      | Some((_, Bool recursive)) ->
                        Stdlib.Result.Result.Ok recursive
                      | _ -> Stdlib.Result.Result.Error "Expected recursive option"

                    match recursive with
                    | Ok recursive ->
                      (DeleteFileOptions.DeleteFileOptions { recursive = recursive })
                      |> Stdlib.Result.Result.Ok
                    | _ -> Stdlib.Result.Result.Error "Invalid options"
                  | _ -> Stdlib.Result.Result.Error "Expected options object"

                match (uri, options) with
                | (Ok uri, Ok options) ->
                  (DeleteFileParams { uri = uri, options = options })
                  |> Stdlib.Result.Result.Ok
                | _ -> Stdlib.Result.Result.Error "Invalid params"
              | _ -> Stdlib.Result.Result.Error "Expected object"


        module Rename =
          let method = "fileSystem/rename"

          module RenameFileOptions =
            type RenameFileOptions =
              {
                /// Overwrite the file if it does exist
                overwrite: Bool
              }

          module RenameFileParams =
            type RenameFileParams =
              {
                /// The existing file
                oldUri: URI
                /// The new location
                newUri: URI
                /// Defines if existing files should be overwritten
                options: RenameFileOptions.RenameFileOptions
              }




// types borrowed from https://github.com/NTaylorMullen/LSPVirtualDocuments/blob/master/Documents/FileSystemSpec.md
// /**
//  * Enumeration of file types. The types `File` and `Directory` can also be
//  * a symbolic links, in that case use `FileType.File | FileType.SymbolicLink` and
//  * `FileType.Directory | FileType.SymbolicLink`.
//  */
// export namespace FileType {
//     /**
//      * The file type is unknown.
//      */
//     export const Unknown = 0;

//     /**
//      * A regular file.
//      */
//     export const File = 1;

//     /**
//      * A directory.
//      */
//     export const Directory = 2;

//     /**
//      * A symbolic link to a file or folder
//      */
//     export const Symbolic = 64;
// }

// export namespace FileSystemErrorType {
//     /**
//      * An error to signal that a file or folder wasn't found.
//      */
//     export const FileNotFound = 0;

//     /**
//      * An error to signal that a file or folder already exists, e.g. when creating but not overwriting a file.
//      */
//     export const FileExists = 1;

//     /**
//      * An error to signal that a file is not a folder.
//      */
//     export const FileNotADirectory = 2;

//     /**
//      * An error to signal that a file is a folder.
//      */
//     export const FileIsADirectory = 3;

//     /**
//      * An error to signal that an operation lacks required permissions.
//      */
//     export const NoPermissions = 4;

//     /**
//      * An error to signal that the file system is unavailable or too busy to complete a request.
//      */
//     export const Unavailable = 5;

//     /**
//      * A custom error.
//      */
//     export const Other = 1000;
// }


// /**
//  * Client capabilities specific to file system providers
//  */
// export interface FileSystemProviderClientCapabilities {
//     /**
//      * Whether or not the file system features are queryable.
//      */
//     queryable?: boolean;
// }


// /**
//  * Server capabilities specific to file system providers
//  */
// export interface FileSystemProviderOptions {
//     /**
//      * The uri-scheme the provider registers for
//      */
//     scheme: string;

//     /**
//      * Whether or not the file system is case sensitive.
//      */
//     caseSensitive?: boolean;

//     /**
//      * Whether or not the file system is readonly.
//      */
//     readonly?: boolean
// }


// Registration Options

// export interface FileSystemProviderRegistrationOptions extends FileSystemProviderOptions {
// }


// /**
//  * An event to signal that a resource has been created, changed, or deleted. This
//  * event should fire for resources that are being [watched](#FileSystemProvider.watch)
//  * by clients of this provider.
//  *
//  * *Note:* It is important that the metadata of the file that changed provides an
//  * updated `mtime` that advanced from the previous value in the [stat](#FileStat) and a
//  * correct `size` value. Otherwise there may be optimizations in place that will not show
//  * the change in an editor for example.
//  */
// export interface DidChangeFileParams {
//     /**
//      * The change events.'
//      */
//     changes: FileChangeEvent[];
// }

// /**
//  * The event filesystem providers must use to signal a file change.
//  */
// export interface FileChangeEvent {
//     /**
//      * The type of change.
//      */
//     uri: URI;

//     /**
//      * The uri of the file that has changed.
//      */
//     type: FileChangeType
// }

// /**
//  * Enumeration of file change types.
//  */
// export namespace FileChangeType {
//     /**
//      * The contents or metadata of a file have changed.
//      */
//     export const Changed = 1;

//     /**
//      * A file has been created.
//      */
//     export const Created = 2;

//     /**
//      * A file has been deleted.
//      */
//     export const Deleted = 3;
// }


// export interface StartWatchingParams {
//     /**
//      * The uri of the file or folder to be watched.
//      */
//     uri: URI;

//     /**
//      * The subscription ID to be used in order to stop watching the provided file or folder uri via the [StopWatching](#stopWatching) notification.
//      */
//     subscriptionId: string;

//     /**
//      * Configures the watch
//      */
//     options: WatchFileOptions
// }

// export interface WatchFileOptions {
//     /**
//      * If a folder should be recursively subscribed to
//      */
//     recursive: boolean;

//     /**
//      * Folders or files to exclude from being watched.
//      */
//     excludes: string[];
// }


// /**
//  * A notification to signal an unsubscribe from a corresponding [start watching](#startWatching) request.
//  */
// export interface StopWatchingParams {
//     /**
//      * The subscription id.
//      */
//     subscriptionId: string;
// }


// export interface FileStatParams {
//     /**
//      * The uri to retrieve metadata about.
//      */
//     uri: URI;
// }

// export interface FileStatResponse {
//     /**
//      * The type of the file, e.g. is a regular file, a directory, or symbolic link
//      * to a file/directory.
//      *
//      * *Note:* This value might be a bitmask, e.g. `FileType.File | FileType.SymbolicLink`.
//      */
//     type: FileType;

//     /**
//      * The creation timestamp in milliseconds elapsed since January 1, 1970 00:00:00 UTC.
//      */
//     ctime: number;

//     /**
//      * The modification timestamp in milliseconds elapsed since January 1, 1970 00:00:00 UTC.
//      *
//      * *Note:* If the file changed, it is important to provide an updated `mtime` that advanced
//      * from the previous value. Otherwise there may be optimizations in place that will not show
//      * the updated file contents in an editor for example.
//      */
//     mtime: number;

//     /**
//      * The size in bytes.
//      *
//      * *Note:* If the file changed, it is important to provide an updated `size`. Otherwise there
//      * may be optimizations in place that will not show the updated file contents in an editor for
//      * example.
//      */
//     size: number;
// }


// export interface ReadDirectoryParams {
//     /**
//      * The uri of the folder.
//      */
//     uri: URI;
// }

// export interface ReadDirectoryResponse {
//     /**
//      * An array of nodes that represent the directories children.
//      */
//     children: DirectoryChild[]
// }

// /**
//  * A name/type item that represents a directory child node.
//  */
// export interface DirectoryChild {
//     /**
//      * The name of the node, e.g. a filename or directory name.
//      */
//     name: string;

//     /**
//      * The type of the file, e.g. is a regular file, a directory, or symbolic link to a file/directory.
//      *
//      * *Note:* This value might be a bitmask, e.g. `FileType.File | FileType.SymbolicLink`.
//      */
//     type: FileType;
// }


// export interface CreateDirectoryParams {
//     /**
//      * The uri of the folder
//      */
//     uri: URI;
// }

// export interface ReadFileParams {
//     /**
//      * The uri of the folder
//      */
//     uri: URI;
// }

// export interface ReadFileResponse {
//     /**
//      * The entire contents of the file `base64` encoded.
//      */
//     content: string;
// }


// export interface WriteFileParams {
//     /**
//      * The uri of the file to write
//      */
//     uri: URI;

//     /**
//      * The new content of the file `base64` encoded.
//      */
//     content: string;

//     /**
//      * Options to define if missing files should or must be created.
//      */
//     options: WriteFileOptions
// }

// export interface WriteFileOptions {
//     /**
//      * If a new file should be created.
//      */
//     create: boolean;

//     /**
//      * If a pre-existing file should be overwritten.
//      */
//     overwrite: boolean;
// }


// export interface DeleteFileParams {
//     /**
//      * The uri of the file or folder to delete
//      */
//     uri: URI;

//     /**
//      * Defines if deletion of folders is recursive.
//      */
//     options: DeleteFileOptions
// }

// export interface DeleteFileOptions {
//     /**
//      * If a folder should be recursively deleted.
//      */
//     recursive: boolean;
// }


// export interface RenameFileParams {
//     /**
//      * The existing file.
//      */
//     oldUri: URI;

//     /**
//      * The new location.
//      */
//     newUri: URI;

//     /**
//      * Defines if existing files should be overwritten.
//      */
//     options: RenameFileOptions
// }

// export interface RenameFileOptions {
//     /**
//      * If existing files should be overwritten.
//      */
//     overwrite: boolean;
// }