module Darklang.LanguageTools.LspServer.FileSystemProvider


module ReadFile =
  let sendResponse
    (state: LspState)
    (requestId: JsonRPC.RequestId)
    (content: String)
    : LspState =
    let responseJson =
      (LspExtension.FileSystemProvider.ReadFile.ReadFileResponse.ReadFileResponse
        { content = content })
      |> LspExtension.FileSystemProvider.ReadFile.ReadFileResponse.toJson
      |> (fun r ->
        JsonRPC.Response.Ok.make (Stdlib.Option.Option.Some(requestId)) r)
      |> Stdlib.AltJson.format

    logAndSendToClient responseJson
    state


  let handleReadFileRequest
    (state: LspState)
    (requestId: JsonRPC.RequestId)
    (params:
      LspExtension.FileSystemProvider.ReadFile.ReadFileParams.ReadFileParams)
    : LspState =

    // CLEANUP: make the 'remove scheme part of URI' more universal. Maybe be add it to Stdlib eg.`Stdlib.Uri.removeScheme`
    let nameForLookup =
      // TODO: remove magic
      params.uri
      |> Stdlib.String.dropFirst 8L  // Drop "darkfs:/"
      |> Stdlib.String.dropLast 5L   // Drop ".dark"

    let location =
      ProgramTypes.parsePackageLocation nameForLookup


    let getContent =
      // Check if this is a script request
      if Stdlib.String.startsWith nameForLookup "script/" then
        let scriptName =
          nameForLookup
          |> Stdlib.String.dropFirst 7L  // Drop "script/"

        match Builtin.pmScriptsGet scriptName with
        | Some script -> script.text
        | None -> $"Script not found: {scriptName}"
      else
        // Handle package entities
        let pm = LanguageTools.PackageManager.pm ()

        // Try to find as a specific entity (type, function, or value)
        let entityContent =
          match pm.findType location with
          | Some id ->
            match pm.getType id with
            | Some typ ->
              (PrettyPrinter.ProgramTypes.packageType typ)
              |> Stdlib.Option.Option.Some
            | None -> Stdlib.Option.Option.None

          | None ->
            let ctx =
              PrettyPrinter.ProgramTypes.Context
                { currentModule = Stdlib.Option.Option.None
                  currentFunction = Stdlib.Option.Option.None }

            match pm.findFn location with
            | Some id ->
              match pm.getFn id with
              | Some fn ->
                (PrettyPrinter.ProgramTypes.packageFn ctx fn)
                |> Stdlib.Option.Option.Some
              | None -> Stdlib.Option.Option.None

            | None ->
              match pm.findValue location with
              | Some id ->
                match pm.getValue id with
                | Some value ->
                  (PrettyPrinter.ProgramTypes.packageValue ctx value)
                  |> Stdlib.Option.Option.Some
                | None -> Stdlib.Option.Option.None

              | None -> Stdlib.Option.Option.None

        match entityContent with
        | Some content -> content
        | None ->
          // Not a specific entity, treat as a module
          let modulePath = nameForLookup |> Stdlib.String.split "."

          // Search for all entities in this module
          let searchQuery =
            LanguageTools.ProgramTypes.Search.SearchQuery
              { currentModule = modulePath
                text = ""
                searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.AllDescendants
                entityTypes = []
                exactMatch = false }

          let ctx =
            PrettyPrinter.ProgramTypes.Context
              { currentModule = Stdlib.Option.Option.None
                currentFunction = Stdlib.Option.Option.None }

          let results =
            LanguageTools.PackageManager.Search.search searchQuery

          let definitions =
            LanguageTools.ProgramTypes.Definitions
              { types = results.types |> Stdlib.List.map (fun found -> found.entity)
                fns = results.fns |> Stdlib.List.map (fun found -> found.entity)
                values = results.values |> Stdlib.List.map (fun found -> found.entity)
                exprs = [] }

          let modules =
            PrettyPrinter.ModuleDeclaration.toModules definitions

          match Stdlib.List.head modules with
          | Some rootModule -> PrettyPrinter.moduleDeclaration ctx rootModule
          | None -> $"// No definitions found in {nameForLookup}"

    sendResponse state requestId getContent


module WriteFile =
  // Extract module name from a module_decl node
  let getModuleName (node: LanguageTools.Parser.ParsedNode) : String =
    // A module_decl has children: keyword, identifier, equals, body
    // Find the identifier child
    let identifierNode =
      node.children
      |> Stdlib.List.findFirst (fun child ->
        child.typ == "module_identifier")

    match identifierNode with
    | Some id -> id.text
    | None -> ""


  // Remove the prefix from a module path if it matches
  let stripModulePrefix
    (prefix: List<String>)
    (path: List<String>)
    : List<String> =
    match (prefix, path) with
    | ([], rest) -> rest
    | (p :: pRest, m :: mRest) ->
      if p == m then
        WriteFile.stripModulePrefix pRest mRest
      else
        path
    | _ -> path


  // Recursively find all declarations with their module path
  // Returns list of (extraModules, declaration) where extraModules are the modules beyond the base path
  let findDeclsWithPath
    (nodeType: String)
    (currentExtraModules: List<String>)
    (node: LanguageTools.Parser.ParsedNode)
    : List<List<String> * LanguageTools.Parser.ParsedNode> =
    if node.typ == nodeType then
      [ (currentExtraModules, node) ]

    else
      if node.typ == "module_decl" then
        let moduleName = WriteFile.getModuleName node
        let newPath = Stdlib.List.append currentExtraModules [ moduleName ]

        node.children
        |> Stdlib.List.map (fun child -> WriteFile.findDeclsWithPath nodeType newPath child)
        |> Stdlib.List.flatten

      else
        node.children
        |> Stdlib.List.map (fun child ->
          WriteFile.findDeclsWithPath nodeType currentExtraModules child)
        |> Stdlib.List.flatten


  let sendSuccessResponse
    (state: LspState)
    (requestId: JsonRPC.RequestId)
    (ops: List<LanguageTools.ProgramTypes.PackageOp>)
    (updatedContent: Stdlib.Option.Option<String>)
    : LspState =
    let opsJson =
      ops
      |> Stdlib.List.map (fun op ->
        Json.String (Builtin.jsonSerialize<LanguageTools.ProgramTypes.PackageOp> op))
      |> Json.Array

    let contentJson =
      match updatedContent with
      | Some content -> Json.String content
      | None -> Json.Null

    let responseJson =
      (JsonRPC.Response.Ok.make
        (Stdlib.Option.Option.Some(requestId))
        (Json.Object
          [ ("success", Json.Bool true)
            ("ops", opsJson)
            ("updatedContent", contentJson)
            ("errors", Json.Array []) ]))
      |> Stdlib.AltJson.format

    logAndSendToClient responseJson
    state


  let sendErrorResponse
    (state: LspState)
    (requestId: JsonRPC.RequestId)
    (errors: List<String>)
    : LspState =
    let errorsJson = errors |> Stdlib.List.map (fun e -> Json.String e) |> Json.Array

    let responseJson =
      (JsonRPC.Response.Ok.make
        (Stdlib.Option.Option.Some(requestId))
        (Json.Object
          [ ("success", Json.Bool false)
            ("ops", Json.Array [])
            ("errors", errorsJson) ]))
      |> Stdlib.AltJson.format

    logAndSendToClient responseJson
    state


  let handleWriteFileRequest
    (state: LspState)
    (requestId: JsonRPC.RequestId)
    (params:
      LspExtension.FileSystemProvider.WriteFile.WriteFileParams.WriteFileParams)
    : LspState =
    let content = params.content

    // Check if this is a script write request
    let nameForLookup =
      // TODO: remove magic
      params.uri
      |> Stdlib.String.dropFirst 8L  // Drop "darkfs:/"
      |> Stdlib.String.dropLast 5L   // Drop ".dark"

    if Stdlib.String.startsWith nameForLookup "script/" then
      let scriptName =
        nameForLookup
        |> Stdlib.String.dropFirst 7L  // Drop "script/"

      // Update the script content
      match Builtin.pmScriptsUpdate scriptName content with
      | Ok () -> sendSuccessResponse state requestId [] Stdlib.Option.Option.None
      | Error err -> sendErrorResponse state requestId [ err ]
    else
      // Parse package module content
      let tree = LanguageTools.Parser.parseToSimplifiedTree content

      // Find all type, function, and value declarations with their module paths
      let typeDeclsWithPath = WriteFile.findDeclsWithPath "type_decl" [] tree
      let fnDeclsWithPath = WriteFile.findDeclsWithPath "fn_decl" [] tree
      let valDeclsWithPath = WriteFile.findDeclsWithPath "val_decl" [] tree

      // Parse declarations, keeping track of their module paths
      let parsedTypes =
        typeDeclsWithPath
        |> Stdlib.List.map (fun (extraModules, node) ->
          let parsed = LanguageTools.Parser.TypeDeclaration.parse node
          (extraModules, parsed))

      let parsedFns =
        fnDeclsWithPath
        |> Stdlib.List.map (fun (extraModules, node) ->
          let parsed = LanguageTools.Parser.FunctionDeclaration.parse node
          (extraModules, parsed))

      let parsedVals =
        valDeclsWithPath
        |> Stdlib.List.map (fun (extraModules, node) ->
          let parsed = LanguageTools.Parser.ValueDeclaration.parse node
          (extraModules, parsed))

      // Extract error messages from each declaration type
      let typeErrors =
        parsedTypes
        |> Stdlib.List.filterMap (fun (_extraModules, result) ->
          match result with
          | Error unparseable ->
            Stdlib.Option.Option.Some(
              $"Type parse error at {unparseable.source.range.start.row}:{unparseable.source.range.start.column}"
            )
          | Ok _ -> Stdlib.Option.Option.None)

      let fnErrors =
        parsedFns
        |> Stdlib.List.filterMap (fun (_extraModules, result) ->
          match result with
          | Error unparseable ->
            Stdlib.Option.Option.Some(
              $"Function parse error at {unparseable.source.range.start.row}:{unparseable.source.range.start.column}"
            )
          | Ok _ -> Stdlib.Option.Option.None)

      let valErrors =
        parsedVals
        |> Stdlib.List.filterMap (fun (_extraModules, result) ->
          match result with
          | Error unparseable ->
            Stdlib.Option.Option.Some(
              $"Value parse error at {unparseable.source.range.start.row}:{unparseable.source.range.start.column}"
            )
          | Ok _ -> Stdlib.Option.Option.None)

      let allErrors =
        Stdlib.List.append
          typeErrors
          (Stdlib.List.append fnErrors valErrors)

      if (Stdlib.List.isEmpty allErrors) |> Stdlib.Bool.not then
        sendErrorResponse state requestId allErrors
      else
        // Convert parsed declarations to PackageOps, but only for NEW items
        let parts = Stdlib.String.split nameForLookup "."

        let owner =
          match parts with
          | owner :: _rest -> owner
          | _ -> ""

        let pm = LanguageTools.PackageManager.pm ()

        // Process types
        let typeOps =
          parsedTypes
          |> Stdlib.List.map (fun (extraModules, result) ->
            match result with
            | Ok typeDecl ->
              let modules =
                match extraModules with
                | _owner :: rest -> rest
                | _ -> []

              let typeLocation =
                (LanguageTools.ProgramTypes.PackageLocation
                  { owner = owner
                    modules = modules
                    name = typeDecl.name.name })

              let existingTypeId = pm.findType typeLocation

              match existingTypeId with
              | Some _id -> []
              | None ->
                let (packageType, _unresolvedNames) =
                  LanguageTools.WrittenTypesToProgramTypes.TypeDeclaration.toPackageTypePT
                    LanguageTools.NameResolver.OnMissing.Allow
                    pm
                    owner
                    modules
                    typeDecl

                [ LanguageTools.ProgramTypes.PackageOp.AddType packageType
                  LanguageTools.ProgramTypes.PackageOp.SetTypeName (packageType.id, typeLocation) ]
            | Error _ -> [])
          |> Stdlib.List.flatten

        // Process functions
        let fnOps =
          parsedFns
          |> Stdlib.List.map (fun (extraModules, result) ->
            match result with
            | Ok fnDecl ->
              // extraModules contains the full path, strip the owner to get modules
              let modules =
                match extraModules with
                | _owner :: rest -> rest
                | _ -> []

              let fnLocation =
                (LanguageTools.ProgramTypes.PackageLocation
                  { owner = owner
                    modules = modules
                    name = fnDecl.name.name })

              let existingFnId = pm.findFn fnLocation

              match existingFnId with
              | Some _id -> []
              | None ->
                let (packageFn, _unresolvedNames) =
                  LanguageTools.WrittenTypesToProgramTypes.FunctionDeclaration.toPackageFnPT
                    LanguageTools.NameResolver.OnMissing.Allow
                    pm
                    owner
                    modules
                    fnDecl

                [ LanguageTools.ProgramTypes.PackageOp.AddFn packageFn
                  LanguageTools.ProgramTypes.PackageOp.SetFnName (packageFn.id, fnLocation) ]
            | Error _ -> [])
          |> Stdlib.List.flatten

        // Process values
        let valueOps =
          parsedVals
          |> Stdlib.List.map (fun (extraModules, result) ->
            match result with
            | Ok valDecl ->
              // extraModules contains the full path, strip the owner to get modules
              let modules =
                match extraModules with
                | _owner :: rest -> rest
                | _ -> []

              let valLocation =
                (LanguageTools.ProgramTypes.PackageLocation
                  { owner = owner
                    modules = modules
                    name = valDecl.name.name })

              let existingValId = pm.findValue valLocation

              match existingValId with
              | Some _id -> []
              | None ->
                let (packageValue, _unresolvedNames) =
                  LanguageTools.WrittenTypesToProgramTypes.ValueDeclaration.toPackageValuePT
                    LanguageTools.NameResolver.OnMissing.Allow
                    pm
                    owner
                    modules
                    valDecl

                [ LanguageTools.ProgramTypes.PackageOp.AddValue packageValue
                  LanguageTools.ProgramTypes.PackageOp.SetValueName (packageValue.id, valLocation) ]
            | Error _ -> [])
          |> Stdlib.List.flatten

        // Combine all ops
        let allOps =
          Stdlib.List.append
            typeOps
            (Stdlib.List.append fnOps valueOps)

        // Only add ops if there are new items (added as WIP)
        let addResult =
          if (Stdlib.List.isEmpty allOps) |> Stdlib.Bool.not then
            SCM.PackageOps.add allOps
          else
            Stdlib.Result.Result.Ok 0L

        match addResult with
        | Error err ->
          sendErrorResponse state requestId [ $"Failed to add package ops: {err}" ]
        | Ok _ ->
          // If ops were added, re-read the content from database to get the version with IDs
          let updatedContent =
            if (Stdlib.List.isEmpty allOps) |> Stdlib.Bool.not then
              // Re-read from package manager to get content with assigned IDs
              let pm = LanguageTools.PackageManager.pm ()
              let location = ProgramTypes.parsePackageLocation nameForLookup

              // Build the content from database (same logic as ReadFile)
              let modulePath = nameForLookup |> Stdlib.String.split "."
              let searchQuery =
                LanguageTools.ProgramTypes.Search.SearchQuery
                  { currentModule = modulePath
                    text = ""
                    searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.AllDescendants
                    entityTypes = []
                    exactMatch = false }

              let ctx =
                PrettyPrinter.ProgramTypes.Context
                  { currentModule = Stdlib.Option.Option.None
                    currentFunction = Stdlib.Option.Option.None }

              let results =
                LanguageTools.PackageManager.Search.search searchQuery

              let definitions =
                LanguageTools.ProgramTypes.Definitions
                  { types = results.types |> Stdlib.List.map (fun found -> found.entity)
                    fns = results.fns |> Stdlib.List.map (fun found -> found.entity)
                    values = results.values |> Stdlib.List.map (fun found -> found.entity)
                    exprs = [] }

              let modules =
                PrettyPrinter.ModuleDeclaration.toModules definitions

              (match Stdlib.List.head modules with
              | Some rootModule -> PrettyPrinter.moduleDeclaration ctx rootModule
              | None -> $"// No definitions found in {nameForLookup}")
              |> Stdlib.Option.Option.Some
            else
              Stdlib.Option.Option.None

          sendSuccessResponse state requestId allOps updatedContent