module Darklang.LanguageTools.LspServer.TreeView


// <aliases>
type TreeItemType = VSCode.TreeView.TreeItemType.TreeItemType

type TreeItemCollapsibleState =
  VSCode.TreeView.TreeItemCollapsibleState.TreeItemCollapsibleState

type TreeItem = VSCode.TreeView.TreeItem.TreeItem
// </aliases>


let makeTreeItem
  (id: String)
  (label: String)
  (collapsibleState: TreeItemCollapsibleState)
  (contextValue: Stdlib.Option.Option<String>)
  : TreeItem =
  TreeItem
    { id = Stdlib.Option.Option.Some id
      label =
        Stdlib.Option.Option.Some(
          VSCode.TreeView.TreeItem.Label.Label.String label
        )
      collapsibleState = collapsibleState |> Stdlib.Option.Option.Some
      command = Stdlib.Option.Option.None //command to open the package
      contextValue = contextValue
      checkboxState = Stdlib.Option.Option.None
      accessibilityInformation = Stdlib.Option.Option.None
      description = Stdlib.Option.Option.None // could include metadata about package, author, etc.
      iconPath = Stdlib.Option.Option.None // based on whether it's a module, type, value, or fn (or later: other things, like http endpoint)
      resourceUri = Stdlib.Option.Option.None // URI of the package
      tooltip = Stdlib.Option.Option.None }


/// Helper to send a tree view response
let sendTreeViewResponse
  (requestID: JsonRPC.RequestId)
  (treeItems: List<TreeItem>)
  : Unit =
  let result =
    treeItems
    |> Stdlib.List.map VSCode.TreeView.TreeItem.toJson
    |> Json.Array

  let responseJson =
    let requestID = Stdlib.Option.Option.Some requestID
    (JsonRPC.Response.Ok.make requestID result)
    |> Stdlib.AltJson.format

  logAndSendToClient responseJson


/// handles `darklang/getRootNodes` requests
let handleGetRootNodesRequest
  (state: LspState)
  (requestID: JsonRPC.RequestId)
  : LspState =
  // TODO: this should be the list of packages that you have access to
  // - the `darklang` package
  // - (future: other globally-accessible packages)
  //   (anything that you've 'pinned' or whatever)
  // - your account's packages (for me, `stachu`)
  // - packages shared with you
  let treeItems =
    [ makeTreeItem "Darklang" "Darklang" TreeItemCollapsibleState.Collapsed Stdlib.Option.Option.None
      makeTreeItem "Stachu" "Stachu" TreeItemCollapsibleState.Collapsed Stdlib.Option.Option.None
      makeTreeItem "Scripts" "Scripts" TreeItemCollapsibleState.Collapsed Stdlib.Option.Option.None ]

  sendTreeViewResponse requestID treeItems

  state


/// Checks if a module path is a parent of another module path
// e.g. `["Darklang", "Stdlib"]` is a parent of `["Darklang", "Stdlib", "Int8"]`
let isModuleParentOf (parentPath: List<String>) (childPath: List<String>) : Bool =
  let parentPathLength = Stdlib.List.length parentPath
  let childPathLength = Stdlib.List.length childPath

  if parentPathLength > childPathLength then false
  else Stdlib.List.take childPath parentPathLength == parentPath


/// Helper to create tree items for entities (fns, types, values)
let makeEntityTreeItems
  (entities: List<ProgramTypes.LocatedItem<'a>>)
  (currentPath: List<String>)
  (entityType: String)
  : List<TreeItem> =
  entities
  |> Stdlib.List.filter (fun item ->
    let modules = Stdlib.List.push item.location.modules item.location.owner
    modules == currentPath)
  |> Stdlib.List.map (fun item ->
    let id = PrettyPrinter.ProgramTypes.PackageLocation.packageLocation item.location
    makeTreeItem id item.location.name TreeItemCollapsibleState.None (Stdlib.Option.Option.Some $"{entityType}:{id}"))


let buildTreeItems
  (results: ProgramTypes.Search.SearchResults)
  (currentPath: List<String>)
  (nodeId: String)
  : List<TreeItem> =
  let currentDepth = Stdlib.List.length currentPath

  let submodules =
    results.submodules
    |> Stdlib.List.filter (fun modulePath ->
      (Stdlib.List.length modulePath == currentDepth + 1L) &&
      isModuleParentOf currentPath modulePath)
    |> Stdlib.List.map (fun modulePath ->
      match Stdlib.List.last modulePath with
      | Some lastPart -> lastPart
      | None -> "")
    |> Stdlib.List.filter (fun name -> name != "")
    |> Stdlib.List.unique
    |> Stdlib.List.map (fun childName ->
      let childId = $"{nodeId}.{childName}"
      makeTreeItem childId childName TreeItemCollapsibleState.Collapsed Stdlib.Option.Option.None)

  let fnItems = makeEntityTreeItems results.fns currentPath "fn"
  let typeItems = makeEntityTreeItems results.types currentPath "type"
  let valueItems = makeEntityTreeItems results.values currentPath "value"

  (Stdlib.List.flatten [submodules; fnItems; typeItems; valueItems])
  |> Stdlib.List.uniqueBy (fun item ->
    match item.id with
    | Some id -> id
    | None -> "")


let handleGetChildNodesRequest
  (state: LspState)
  (requestID: JsonRPC.RequestId)
  (nodeId: String)
  : LspState =
  let treeItems =
    if nodeId == "Scripts" then
      // Handle Scripts node - show all stored scripts
      let scripts = Builtin.pmScriptsList ()
      scripts
      |> Stdlib.List.map (fun script ->
        let scriptId = $"script/{script.name}"
        makeTreeItem scriptId script.name TreeItemCollapsibleState.None (Stdlib.Option.Option.Some scriptId))
    else
      // Handle package nodes
      let currentPath = nodeId |> Stdlib.String.split "."

      let searchQuery =
        ProgramTypes.Search.SearchQuery
          { currentModule = currentPath
            text = ""
            searchDepth = ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
            entityTypes = [
              ProgramTypes.Search.EntityType.Module
              ProgramTypes.Search.EntityType.Fn
              ProgramTypes.Search.EntityType.Type
              ProgramTypes.Search.EntityType.Value
            ]
            exactMatch = false }

      let searchResults =
        PackageManager.Search.search state.branchID searchQuery
      buildTreeItems searchResults currentPath nodeId

  sendTreeViewResponse requestID treeItems
  state