module Darklang.LanguageTools.LspServer.TreeView


// <aliases>
type TreeItemType = VSCode.TreeView.TreeItemType.TreeItemType

type TreeItemCollapsibleState =
  VSCode.TreeView.TreeItemCollapsibleState.TreeItemCollapsibleState

type TreeItem = VSCode.TreeView.TreeItem.TreeItem
// </aliases>


let makeTreeItem
  (id: String)
  (label: String)
  (collapsibleState: TreeItemCollapsibleState)
  (contextValue: Stdlib.Option.Option<String>)
  : TreeItem =
  TreeItem
    { id = Stdlib.Option.Option.Some id
      label =
        Stdlib.Option.Option.Some(
          VSCode.TreeView.TreeItem.Label.Label.String label
        )
      collapsibleState = collapsibleState |> Stdlib.Option.Option.Some
      command = Stdlib.Option.Option.None //command to open the package
      contextValue = contextValue
      checkboxState = Stdlib.Option.Option.None
      accessibilityInformation = Stdlib.Option.Option.None
      description = Stdlib.Option.Option.None // could include metadata about package, author, etc.
      iconPath = Stdlib.Option.Option.None // based on whether it's a module, type, value, or fn (or later: other things, like http endpoint)
      resourceUri = Stdlib.Option.Option.None // URI of the package
      tooltip = Stdlib.Option.Option.None }


/// Helper to send a tree view response
let sendTreeViewResponse
  (requestID: JsonRPC.RequestId)
  (treeItems: List<TreeItem>)
  : Unit =
  let result =
    treeItems
    |> Stdlib.List.map VSCode.TreeView.TreeItem.toJson
    |> Json.Array

  let responseJson =
    let requestID = Stdlib.Option.Option.Some requestID
    (JsonRPC.Response.Ok.make requestID result)
    |> Stdlib.AltJson.format

  logAndSendToClient responseJson


/// handles `dark/getRootNodes` requests
let handleGetRootNodesRequest
  (state: LspState)
  (requestID: JsonRPC.RequestId)
  : LspState =
  // TODO perf: this is kinda nuts - we search ALL packages just to extract unique owners
  // should have a dedicated SQL query like `SELECT DISTINCT owner FROM locations WHERE deprecated_at IS NULL`
  // Search for all packages to get unique owners
  let searchQuery =
    ProgramTypes.Search.SearchQuery
      { currentModule = []
        text = ""
        searchDepth = ProgramTypes.Search.SearchDepth.AllDescendants
        entityTypes = [
          ProgramTypes.Search.EntityType.Module
          ProgramTypes.Search.EntityType.Fn
          ProgramTypes.Search.EntityType.Type
          ProgramTypes.Search.EntityType.Value
        ]
        exactMatch = false }

  let searchResults = PackageManager.Search.search searchQuery

  // Extract unique owners from all results
  let owners =
    let fnOwners = searchResults.fns |> Stdlib.List.map (fun item -> item.location.owner)
    let typeOwners = searchResults.types |> Stdlib.List.map (fun item -> item.location.owner)
    let valueOwners = searchResults.values |> Stdlib.List.map (fun item -> item.location.owner)

    (Stdlib.List.flatten [ fnOwners; typeOwners; valueOwners ])
    |> Stdlib.List.unique
    |> Stdlib.List.sort

  // Create tree items for each owner
  let treeItems =
    owners
    |> Stdlib.List.map (fun owner ->
      makeTreeItem owner owner TreeItemCollapsibleState.Collapsed Stdlib.Option.Option.None)

  sendTreeViewResponse requestID treeItems

  state


/// Checks if a module path is a parent of another module path
// e.g. `["Darklang", "Stdlib"]` is a parent of `["Darklang", "Stdlib", "Int8"]`
let isModuleParentOf (parentPath: List<String>) (childPath: List<String>) : Bool =
  let parentPathLength = Stdlib.List.length parentPath
  let childPathLength = Stdlib.List.length childPath

  if parentPathLength > childPathLength then false
  else Stdlib.List.take childPath parentPathLength == parentPath


/// Helper to create tree items for entities (fns, types, values)
let makeEntityTreeItems
  (entities: List<ProgramTypes.LocatedItem<'a>>)
  (currentPath: List<String>)
  (entityType: String)
  : List<TreeItem> =
  entities
  |> Stdlib.List.filter (fun item ->
    let modules = Stdlib.List.push item.location.modules item.location.owner
    modules == currentPath)
  |> Stdlib.List.map (fun item ->
    let id = PrettyPrinter.ProgramTypes.PackageLocation.packageLocation item.location
    makeTreeItem id item.location.name TreeItemCollapsibleState.None (Stdlib.Option.Option.Some $"{entityType}:{id}"))


let buildTreeItems
  (results: ProgramTypes.Search.SearchResults)
  (currentPath: List<String>)
  (nodeId: String)
  : List<TreeItem> =
  let currentDepth = Stdlib.List.length currentPath

  let submodules =
    results.submodules
    |> Stdlib.List.filter (fun modulePath ->
      (Stdlib.List.length modulePath > currentDepth) &&
      isModuleParentOf currentPath modulePath)
    |> Stdlib.List.map (fun modulePath ->
      match Stdlib.List.getAt modulePath currentDepth with
      | Some childName -> childName
      | None -> "")
    |> Stdlib.List.filter (fun name -> name != "")
    |> Stdlib.List.unique
    |> Stdlib.List.map (fun childName ->
      let childId = $"{nodeId}.{childName}"
      makeTreeItem childId childName TreeItemCollapsibleState.Collapsed Stdlib.Option.Option.None)

  let fnItems = makeEntityTreeItems results.fns currentPath "fn"
  let typeItems = makeEntityTreeItems results.types currentPath "type"
  let valueItems = makeEntityTreeItems results.values currentPath "value"

  (Stdlib.List.flatten [submodules; fnItems; typeItems; valueItems])
  |> Stdlib.List.uniqueBy (fun item ->
    match item.id with
    | Some id -> id
    | None -> "")


let handleGetChildNodesRequest
  (state: LspState)
  (requestID: JsonRPC.RequestId)
  (nodeId: String)
  : LspState =
  // TODO perf: using AllDescendants then filtering in Darklang to get immediate children
  // works fine now but won't scale to millions of packages
  // see later.md for optimization options (denormalized table, better SQL queries, etc.)
  // Handle package nodes
  let currentPath = nodeId |> Stdlib.String.split "."

  let searchQuery =
    ProgramTypes.Search.SearchQuery
      { currentModule = currentPath
        text = ""
        searchDepth = ProgramTypes.Search.SearchDepth.AllDescendants
        entityTypes = [
          ProgramTypes.Search.EntityType.Module
          ProgramTypes.Search.EntityType.Fn
          ProgramTypes.Search.EntityType.Type
          ProgramTypes.Search.EntityType.Value
        ]
        exactMatch = false }

  let searchResults =
    PackageManager.Search.search searchQuery
  let treeItems = buildTreeItems searchResults currentPath nodeId

  sendTreeViewResponse requestID treeItems
  state