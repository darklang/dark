module Darklang.LanguageTools.LspServer.HoverInformation

// this file is really long - quick thoughts on how to potentially tidy:
// - operators (lines ~1231-1361): 13 nearly identical fns, could be lookup table. Quick win, saves ~100 lines.
// - builtin types (lines ~296-314): 15 identical primitive type cases, could be data-driven. Saves ~50 lines.
// - expression helpers: lots of "check range â†’ recurse on children" patterns could be extracted. Saves ~200 lines.
// - full generic tree walker: would cut ~50% of code but big refactor. probably overkill unless we're actively working here.

type Info =
  { range: WrittenTypes.Range
    description: Stdlib.Option.Option<String>
    metadata: Stdlib.Option.Option<String> }

/// Context for hover information collection - wraps common parameters
type Context =
  { branchId: Uuid
    pm: ProgramTypes.PackageManager.PackageManager
    owner: String
    currentModules: List<String> }


let createHoverInfo
  (range: WrittenTypes.Range)
  (description: Stdlib.Option.Option<String>)
  (metadata: Stdlib.Option.Option<String>)
  : Info =
  Info
    { range = range
      description = description
      metadata = metadata }


let hoverInfoForThingAtPosition
  (ctx: Context)
  (thingAtPosition: CursorPosition.ThingAtPosition)
  (range: WrittenTypes.Range)
  : HoverInformation.Info =
  let ppCtx = PrettyPrinter.ProgramTypes.Context.forBranch ctx.branchId
  match thingAtPosition with
  | Keyword keywordName ->
    let metadata = Stdlib.Option.Option.Some("Keyword: " ++ keywordName)
    let description = KeywordDescription.getKeywordDescription keywordName
    createHoverInfo range description metadata

  | ModuleName moduleName description ->
    let metadata =
      Stdlib.Option.Option.Some("Module: " ++ moduleName ++ "\n\n")

    createHoverInfo range description metadata

  | SubModuleName fqName description ->
    let metadata =
      Stdlib.Option.Option.Some("Fully qualified name: " ++ fqName)

    createHoverInfo range description metadata

  | FnName fnName description ->
    let metadata =
      Stdlib.Option.Option.Some("Fully qualified name: " ++ fnName)

    createHoverInfo range description metadata

  | PackageValue fqNameList value description ->
    let prettyVal = PrettyPrinter.ProgramTypes.packageValue ppCtx value

    let fqName = fqNameList |> Stdlib.String.join "."

    let metadata =
      Stdlib.Option.Option.Some(
        "Fully qualified name: " ++ fqName ++ "\n\n" ++ (createCodeSnippet prettyVal)
      )

    createHoverInfo range description metadata

  | BuiltinFn signature description ->
    let metadata =
      Stdlib.Option.Option.Some("Builtin Function: " ++ signature)

    createHoverInfo range description metadata

  | PackageFn fqNameList fn description ->
    let signature = PrettyPrinter.ProgramTypes.PackageFn.signature ppCtx fn

    let fqName = fqNameList |> Stdlib.String.join "."

    let metadata =
      Stdlib.Option.Option.Some(
        "Fully qualified name: "
        ++ fqName
        ++ "\n\n"
        ++ (createCodeSnippet signature)
      )

    createHoverInfo range description metadata

  | BuiltinType typeName description ->
    let metadata = Stdlib.Option.Option.Some("Builtin Type: " ++ typeName)
    createHoverInfo range description metadata


  | PackageType fqNameList typ description ->
    let prettyType = PrettyPrinter.ProgramTypes.packageType ppCtx typ

    let fqName = fqNameList |> Stdlib.String.join "."

    let metadata =
      Stdlib.Option.Option.Some(
        createCodeSnippet prettyType
        ++ "\n\n"
        ++ $"Fully qualified name: {fqName}"
      )

    createHoverInfo range description metadata

  | Variable variableName description ->
    let metadata = Stdlib.Option.Option.Some("Variable: " ++ variableName)
    createHoverInfo range description metadata

  | Operator description ->
    let metadata = Stdlib.Option.Option.None

    let description = Stdlib.Option.Option.Some(description)

    createHoverInfo range description metadata

  | EnumCase caseName description ->
    let metadata = Stdlib.Option.Option.Some("Enum case: " ++ caseName)

    createHoverInfo range description metadata

  | EnumLabel description ->
    let metadata = Stdlib.Option.Option.Some("Enum label")
    createHoverInfo range description metadata

  | FieldName fieldName description ->
    let metadata = Stdlib.Option.Option.Some("Field: " ++ fieldName)
    createHoverInfo range description metadata

  | Parameter name typ description ->
    let metadata = Stdlib.Option.Option.Some(name ++ ": " ++ typ)
    createHoverInfo range description metadata

  | TypeParameter description ->
    let metadata = Stdlib.Option.Option.Some("Type parameter")
    createHoverInfo range description metadata

  | DictKey key description ->
    let metadata = Stdlib.Option.Option.Some("Dict key: " ++ key)
    createHoverInfo range description metadata


let createCodeSnippet (text: String) : String =
  $"""
```fsharp
{text}
```"""


let getBuiltinFn (name: String) : Stdlib.Option.Option<BuiltinFunction> =
  (Builtin.languageToolsAllBuiltinFns ())
  |> Stdlib.List.findFirst (fun f -> f.name.name == name)


/// Helper function to find and get package functions, types, and values by name from the package manager
let tryGetFnAndCollectHoverInfo
  (ctx: Context)
  (fnName: List<String>)
  (range: WrittenTypes.Range)
  : Stdlib.Option.Option<Info> =
  let onMissing = LanguageTools.NameResolver.OnMissing.Allow
  let fnNameList = fnName
  let fnName = WrittenTypes.Name.Unresolved range fnName

  let nrCtx =
    LanguageTools.NameResolver.NRContext
      { onMissing = onMissing
        pm = ctx.pm
        branchId = ctx.branchId
        owner = ctx.owner
        currentModule = ctx.currentModules }

  let resolvedFn =
    NameResolver.FnName.resolve nrCtx fnName

  match resolvedFn with
  | Ok fn ->
    match fn with
    | Package pkgFn ->
      match ctx.pm.getFn pkgFn with
      | Some f ->
        let description =
          if f.description == "" then
            Stdlib.Option.Option.None
          else
            Stdlib.Option.Option.Some f.description

        let thingAtPosition =
          CursorPosition.ThingAtPosition.PackageFn(fnNameList, f, description)

        (hoverInfoForThingAtPosition ctx thingAtPosition range)
        |> Stdlib.Option.Option.Some

      | None -> Stdlib.Option.Option.None

    | Builtin b ->
      let builtin = getBuiltinFn b.name

      match builtin with
      | Some b ->
        let signature = PrettyPrinter.ProgramTypes.BuiltinFn.signature ctx.branchId b

        let description = Stdlib.Option.Option.Some(b.description)

        let thingAtPosition =
          CursorPosition.ThingAtPosition.BuiltinFn(
            createCodeSnippet signature,
            description
          )

        (hoverInfoForThingAtPosition ctx thingAtPosition range)
        |> Stdlib.Option.Option.Some

      | None -> Stdlib.Option.Option.None

  | _ -> Stdlib.Option.Option.None


let tryGetPkgType
  (ctx: Context)
  (typeName: List<String>)
  (range: WrittenTypes.Range)
  : Stdlib.Option.Option<ProgramTypes.PackageType.PackageType> =
  let onMissing = LanguageTools.NameResolver.OnMissing.Allow
  let typeName = WrittenTypes.Name.Unresolved range typeName

  let nrCtx =
    LanguageTools.NameResolver.NRContext
      { onMissing = onMissing
        pm = ctx.pm
        branchId = ctx.branchId
        owner = ctx.owner
        currentModule = ctx.currentModules }

  let resolvedType =
    NameResolver.TypeName.resolve nrCtx typeName

  match resolvedType with
  | Ok typ ->
    let t =
      match typ with
      | Package t -> t

    ctx.pm.getType t
  | _ -> Stdlib.Option.Option.None


let tryGetPkgVal
  (ctx: Context)
  (valName: List<String>)
  (range: WrittenTypes.Range)
  : Stdlib.Option.Option<ProgramTypes.PackageValue.PackageValue> =
  let onMissing = LanguageTools.NameResolver.OnMissing.Allow
  let valName = WrittenTypes.Name.Unresolved range valName

  let nrCtx =
    LanguageTools.NameResolver.NRContext
      { onMissing = onMissing
        pm = ctx.pm
        branchId = ctx.branchId
        owner = ctx.owner
        currentModule = ctx.currentModules }

  let resolvedVal =
    NameResolver.ValueName.resolve nrCtx valName

  match resolvedVal with
  | Ok value ->
    let v =
      match value with
      | Package v -> v

    ctx.pm.getValue v
  | _ -> Stdlib.Option.Option.None


/// Helper function for `collectBuiltinTypeHoverInfoAtPos`
let createBuiltinTypeInfoIfInRange
  (ctx: Context)
  (range: WrittenTypes.Range)
  (typeName: String)
  (position: LanguageServerProtocol.Position.Position)
  : Stdlib.Option.Option<Info> =
  match CursorPosition.checkIfPositionWithinRange position range with
  | Some r ->
    let description =
      Stdlib.Option.Option.Some(
        "TODO: add description when /// comments are supported"
      )

    let thingAtPosition =
      CursorPosition.ThingAtPosition.BuiltinType(typeName, description)

    (hoverInfoForThingAtPosition ctx thingAtPosition r)
    |> Stdlib.Option.Option.Some
  | None -> Stdlib.Option.Option.None

let collectBuiltinTypeHoverInfoAtPos
  (ctx: Context)
  (builtin: WrittenTypes.TypeReference.Builtin)
  (position: LanguageServerProtocol.Position.Position)
  : Stdlib.Option.Option<Info> =
  match builtin with
  | TUnit r -> createBuiltinTypeInfoIfInRange ctx r "Unit" position
  | TBool r -> createBuiltinTypeInfoIfInRange ctx r "Bool" position
  | TInt8 r -> createBuiltinTypeInfoIfInRange ctx r "Int8" position
  | TUInt8 r -> createBuiltinTypeInfoIfInRange ctx r "UInt8" position
  | TInt16 r -> createBuiltinTypeInfoIfInRange ctx r "Int16" position
  | TUInt16 r -> createBuiltinTypeInfoIfInRange ctx r "UInt16" position
  | TInt32 r -> createBuiltinTypeInfoIfInRange ctx r "Int32" position
  | TUInt32 r -> createBuiltinTypeInfoIfInRange ctx r "UInt32" position
  | TInt64 r -> createBuiltinTypeInfoIfInRange ctx r "Int64" position
  | TUInt64 r -> createBuiltinTypeInfoIfInRange ctx r "UInt64" position
  | TInt128 r -> createBuiltinTypeInfoIfInRange ctx r "Int128" position
  | TUInt128 r -> createBuiltinTypeInfoIfInRange ctx r "UInt128" position
  | TFloat r -> createBuiltinTypeInfoIfInRange ctx r "Float" position
  | TChar r -> createBuiltinTypeInfoIfInRange ctx r "Char" position
  | TString r -> createBuiltinTypeInfoIfInRange ctx r "String" position
  | TDateTime r -> createBuiltinTypeInfoIfInRange ctx r "DateTime" position
  | TUuid r -> createBuiltinTypeInfoIfInRange ctx r "Uuid" position

  | TList(r, keywordRange, _, typ, _) ->
    // check if position is within the List range
    if CursorPosition.isLineNumberInRange position r then
      // check if we are hovering over the List keyword
      match
        CursorPosition.checkIfPositionWithinRange position keywordRange
      with
      | Some r ->
        let thingAtPosition = CursorPosition.ThingAtPosition.Keyword("List")

        (hoverInfoForThingAtPosition ctx thingAtPosition r)
        |> Stdlib.Option.Option.Some
      | None ->
        // check if we are hovering over the type reference
        collectTypeRefHoverInfoAtPos ctx typ position
    else
      Stdlib.Option.Option.None

  | TDict(r, keywordRange, _, typ, _) ->
    // check if position is within the Dict range
    if CursorPosition.isLineNumberInRange position r then
      // check if we are hovering over the Dict keyword
      match
        CursorPosition.checkIfPositionWithinRange position keywordRange
      with
      | Some r ->
        let thingAtPosition = CursorPosition.ThingAtPosition.Keyword("Dict")

        (hoverInfoForThingAtPosition ctx thingAtPosition r)
        |> Stdlib.Option.Option.Some

      | None ->
        // check if we are hovering over the type reference
        collectTypeRefHoverInfoAtPos ctx typ position

    else
      Stdlib.Option.Option.None

  | TTuple(range, f, _, s, rest, _, _) ->
    // check if position is within the Tuple range
    if CursorPosition.isLineNumberInRange position range then
      // check if we are hovering over the first type reference
      match collectTypeRefHoverInfoAtPos ctx f position with
      | Some r -> Stdlib.Option.Option.Some(r)
      | None ->
        // check if we are hovering over the second type reference
        match collectTypeRefHoverInfoAtPos ctx s position with
        | Some r -> Stdlib.Option.Option.Some(r)
        | None ->
          // check if we are hovering over the rest type references
          rest
          |> Stdlib.List.filterMap (fun (_, t) ->
            collectTypeRefHoverInfoAtPos ctx t position)
          |> Stdlib.List.head
    else
      Stdlib.Option.Option.None

  | TFn(r, args, ret) ->
    // check if position is within the Fn range
    if CursorPosition.isLineNumberInRange position r then
      // check if we are hovering over the return type
      match collectTypeRefHoverInfoAtPos ctx ret position with
      | Some r -> Stdlib.Option.Option.Some(r)
      | None ->
        // check if we are hovering over the arguments
        args
        |> Stdlib.List.filterMap (fun (t, _) ->
          collectTypeRefHoverInfoAtPos ctx t position)
        |> Stdlib.List.head
    else
      Stdlib.Option.Option.None

  | TDB(r, keywordRange, _, typ, _) ->
    // check if position is within the DB range
    if CursorPosition.isLineNumberInRange position r then
      // check if we are hovering over the DB keyword
      match
        CursorPosition.checkIfPositionWithinRange position keywordRange
      with
      | Some r ->
        let thingAtPosition = CursorPosition.ThingAtPosition.Keyword("DB")

        (hoverInfoForThingAtPosition ctx thingAtPosition r)
        |> Stdlib.Option.Option.Some
      | None ->
        // check if we are hovering over the type reference
        collectTypeRefHoverInfoAtPos ctx typ position
    else
      Stdlib.Option.Option.None

  | TVariable(r, _, (_, name)) ->
    match CursorPosition.checkIfPositionWithinRange position r with
    | Some r ->
      let description =
        Stdlib.Option.Option.Some(
          "TODO: add description when /// comments are supported"
        )

      let thingAtPosition =
        CursorPosition.ThingAtPosition.TypeParameter description

      (hoverInfoForThingAtPosition ctx thingAtPosition r)
      |> Stdlib.Option.Option.Some

    | None -> Stdlib.Option.Option.None

  | _ -> Stdlib.Option.Option.None

let collectModuleNameHoverInfoAtPos
  (ctx: Context)
  (modules: List<WrittenTypes.ModuleIdentifier * WrittenTypes.Range>)
  (position: LanguageServerProtocol.Position.Position)
  : Stdlib.Option.Option<Info> =
  modules
  |> Stdlib.List.filterMap (fun (m, _) ->
    match CursorPosition.checkIfPositionWithinRange position m.range with
    | Some r ->
      let description =
        Stdlib.Option.Option.Some(
          "TODO: add description when /// comments are supported"
        )

      let thingAtPosition =
        CursorPosition.ThingAtPosition.ModuleName(m.name, description)

      (hoverInfoForThingAtPosition ctx thingAtPosition r)
      |> Stdlib.Option.Option.Some

    | None -> Stdlib.Option.Option.None)

  |> Stdlib.List.head


let collectTypeRefHoverInfoAtPos
  (ctx: Context)
  (typeRef: WrittenTypes.TypeReference.TypeReference)
  (position: LanguageServerProtocol.Position.Position)
  : Stdlib.Option.Option<Info> =
  match typeRef with
  | Builtin b ->
    collectBuiltinTypeHoverInfoAtPos ctx b position
  | QualifiedName qn ->
    // check if we are hovering over the one of the modules
    let moduleHoverInfo =
      collectModuleNameHoverInfoAtPos ctx qn.modules position

    match moduleHoverInfo with
    | Some r -> Stdlib.Option.Option.Some r
    | None ->
      let range = qn.typ.range
      // check if we are hovering over the type name
      match CursorPosition.checkIfPositionWithinRange position range with
      | Some r ->
        let modules = qn.modules |> Stdlib.List.map (fun (m, _) -> m.name)
        let typeName = Stdlib.List.append modules [ qn.typ.name ]

        let typ = tryGetPkgType ctx typeName range

        match typ with
        | Some t ->
          let description =
            if t.description == "" then
              Stdlib.Option.Option.None
            else
              Stdlib.Option.Option.Some t.description

          let thingAtPosition =
            CursorPosition.ThingAtPosition.PackageType(typeName, t, description)

          (hoverInfoForThingAtPosition ctx thingAtPosition r)
          |> Stdlib.Option.Option.Some
        | None -> Stdlib.Option.Option.None

      | None ->
        // check if we are hovering over the type parameters
        qn.typeArgs
        |> Stdlib.List.filterMap (fun tr ->
          collectTypeRefHoverInfoAtPos ctx tr position)
        |> Stdlib.List.head


// ---------------------------
// Type declaration Hover Info
// ---------------------------
let collectEnumFieldHoverInfoAtPos
  (ctx: Context)
  (enumField: WrittenTypes.TypeDeclaration.EnumField)
  (position: LanguageServerProtocol.Position.Position)
  : Stdlib.Option.Option<Info> =
  // check if we are hovering over an enum field
  match
    CursorPosition.checkIfPositionWithinRange position enumField.range
  with
  | Some r ->
    let typ = collectTypeRefHoverInfoAtPos ctx enumField.typ position
    // check if we are hovering over the enum field type
    match typ with
    | Some _ -> typ
    | None ->
      let label =
        match enumField.label with
        | Some((r, _)) -> Stdlib.Option.Option.Some r
        | None -> Stdlib.Option.Option.None

      // check if we are hovering over the enum field label
      match label with
      | Some r ->
        match CursorPosition.checkIfPositionWithinRange position r with
        | Some r ->
          let description =
            Stdlib.Option.Option.Some(
              "TODO: add description when /// comments are supported"
            )

          let thingAtPosition =
            CursorPosition.ThingAtPosition.EnumLabel description

          (hoverInfoForThingAtPosition ctx thingAtPosition r)
          |> Stdlib.Option.Option.Some

        | None -> Stdlib.Option.Option.None
      | None -> Stdlib.Option.Option.None
  | None -> Stdlib.Option.Option.None

let collectEnumCaseHoverInfoAtPos
  (ctx: Context)
  (enumCase: WrittenTypes.TypeDeclaration.EnumCase)
  (position: LanguageServerProtocol.Position.Position)
  : Stdlib.Option.Option<Info> =
  let (nameRange, caseName) = enumCase.name
  // check if we are hovering over the enum case
  match
    CursorPosition.checkIfPositionWithinRange position enumCase.range
  with
  | Some r ->
    // check if we are hovering over the enum case name
    match CursorPosition.checkIfPositionWithinRange position nameRange with
    | Some r ->
      let description =
        Stdlib.Option.Option.Some(
          "TODO: add description when /// comments are supported"
        )

      let thingAtPosition =
        CursorPosition.ThingAtPosition.EnumCase caseName description

      (hoverInfoForThingAtPosition ctx thingAtPosition r)
      |> Stdlib.Option.Option.Some

    | None ->
      // check if we are hovering over the of keyword
      match enumCase.keywordOf with
      | Some r ->
        match CursorPosition.checkIfPositionWithinRange position r with
        | Some r ->
          let thingAtPosition = CursorPosition.ThingAtPosition.Keyword("of")

          (hoverInfoForThingAtPosition ctx thingAtPosition r)
          |> Stdlib.Option.Option.Some

        | None ->
          // check if we are hovering over one of the enum case fields
          enumCase.fields
          |> Stdlib.List.filterMap (fun field ->
            collectEnumFieldHoverInfoAtPos ctx field position)
          |> Stdlib.List.head

      | None -> Stdlib.Option.Option.None
  | None -> Stdlib.Option.Option.None


let collectDefintionHoverInfoAtPos
  (ctx: Context)
  (def: WrittenTypes.TypeDeclaration.Definition)
  (position: LanguageServerProtocol.Position.Position)
  : Stdlib.Option.Option<Info> =
  match def with
  | Alias a ->
    collectTypeRefHoverInfoAtPos ctx a position
  | Record r ->
    r
    |> Stdlib.List.filterMap (fun (field, _) ->
      let (nameRange, name) = field.name
      // check if we are hovering over the record field name
      match
        CursorPosition.checkIfPositionWithinRange position nameRange
      with
      | Some r ->
        let description =
          Stdlib.Option.Option.Some(
            "TODO: add description when /// comments are supported"
          )

        let thingAtPosition =
          CursorPosition.ThingAtPosition.FieldName name description

        (hoverInfoForThingAtPosition ctx thingAtPosition r)
        |> Stdlib.Option.Option.Some

      | None ->
        // check if we are hovering over the record field type
        collectTypeRefHoverInfoAtPos ctx field.typ position)

    |> Stdlib.List.head

  | Enum enumCases ->
    enumCases
    |> Stdlib.List.filterMap (fun (_, enumCase) ->
      collectEnumCaseHoverInfoAtPos ctx enumCase position)
    |> Stdlib.List.head


let collectTypeHoverInfoAtPosition
  (ctx: Context)
  (typeDecl: WrittenTypes.TypeDeclaration.TypeDeclaration)
  (position: LanguageServerProtocol.Position.Position)
  : Stdlib.Option.Option<Info> =
  // check if we are hovering over the type keyword
  match
    CursorPosition.checkIfPositionWithinRange position typeDecl.keywordType
  with
  | Some r ->
    let thingAtPosition = CursorPosition.ThingAtPosition.Keyword("type")

    (hoverInfoForThingAtPosition ctx thingAtPosition r)
    |> Stdlib.Option.Option.Some
  | None ->
    let range = typeDecl.name.range
    // check if we are hovering over the type name
    match CursorPosition.checkIfPositionWithinRange position range with
    | Some r ->
      let modules = Stdlib.String.join ctx.currentModules "."
      let typeNameList = Stdlib.List.append ctx.currentModules [ typeDecl.name.name ]

      let typ = tryGetPkgType ctx [ typeDecl.name.name ] range

      match typ with
      | Some t ->
        let description =
          if t.description == "" then
            Stdlib.Option.Option.None
          else
            Stdlib.Option.Option.Some t.description

        let thingAtPosition =
          CursorPosition.ThingAtPosition.PackageType(typeNameList, t, description)

        (hoverInfoForThingAtPosition ctx thingAtPosition r)
        |> Stdlib.Option.Option.Some
      | None -> Stdlib.Option.Option.None

    | None ->
      // check if we are hovering over type parameters
      let typeParams =
        typeDecl.typeParams
        |> Stdlib.List.filterMap (fun (range, name) ->
          match
            CursorPosition.checkIfPositionWithinRange position range
          with
          | Some r ->
            let description =
              Stdlib.Option.Option.Some(
                "TODO: add description when /// comments are supported"
              )

            let thingAtPosition =
              CursorPosition.ThingAtPosition.TypeParameter description

            (hoverInfoForThingAtPosition ctx thingAtPosition r)
            |> Stdlib.Option.Option.Some

          | None -> Stdlib.Option.Option.None)

        |> Stdlib.List.head

      match typeParams with
      | Some r -> Stdlib.Option.Option.Some r
      | None ->
        // check if we are hovering over the type definition
        collectDefintionHoverInfoAtPos ctx typeDecl.definition position


// ---------------------------
// Value declaration Hover Info
// ---------------------------

/// Collect hover information for a value declaration at a given position
let collectValueHoverInfoAtPos
  (ctx: Context)
  (v: WrittenTypes.ValueDeclaration.ValueDeclaration)
  (position: LanguageServerProtocol.Position.Position)
  : Stdlib.Option.Option<Info> =
  // check if we are hovering over the val keyword
  match
    CursorPosition.checkIfPositionWithinRange position v.keywordVal
  with
  | Some r ->
    let thingAtPosition = CursorPosition.ThingAtPosition.Keyword("val")

    (hoverInfoForThingAtPosition ctx thingAtPosition r)
    |> Stdlib.Option.Option.Some

  | None ->
    let range = v.name.range
    // check if we are hovering over the value name
    match CursorPosition.checkIfPositionWithinRange position range with
    | Some r ->
      let valueNameList = Stdlib.List.append ctx.currentModules [ v.name.name ]

      let getValue = tryGetPkgVal ctx [ v.name.name ] range

      match getValue with
      | Some value ->
        let description =
          if value.description == "" then
            Stdlib.Option.Option.None
          else
            Stdlib.Option.Option.Some value.description

        let thingAtPosition =
          CursorPosition.ThingAtPosition.PackageValue(
            valueNameList,
            value,
            description
          )

        (hoverInfoForThingAtPosition ctx thingAtPosition r)
        |> Stdlib.Option.Option.Some

      | None -> Stdlib.Option.Option.None

    | None ->
      // check if we are hovering over the value body (which is an expression)
      collectExpressionHoverInfoAtPos ctx v.body position


// ---------------------------
// Function declaration Hover Info
// ---------------------------
let collectFnParameterHoverInfoAtPos
  (ctx: Context)
  (p: WrittenTypes.FnDeclaration.Parameter)
  (position: LanguageServerProtocol.Position.Position)
  : Stdlib.Option.Option<Info> =
  match p with
  | Unit r -> createBuiltinTypeInfoIfInRange ctx r "Unit" position
  | Normal np ->
    // check if we are hovering over a parameter
    match CursorPosition.checkIfPositionWithinRange position np.range with
    | Some r ->
      // check if we are hovering over the parameter name
      match
        CursorPosition.checkIfPositionWithinRange position np.name.range
      with
      | Some r ->
        let modules =
          ctx.currentModules |> Stdlib.List.tail |> Stdlib.Option.withDefault []

        let nrCtx =
          LanguageTools.NameResolver.NRContext
            { onMissing = LanguageTools.NameResolver.OnMissing.Allow
              pm = ctx.pm
              branchId = ctx.branchId
              owner = ctx.owner
              currentModule = modules }

        let typ =
          (WrittenTypesToProgramTypes.TypeReference.toPT
            nrCtx
            np.typ)
          |> Stdlib.Tuple2.first

        let ppCtx = PrettyPrinter.ProgramTypes.Context.forBranch ctx.branchId
        let typAsString = PrettyPrinter.ProgramTypes.typeReference ppCtx typ

        let description =
          Stdlib.Option.Option.Some(
            "TODO: add description when /// comments are supported"
          )

        let thingAtPosition =
          CursorPosition.ThingAtPosition.Parameter
            np.name.name
            typAsString
            description

        (hoverInfoForThingAtPosition ctx thingAtPosition r)
        |> Stdlib.Option.Option.Some

      | None ->
        // check if we are hovering over the parameter type
        collectTypeRefHoverInfoAtPos ctx np.typ position

    | None -> Stdlib.Option.Option.None

let collectFnHoverInfoAtPos
  (ctx: Context)
  (f: WrittenTypes.FnDeclaration.FnDeclaration)
  (position: LanguageServerProtocol.Position.Position)
  : Stdlib.Option.Option<Info> =
  // check if we are hovering over the let keyword
  match CursorPosition.checkIfPositionWithinRange position f.keywordLet with
  | Some r ->
    let thingAtPosition = CursorPosition.ThingAtPosition.Keyword("let")

    (hoverInfoForThingAtPosition ctx thingAtPosition r)
    |> Stdlib.Option.Option.Some
  | None ->
    // check if we are hovering over the function name
    match
      CursorPosition.checkIfPositionWithinRange position f.name.range
    with
    | Some r ->
      let fqName =
        (Stdlib.String.join ctx.currentModules ".")
        |> (fun currentModules ->
          if currentModules == "" then
            f.name.name
          else
            currentModules ++ "." ++ f.name.name)

      let description =
        if f.description == "" then
          Stdlib.Option.Option.None
        else
          Stdlib.Option.Option.Some f.description

      let thingAtPosition =
        CursorPosition.ThingAtPosition.FnName(fqName, description)

      (hoverInfoForThingAtPosition ctx thingAtPosition r)
      |> Stdlib.Option.Option.Some

    | None ->
      // check if we are hovering over the function type parameters
      let typeParams =
        f.typeParams
        |> Stdlib.List.filterMap (fun (range, name) ->
          match
            CursorPosition.checkIfPositionWithinRange position range
          with
          | Some r ->
            let description =
              Stdlib.Option.Option.Some(
                "TODO: add description when /// comments are supported"
              )

            let thingAtPosition =
              CursorPosition.ThingAtPosition.TypeParameter description

            (hoverInfoForThingAtPosition ctx thingAtPosition r)
            |> Stdlib.Option.Option.Some

          | None -> Stdlib.Option.Option.None)

        |> Stdlib.List.head

      match typeParams with
      | Some _ -> typeParams
      | None ->
        // check if we are hovering over the function parameters
        let parameters =
          f.parameters
          |> Stdlib.List.filterMap (fun p ->
            collectFnParameterHoverInfoAtPos ctx p position)
          |> Stdlib.List.head

        match parameters with
        | Some _ -> parameters
        | None ->
          // check if we are hovering over the function return type
          let returnType = collectTypeRefHoverInfoAtPos ctx f.returnType position

          match returnType with
          | Some _ -> returnType
          | None ->
            // check if we are hovering over the function body
            collectExpressionHoverInfoAtPos ctx f.body position


// ---------------------------
// Expression Hover Info
// ---------------------------
/// Collect hover information for match expression at a given position
let collectMatchPatternHoverInfoAtPos
  (ctx: Context)
  (mp: WrittenTypes.MatchPattern)
  (position: LanguageServerProtocol.Position.Position)
  : Stdlib.Option.Option<Info> =
  match mp with
  | MPUnit r
  | MPBool(r, _)
  | MPInt8(r, _, _)
  | MPUInt8(r, _, _)
  | MPInt16(r, _, _)
  | MPUInt16(r, _, _)
  | MPInt32(r, _, _)
  | MPUInt32(r, _, _)
  | MPInt64(r, _, _)
  | MPUInt64(r, _, _)
  | MPInt128(r, _, _)
  | MPUInt128(r, _, _)
  | MPFloat(r, _, _, _)
  | MPChar(r, _, _, _)
  | MPString(r, _, _, _) -> Stdlib.Option.Option.None
  | MPList(r, contents, _, _) ->
    // check if position is within the List range
    match CursorPosition.checkIfPositionWithinRange position r with
    | Some r ->
      contents
      |> Stdlib.List.filterMap (fun (c, _) ->
        collectMatchPatternHoverInfoAtPos ctx c position)
      |> Stdlib.List.head
    | None -> Stdlib.Option.Option.None

  | MPListCons(r, head, tail, symbolCons) ->
    // check if position is within the List cons range
    if CursorPosition.isLineNumberInRange position r then
      // check if we are hovering over the cons symbol
      match
        CursorPosition.checkIfPositionWithinRange position symbolCons
      with
      | Some r ->
        let thingAtPosition =
          CursorPosition.ThingAtPosition.Operator(
            "Cons operator: used to construct a list by adding an element to the front of an existing list"
          )

        (hoverInfoForThingAtPosition ctx thingAtPosition r)
        |> Stdlib.Option.Option.Some

      | None ->
        // check if we are hovering over the head
        match
          collectMatchPatternHoverInfoAtPos ctx head position
        with
        | Some r -> Stdlib.Option.Option.Some r
        | None ->
          // check if we are hovering over the tail
          collectMatchPatternHoverInfoAtPos ctx tail position
    else
      Stdlib.Option.Option.None

  | MPTuple(r, first, _, second, rest, _, _) ->
    // check if position is within the Tuple range
    if CursorPosition.isLineNumberInRange position r then
      // check if we are hovering over the first match pattern
      match
        collectMatchPatternHoverInfoAtPos ctx first position
      with
      | Some r -> Stdlib.Option.Option.Some r
      | None ->
        // check if we are hovering over the second match pattern
        match
          collectMatchPatternHoverInfoAtPos ctx second position
        with
        | Some r -> Stdlib.Option.Option.Some r
        | None ->
          // check if we are hovering over the rest match patterns
          rest
          |> Stdlib.List.filterMap (fun (_, mp) ->
            collectMatchPatternHoverInfoAtPos ctx mp position)
          |> Stdlib.List.head

    else
      Stdlib.Option.Option.None

  | MPVariable(r, name) ->
    match CursorPosition.checkIfPositionWithinRange position r with
    | Some r ->
      let description =
        Stdlib.Option.Option.Some(
          "TODO: add description when /// comments are supported"
        )

      let thingAtPosition =
        CursorPosition.ThingAtPosition.Variable(name, description)

      (hoverInfoForThingAtPosition ctx thingAtPosition r)
      |> Stdlib.Option.Option.Some

    | None -> Stdlib.Option.Option.None

  | MPEnum(r, caseName, fieldPats) ->
    // check if position is within the Enum range
    if CursorPosition.isLineNumberInRange position r then
      // check if we are hovering over the enum case name
      let (caseNameRange, caseName) = caseName

      match
        CursorPosition.checkIfPositionWithinRange position caseNameRange
      with
      | Some r ->
        let description =
          Stdlib.Option.Option.Some(
            "TODO: add description when /// comments are supported"
          )

        let thingAtPosition =
          CursorPosition.ThingAtPosition.EnumCase caseName description

        (hoverInfoForThingAtPosition ctx thingAtPosition r)
        |> Stdlib.Option.Option.Some

      | None ->
        // check if we are hovering over the field patterns
        fieldPats
        |> Stdlib.List.filterMap (fun mp ->
          collectMatchPatternHoverInfoAtPos ctx mp position)
        |> Stdlib.List.head
    else
      Stdlib.Option.Option.None

  | MPOr(r, patterns) ->
    // check if position is within the MPOr range
    if CursorPosition.isLineNumberInRange position r then
      // check if we are hovering over one of the or patterns
      patterns
      |> Stdlib.List.filterMap (fun mp ->
        collectMatchPatternHoverInfoAtPos ctx mp position)
      |> Stdlib.List.head
    else
      Stdlib.Option.Option.None

  | _ -> Stdlib.Option.Option.None

let collectMatchCaseHoverInfoAtPos
  (ctx: Context)
  (mc: WrittenTypes.MatchCase)
  (position: LanguageServerProtocol.Position.Position)
  : Stdlib.Option.Option<Info> =
  let (_, matchPattern, _) = mc.pat

  // check if we are hovering over the match case pattern
  match collectMatchPatternHoverInfoAtPos ctx matchPattern position with
  | Some r -> Stdlib.Option.Option.Some r
  | None ->
    // check if we are hovering over the match case rhs
    match collectExpressionHoverInfoAtPos ctx mc.rhs position with
    | Some r -> Stdlib.Option.Option.Some r
    | None ->
      match mc.whenCondition with
      | Some((whenKeyword, expr)) ->
        // check if we are hovering over the when keyword
        match
          CursorPosition.checkIfPositionWithinRange position whenKeyword
        with
        | Some r ->
          let thingAtPosition =
            CursorPosition.ThingAtPosition.Keyword("when")

          (hoverInfoForThingAtPosition ctx thingAtPosition r)
          |> Stdlib.Option.Option.Some
        | None ->
          // check if we are hovering over the when condition expression
          collectExpressionHoverInfoAtPos ctx expr position

      | None -> Stdlib.Option.Option.None


/// Collect hover information for Infix operations at a given position
let collectInfixFnNameHoverInfoAtPos
  (ctx: Context)
  (i: WrittenTypes.InfixFnName)
  (range: WrittenTypes.Range)
  : Stdlib.Option.Option<Info> =
  match i with
  | ArithmeticPlus ->
    let thingAtPosition =
      CursorPosition.ThingAtPosition.Operator("Arithmetic plus")

    (hoverInfoForThingAtPosition ctx thingAtPosition range)
    |> Stdlib.Option.Option.Some

  | ArithmeticMinus ->
    let thingAtPosition =
      CursorPosition.ThingAtPosition.Operator("Arithmetic minus")

    (hoverInfoForThingAtPosition ctx thingAtPosition range)
    |> Stdlib.Option.Option.Some

  | ArithmeticMultiply ->
    let thingAtPosition =
      CursorPosition.ThingAtPosition.Operator("Arithmetic multiply")

    (hoverInfoForThingAtPosition ctx thingAtPosition range)
    |> Stdlib.Option.Option.Some

  | ArithmeticDivide ->
    let thingAtPosition =
      CursorPosition.ThingAtPosition.Operator("Arithmetic divide")

    (hoverInfoForThingAtPosition ctx thingAtPosition range)
    |> Stdlib.Option.Option.Some

  | ArithmeticModulo ->
    let thingAtPosition =
      CursorPosition.ThingAtPosition.Operator("Arithmetic modulo")

    (hoverInfoForThingAtPosition ctx thingAtPosition range)
    |> Stdlib.Option.Option.Some

  | ArithmeticPower ->
    let thingAtPosition =
      CursorPosition.ThingAtPosition.Operator("Arithmetic power")

    (hoverInfoForThingAtPosition ctx thingAtPosition range)
    |> Stdlib.Option.Option.Some

  | ComparisonGreaterThan ->
    let thingAtPosition =
      CursorPosition.ThingAtPosition.Operator("Comparison greater than")

    (hoverInfoForThingAtPosition ctx thingAtPosition range)
    |> Stdlib.Option.Option.Some

  | ComparisonGreaterThanOrEqual ->
    let thingAtPosition =
      CursorPosition.ThingAtPosition.Operator(
        "Comparison greater than or equal"
      )

    (hoverInfoForThingAtPosition ctx thingAtPosition range)
    |> Stdlib.Option.Option.Some

  | ComparisonLessThan ->
    let thingAtPosition =
      CursorPosition.ThingAtPosition.Operator("Comparison less than")

    (hoverInfoForThingAtPosition ctx thingAtPosition range)
    |> Stdlib.Option.Option.Some

  | ComparisonLessThanOrEqual ->
    let thingAtPosition =
      CursorPosition.ThingAtPosition.Operator(
        "Comparison less than or equal"
      )

    (hoverInfoForThingAtPosition ctx thingAtPosition range)
    |> Stdlib.Option.Option.Some

  | ComparisonEquals ->
    let thingAtPosition =
      CursorPosition.ThingAtPosition.Operator("Comparison equals")

    (hoverInfoForThingAtPosition ctx thingAtPosition range)
    |> Stdlib.Option.Option.Some

  | ComparisonNotEquals ->
    let thingAtPosition =
      CursorPosition.ThingAtPosition.Operator("Comparison not equals")

    (hoverInfoForThingAtPosition ctx thingAtPosition range)
    |> Stdlib.Option.Option.Some

  | StringConcat ->
    let thingAtPosition =
      CursorPosition.ThingAtPosition.Operator("String concat")

    (hoverInfoForThingAtPosition ctx thingAtPosition range)
    |> Stdlib.Option.Option.Some

let collectBinOpHoverInfoAtPos
  (ctx: Context)
  (b: WrittenTypes.BinaryOperation)
  (range: WrittenTypes.Range)
  : Stdlib.Option.Option<Info> =
  match b with
  | BinOpAnd ->
    let thingAtPosition =
      CursorPosition.ThingAtPosition.Operator("Logical and")

    (hoverInfoForThingAtPosition ctx thingAtPosition range)
    |> Stdlib.Option.Option.Some

  | BinOpOr ->
    let thingAtPosition =
      CursorPosition.ThingAtPosition.Operator("Logical or")

    (hoverInfoForThingAtPosition ctx thingAtPosition range)
    |> Stdlib.Option.Option.Some

let collectInfixHoverInfoAtPos
  (ctx: Context)
  (infix: WrittenTypes.Infix)
  (range: WrittenTypes.Range)
  : Stdlib.Option.Option<Info> =
  match infix with
  | InfixFnCall i -> collectInfixFnNameHoverInfoAtPos ctx i range
  | BinOp b -> collectBinOpHoverInfoAtPos ctx b range


/// Collect hover information for let pattern at a given position
let collectLetPatternHoverInfoAtPos
  (ctx: Context)
  (lp: WrittenTypes.LetPattern)
  (position: LanguageServerProtocol.Position.Position)
  : Stdlib.Option.Option<Info> =
  match lp with
  | LPUnit r ->
    // check if position is within the Unit range
    match CursorPosition.checkIfPositionWithinRange position r with
    | Some r ->
      let metadata = Stdlib.Option.Option.Some("Unit let pattern")
      let description = Stdlib.Option.Option.None

      Stdlib.Option.Option.Some(createHoverInfo r description metadata)

    | None -> Stdlib.Option.Option.None

  | LPVariable(r, name) ->
    // check if position is within the Variable range
    match CursorPosition.checkIfPositionWithinRange position r with
    | Some r ->
      let description =
        Stdlib.Option.Option.Some(
          "TODO: add description when /// comments are supported"
        )

      let thingAtPosition =
        CursorPosition.ThingAtPosition.Variable(name, description)

      (hoverInfoForThingAtPosition ctx thingAtPosition r)
      |> Stdlib.Option.Option.Some

    | None -> Stdlib.Option.Option.None

  | LPTuple(r, first, _, second, rest, _, _) ->
    // check if position is within the Tuple range
    if CursorPosition.isLineNumberInRange position r then
      // check if we are hovering over the first let pattern
      match collectLetPatternHoverInfoAtPos ctx first position with
      | Some r -> Stdlib.Option.Option.Some r
      | None ->
        // check if we are hovering over the second let pattern
        match collectLetPatternHoverInfoAtPos ctx second position with
        | Some r -> Stdlib.Option.Option.Some r
        | None ->
          // check if we are hovering over one of the rest let patterns
          rest
          |> Stdlib.List.filterMap (fun (_, lp) ->
            collectLetPatternHoverInfoAtPos ctx lp position)
          |> Stdlib.List.head

    else
      Stdlib.Option.Option.None

let collectTypeNameHoverInfoAtPos
  (ctx: Context)
  (typeName: WrittenTypes.QualifiedTypeIdentifier)
  (position: LanguageServerProtocol.Position.Position)
  : Stdlib.Option.Option<Info> =
  // check if we are hovering over the type name
    let modules =
      collectModuleNameHoverInfoAtPos ctx typeName.modules position

    // check if we are hovering over one of the module names
    match modules with
    | Some r -> Stdlib.Option.Option.Some r
    | None ->
      // check if we are hovering over the type name
      match
        CursorPosition.checkIfPositionWithinRange position typeName.typ.range
      with
      | Some r ->
        let modules =
          typeName.modules |> Stdlib.List.map (fun (name, _) -> name.name)

        let name = typeName.typ.name
        let range = typeName.typ.range
        let fqName = Stdlib.List.append modules [ name ]

        let typ = tryGetPkgType ctx fqName range

        match typ with
        | Some t ->
          let description =
            if t.description == "" then
              Stdlib.Option.Option.None
            else
              Stdlib.Option.Option.Some t.description

          let thingAtPosition =
            CursorPosition.ThingAtPosition.PackageType(fqName, t, description)

          (hoverInfoForThingAtPosition ctx thingAtPosition r)
          |> Stdlib.Option.Option.Some

        | None -> Stdlib.Option.Option.None
      | None ->
        // check if we are hovering over the type arguments
        typeName.typeArgs
        |> Stdlib.List.filterMap (fun tr ->
          collectTypeRefHoverInfoAtPos ctx tr position)
        |> Stdlib.List.head

let collectRecordHoverInfo
  (ctx: Context)
  (typeName: WrittenTypes.QualifiedTypeIdentifier)
  (fields: List<((WrittenTypes.Range * String) * 'a)>)
  (position: LanguageServerProtocol.Position.Position)
  (range: WrittenTypes.Range)
  (hoverInfoFn:
    Context
      -> 'a
      -> LanguageServerProtocol.Position.Position
      -> Stdlib.Option.Option<Info>)
  : Stdlib.Option.Option<Info> =
  // check if we are hovering over the fully qualified type name
  match
    CursorPosition.checkIfPositionWithinRange position typeName.range
  with
  | Some r ->
    collectTypeNameHoverInfoAtPos ctx typeName position

  | None ->
    // check if we are hovering over one of the fields
    fields
    |> Stdlib.List.filterMap (fun field ->
      let ((nameRange, fieldName), value) = field
      match CursorPosition.checkIfPositionWithinRange position nameRange with
      | Some r ->
        // Hovering over field name - show field information
        let description =
          Stdlib.Option.Option.Some(
            $"Record field: {fieldName}"
          )

        let thingAtPosition =
          CursorPosition.ThingAtPosition.FieldName(fieldName, description)

        (hoverInfoForThingAtPosition ctx thingAtPosition r)
        |> Stdlib.Option.Option.Some
      | None ->
        // Check if hovering over field value
        hoverInfoFn ctx value position)
    |> Stdlib.List.head

let collectEnumHoverInfo
  (ctx: Context)
  (typeName: WrittenTypes.QualifiedTypeIdentifier)
  (caseName: (WrittenTypes.Range * String))
  (fields: List<'a>)
  (position: LanguageServerProtocol.Position.Position)
  (range: WrittenTypes.Range)
  (hoverInfoFn:
    Context
      -> 'a
      -> LanguageServerProtocol.Position.Position
      -> Stdlib.Option.Option<Info>)
  : Stdlib.Option.Option<Info> =
  // check if we are hovering over the fully qualified type name
  match
    CursorPosition.checkIfPositionWithinRange position typeName.range
  with
  | Some r ->
    collectTypeNameHoverInfoAtPos ctx typeName position

  | None ->
    // check if we are hovering over the case name
    let (cnRange, caseName) = caseName

    match CursorPosition.checkIfPositionWithinRange position cnRange with
    | Some r ->
      let description =
        Stdlib.Option.Option.Some(
          "TODO: add description when /// comments are supported"
        )

      let thingAtPosition =
        CursorPosition.ThingAtPosition.EnumCase(caseName, description)

      (hoverInfoForThingAtPosition ctx thingAtPosition r)
      |> Stdlib.Option.Option.Some

    | None ->
      // check if we are hovering over one of the fields
      fields
      |> Stdlib.List.filterMap (fun exprOrVal ->
        hoverInfoFn ctx exprOrVal position)
      |> Stdlib.List.head


/// Collect hover information for a PipeExpr at a given position
let collectPipeExprHoverInfoAtPos
  (ctx: Context)
  (pe: WrittenTypes.PipeExpr)
  (position: LanguageServerProtocol.Position.Position)
  : Stdlib.Option.Option<Info> =
  match pe with
  | EPipeInfix(r, op, expr) ->
    // check if position is within the PipeInfix range
    if CursorPosition.isLineNumberInRange position r then
      let (range, infix) = op
      // check if we are hovering over an infix operator
      match CursorPosition.checkIfPositionWithinRange position range with
      | Some r -> collectInfixHoverInfoAtPos ctx infix r
      | None ->
        // check if we are hovering over the expression
        collectExpressionHoverInfoAtPos ctx expr position
    else
      Stdlib.Option.Option.None

  | EPipeLambda(r, pats, body, keywordFun, _symbolArrow) ->
    // check if position is within the PipeLambda range
    if CursorPosition.isLineNumberInRange position r then
      // check if we are hovering over the fun keyword
      match
        CursorPosition.checkIfPositionWithinRange position keywordFun
      with
      | Some r ->
        let thingAtPosition = CursorPosition.ThingAtPosition.Keyword("fun")

        (hoverInfoForThingAtPosition ctx thingAtPosition r)
        |> Stdlib.Option.Option.Some

      | None ->
        // check if we are hovering over one of the let patterns
        let pats =
          pats
          |> Stdlib.List.filterMap (fun lp ->
            collectLetPatternHoverInfoAtPos ctx lp position)
          |> Stdlib.List.head

        match pats with
        | Some r -> Stdlib.Option.Option.Some r
        | None ->
          // check if we are hovering over the body
          collectExpressionHoverInfoAtPos ctx body position
    else
      Stdlib.Option.Option.None


  | EPipeEnum(r, typeName, caseName, fields, _symbolDot) ->
    if CursorPosition.isLineNumberInRange position r then
      collectEnumHoverInfo
        ctx
        typeName
        caseName
        fields
        position
        r
        HoverInformation.collectExpressionHoverInfoAtPos
    else
      Stdlib.Option.Option.None

  | EPipeFnCall(r, fnName, args) ->
    // check if position is within the PipeFnCall range first
    if CursorPosition.isLineNumberInRange position r then
      // check if we are hovering over the fn name
      match
        CursorPosition.checkIfPositionWithinRange position fnName.range
      with
      | Some r ->
        // check if we are hovering over one of the module names
        let modules =
          collectModuleNameHoverInfoAtPos ctx fnName.modules position

        match modules with
        | Some r -> Stdlib.Option.Option.Some r
        | None ->
          let modules =
            fnName.modules |> Stdlib.List.map (fun (name, _) -> name.name)

          let name = fnName.fn.name
          // TODO: the range doesn't seem right, recheck parser code
          let range = fnName.fn.range
          let fn = Stdlib.List.append modules [ name ]

          match tryGetFnAndCollectHoverInfo ctx fn range with
          | Some r -> Stdlib.Option.Option.Some r
          | None ->
            fnName.typeArgs
            |> Stdlib.List.filterMap (fun tr ->
              collectTypeRefHoverInfoAtPos ctx tr position)
            |> Stdlib.List.head

      | None ->
        let typeArgs =
          fnName.typeArgs
          |> Stdlib.List.filterMap (fun tr ->
            collectTypeRefHoverInfoAtPos ctx tr position)
          |> Stdlib.List.head

        // check if we are hovering over one of the arguments
        args
        |> Stdlib.List.filterMap (fun expr ->
          collectExpressionHoverInfoAtPos ctx expr position)
        |> Stdlib.List.head
    else
      Stdlib.Option.Option.None

  | EPipeVariableOrFnCall(r, name) ->
    // check if position is within the PipeExpr range
    if CursorPosition.isLineNumberInRange position r then
      match tryGetFnAndCollectHoverInfo ctx name r with
      | Some r -> Stdlib.Option.Option.Some r
      | None ->
        let description =
          Stdlib.Option.Option.Some(
            "TODO: add description when /// comments are supported"
          )

        let thingAtPosition =
          CursorPosition.ThingAtPosition.Variable(name, description)

        (hoverInfoForThingAtPosition ctx thingAtPosition r)
        |> Stdlib.Option.Option.Some
    else
      Stdlib.Option.Option.None


let collectExpressionHoverInfoAtPos
  (ctx: Context)
  (e: WrittenTypes.Expr)
  (position: LanguageServerProtocol.Position.Position)
  : Stdlib.Option.Option<Info> =
  match e with
  | EList(r, contents, sob, scb) ->
    // check if position is within the List range
    if CursorPosition.isLineNumberInRange position r then
      // check if we are hovering over one of the List contents
      contents
      |> Stdlib.List.filterMap (fun (c, _) ->
        collectExpressionHoverInfoAtPos ctx c position)
      |> Stdlib.List.head
    else
      Stdlib.Option.Option.None

  | EDict(r, contents, keywordDict, sob, scb) ->
    // check if position is within the Dict range
    if CursorPosition.isLineNumberInRange position r then
      // check if we are hovering over the Dict keyword
      match
        CursorPosition.checkIfPositionWithinRange position keywordDict
      with
      | Some r ->
        let thingAtPosition = CursorPosition.ThingAtPosition.Keyword("Dict")

        (hoverInfoForThingAtPosition ctx thingAtPosition r)
        |> Stdlib.Option.Option.Some

      | None ->
        // check if we are hovering over one of the Dict contents
        contents
        |> Stdlib.List.filterMap (fun (_, k, v) ->
          let (keyRange, key) = k

          match
            CursorPosition.checkIfPositionWithinRange position keyRange
          with
          | Some r ->
            let description =
              Stdlib.Option.Option.Some(
                "TODO: add description when /// comments are supported"
              )

            let thingAtPosition =
              CursorPosition.ThingAtPosition.DictKey key description

            (hoverInfoForThingAtPosition ctx thingAtPosition r)
            |> Stdlib.Option.Option.Some

          | None ->
            collectExpressionHoverInfoAtPos ctx v position)
        |> Stdlib.List.head
    else
      Stdlib.Option.Option.None

  | ETuple(r, first, sc, second, rest, _, _) ->
    // check if position is within the Tuple range
    if CursorPosition.isLineNumberInRange position r then
      // check if we are hovering over the first expression
      match collectExpressionHoverInfoAtPos ctx first position with
      | Some r -> Stdlib.Option.Option.Some r
      | None ->
        // check if we are hovering over the second expression
        match collectExpressionHoverInfoAtPos ctx second position with
        | Some r -> Stdlib.Option.Option.Some r
        | None ->
          // check if we are hovering over one of the rest expressions
          rest
          |> Stdlib.List.filterMap (fun (_, e) ->
            collectExpressionHoverInfoAtPos ctx e position)
          |> Stdlib.List.head
    else
      Stdlib.Option.Option.None

  | ERecord(r, typeName, fields, _, _) ->
    // check if position is within the Record range
    if CursorPosition.isLineNumberInRange position r then
      match CursorPosition.checkIfPositionWithinRange position typeName.range with
      | Some range ->
        collectTypeNameHoverInfoAtPos ctx typeName position

      | None ->
        fields
        |> Stdlib.List.filterMap (fun (_, fieldName, expr) ->
          let (fieldNameRange, name) = fieldName

          match
            CursorPosition.checkIfPositionWithinRange
              position
              fieldNameRange
          with
          | Some r ->
            let description =
              Stdlib.Option.Option.Some(
                "TODO: add description when /// comments are supported"
              )

            let thingAtPosition =
              CursorPosition.ThingAtPosition.FieldName name description

            (hoverInfoForThingAtPosition ctx thingAtPosition r)
            |> Stdlib.Option.Option.Some

          | None ->
            collectExpressionHoverInfoAtPos ctx expr position)

        |> Stdlib.List.head

    else
      Stdlib.Option.Option.None

  | ERecordUpdate(r, record, updates, _sob, _scb, keywordWith) ->
    // check if position is within the RecordUpdate range
    if CursorPosition.isLineNumberInRange position r then
      // check if we are hovering over the record expression
      match collectExpressionHoverInfoAtPos ctx record position with
      | Some r -> Stdlib.Option.Option.Some r
      | None ->
        // check if we are hovering over the with keyword
        match
          CursorPosition.checkIfPositionWithinRange position keywordWith
        with
        | Some r ->
          let thingAtPosition =
            CursorPosition.ThingAtPosition.Keyword("with")

          (hoverInfoForThingAtPosition ctx thingAtPosition r)
          |> Stdlib.Option.Option.Some
        | None ->
          // check if we are hovering over one of the updates
          updates
          |> Stdlib.List.filterMap (fun (fieldName, _, expr) ->
            let (range, name) = fieldName

            match
              CursorPosition.checkIfPositionWithinRange position range
            with
            | Some r ->
              let description =
                Stdlib.Option.Option.Some(
                  "TODO: add description when /// comments are supported"
                )

              let thingAtPosition =
                CursorPosition.ThingAtPosition.FieldName name description

              (hoverInfoForThingAtPosition ctx thingAtPosition r)
              |> Stdlib.Option.Option.Some

            | None ->
              collectExpressionHoverInfoAtPos ctx expr position)
          |> Stdlib.List.head
    else
      Stdlib.Option.Option.None

  | EEnum(r, typeName, caseName, fields, _) ->
    if CursorPosition.isLineNumberInRange position r then
      collectEnumHoverInfo
        ctx
        typeName
        caseName
        fields
        position
        r
        HoverInformation.collectExpressionHoverInfoAtPos
    else
      Stdlib.Option.Option.None

  | ELet(r, letPattern, expr, body, keywordLet, _) ->
    // check if position is within the Let range
    if CursorPosition.isLineNumberInRange position r then
      // check if we are hovering over the let keyword
      match
        CursorPosition.checkIfPositionWithinRange position keywordLet
      with
      | Some r ->
        let thingAtPosition = CursorPosition.ThingAtPosition.Keyword("let")

        (hoverInfoForThingAtPosition ctx thingAtPosition r)
        |> Stdlib.Option.Option.Some
      | None ->
        // check if we are hovering over the let pattern
        match collectLetPatternHoverInfoAtPos ctx letPattern position with
        | Some r -> Stdlib.Option.Option.Some r
        | None ->
          // check if we are hovering over the let expression
          match collectExpressionHoverInfoAtPos ctx expr position with
          | Some r -> Stdlib.Option.Option.Some r
          | None ->
            // check if we are hovering over the let body
            collectExpressionHoverInfoAtPos ctx body position
    else
      Stdlib.Option.Option.None

  | EVariable(r, name) ->
    match CursorPosition.checkIfPositionWithinRange position r with
    | Some r ->
      let description =
        Stdlib.Option.Option.Some(
          "TODO: add description when /// comments are supported"
        )

      let thingAtPosition =
        CursorPosition.ThingAtPosition.Variable(name, description)

      (hoverInfoForThingAtPosition ctx thingAtPosition r)
      |> Stdlib.Option.Option.Some

    | None -> Stdlib.Option.Option.None

  | EFieldAccess(r, expr, fieldName, _symbolDot) ->
    // check if we are hovering over a field access expression range
    if CursorPosition.isLineNumberInRange position r then
      // check if we are hovering over the expression
      match collectExpressionHoverInfoAtPos ctx expr position with
      | Some r -> Stdlib.Option.Option.Some r
      | None ->
        // check if we are hovering over the field name
        let (fnRange, name) = fieldName

        match CursorPosition.checkIfPositionWithinRange position fnRange with
        | Some r ->
          let description =
            Stdlib.Option.Option.Some(
              "TODO: add description when /// comments are supported"
            )

          let thingAtPosition =
            CursorPosition.ThingAtPosition.FieldName name description

          (hoverInfoForThingAtPosition ctx thingAtPosition r)
          |> Stdlib.Option.Option.Some

        | None -> Stdlib.Option.Option.None

    else
      Stdlib.Option.Option.None

  | EIf(r, cond, thenExpr, elseExpr, keywordIf, keywordThen, keywordElse) ->
    // check if we are hovering over an if expression range
    if CursorPosition.isLineNumberInRange position r then
      // check if we are hovering over the if keyword
      match CursorPosition.checkIfPositionWithinRange position keywordIf with
      | Some r ->
        let thingAtPosition = CursorPosition.ThingAtPosition.Keyword("if")

        (hoverInfoForThingAtPosition ctx thingAtPosition r)
        |> Stdlib.Option.Option.Some
      | None ->
        // check if we are hovering over the condition
        match collectExpressionHoverInfoAtPos ctx cond position with
        | Some c -> Stdlib.Option.Option.Some(c)
        | None ->
          // check if we are hovering over the then keyword
          match
            CursorPosition.checkIfPositionWithinRange position keywordThen
          with
          | Some r ->
            let thingAtPosition =
              CursorPosition.ThingAtPosition.Keyword("then")

            (hoverInfoForThingAtPosition ctx thingAtPosition r)
            |> Stdlib.Option.Option.Some
          | None ->
            // check if we are hovering over the then expression
            match collectExpressionHoverInfoAtPos ctx thenExpr position with
            | Some t -> Stdlib.Option.Option.Some(t)
            | None ->
              // check if we are hovering over the else keyword
              match keywordElse with
              | Some r ->
                match
                  CursorPosition.checkIfPositionWithinRange position r
                with
                | Some r ->
                  let thingAtPosition =
                    CursorPosition.ThingAtPosition.Keyword("else")

                  (hoverInfoForThingAtPosition ctx thingAtPosition r)
                  |> Stdlib.Option.Option.Some
                | None ->
                  // check if we are hovering over the else expression
                  match elseExpr with
                  | Some e ->
                    collectExpressionHoverInfoAtPos ctx e position
                  | None -> Stdlib.Option.Option.None

              | None -> Stdlib.Option.Option.None
    else
      Stdlib.Option.Option.None

  | EMatch(r, expr, cases, keywordMatch, keywordWith) ->
    // check if we are hovering over a match expression range
    if CursorPosition.isLineNumberInRange position r then
      // check if we are hovering over the match keyword
      match
        CursorPosition.checkIfPositionWithinRange position keywordMatch
      with
      | Some r ->
        let thingAtPosition = CursorPosition.ThingAtPosition.Keyword("match")

        (hoverInfoForThingAtPosition ctx thingAtPosition r)
        |> Stdlib.Option.Option.Some
      | None ->
        // check if we are hovering over the expression
        match collectExpressionHoverInfoAtPos ctx expr position with
        | Some r -> Stdlib.Option.Option.Some r
        | None ->
          // check if we are hovering over the with keyword
          match
            CursorPosition.checkIfPositionWithinRange position keywordWith
          with
          | Some r ->
            let thingAtPosition =
              CursorPosition.ThingAtPosition.Keyword("with")

            (hoverInfoForThingAtPosition ctx thingAtPosition r)
            |> Stdlib.Option.Option.Some

          | None ->
            // check if we are hovering over one of the match cases
            cases
            |> Stdlib.List.filterMap (fun c ->
              collectMatchCaseHoverInfoAtPos ctx c position)
            |> Stdlib.List.head

    else
      Stdlib.Option.Option.None

  | EPipe(r, expr, pipeExprs) ->
    // check if we are hovering over a pipe expression range
    if CursorPosition.isLineNumberInRange position r then
      // check if we are hovering over the expression
      match collectExpressionHoverInfoAtPos ctx expr position with
      | Some r -> Stdlib.Option.Option.Some r
      | None ->
        // check if we are hovering over the pipe expression
        pipeExprs
        |> Stdlib.List.filterMap (fun (_, pe) ->
          collectPipeExprHoverInfoAtPos ctx pe position)
        |> Stdlib.List.head
    else
      Stdlib.Option.Option.None

  | EInfix(r, op, left, right) ->
    if CursorPosition.isLineNumberInRange position r then
      let (opRange, op) = op

      match CursorPosition.checkIfPositionWithinRange position opRange with
      | Some range ->
        match collectInfixHoverInfoAtPos ctx op range with
        | Some r -> Stdlib.Option.Option.Some r
        | None -> Stdlib.Option.Option.None

      | None ->
        match collectExpressionHoverInfoAtPos ctx left position with
        | Some r -> Stdlib.Option.Option.Some r
        | None -> collectExpressionHoverInfoAtPos ctx right position

    else
      Stdlib.Option.Option.None

  | ELambda(r, pats, body, keywordFun, _symbolArrow) ->
    // check if position is within the Lambda range
    if CursorPosition.isLineNumberInRange position r then
      // check if we are hovering over the fun keyword
      match
        CursorPosition.checkIfPositionWithinRange position keywordFun
      with
      | Some r ->
        let thingAtPosition = CursorPosition.ThingAtPosition.Keyword("fun")

        (hoverInfoForThingAtPosition ctx thingAtPosition r)
        |> Stdlib.Option.Option.Some
      | None ->
        // check if we are hovering over one of the lambda patterns
        let pats =
          pats
          |> Stdlib.List.filterMap (fun lp ->
            collectLetPatternHoverInfoAtPos ctx lp position)
          |> Stdlib.List.head

        match pats with
        | Some r -> Stdlib.Option.Option.Some r
        | None ->
          // check if we are hovering over the lambda body
          collectExpressionHoverInfoAtPos ctx body position

    else
      Stdlib.Option.Option.None

  | EApply(r, lhs, typeArgs, args) ->
    // check if position is within the EApply range
    if CursorPosition.isLineNumberInRange position r then
      // check if we are hovering over the lhs expression
      match collectExpressionHoverInfoAtPos ctx lhs position with
      | Some r -> Stdlib.Option.Option.Some r
      | None ->
        match
          typeArgs
          |> Stdlib.List.filterMap (fun tr ->
            collectTypeRefHoverInfoAtPos ctx tr position)
          |> Stdlib.List.head
        with
        | Some r -> Stdlib.Option.Option.Some r
        | None ->
          args
          |> Stdlib.List.filterMap (fun e ->
            collectExpressionHoverInfoAtPos ctx e position)
          |> Stdlib.List.head
    else
      Stdlib.Option.Option.None

  | EFnName(r, name) ->
    // check if position is within the EFnName range
    if CursorPosition.isLineNumberInRange position r then
      match
        CursorPosition.checkIfPositionWithinRange position name.fn.range
      with
      | Some r ->
        let modules = name.modules |> Stdlib.List.map (fun (m, _) -> m.name)
        let fnName = Stdlib.List.append modules [ name.fn.name ]

        tryGetFnAndCollectHoverInfo ctx fnName name.fn.range

      | None -> collectModuleNameHoverInfoAtPos name.modules position
    else
      Stdlib.Option.Option.None

  | EValueOrFn(r, fnOrValueName) ->
    // check if position is within the EValueOrFn range
    if CursorPosition.isLineNumberInRange position r then
      let modules =
        collectModuleNameHoverInfoAtPos fnOrValueName.modules position

      match modules with
      | Some r -> Stdlib.Option.Option.Some r
      | None ->
        let modules =
          fnOrValueName.modules |> Stdlib.List.map (fun (m, _) -> m.name)

        let fnOrValueNameList =
          Stdlib.List.append modules [ fnOrValueName.valueOrFn.name ]

        match CursorPosition.checkIfPositionWithinRange position r with
        | Some r ->
          // check if we are hovering over a function
          match tryGetFnAndCollectHoverInfo ctx fnOrValueNameList r with
          | Some r -> Stdlib.Option.Option.Some r
          | None ->
            // check if we are hovering over a value
            let getValue =
              tryGetPkgVal ctx fnOrValueNameList fnOrValueName.valueOrFn.range

            match getValue with
            | Some value ->
              let description =
                if value.description == "" then
                  Stdlib.Option.Option.None
                else
                  Stdlib.Option.Option.Some value.description

              let thingAtPosition =
                CursorPosition.ThingAtPosition.PackageValue(
                  fnOrValueNameList,
                  value,
                  description
                )

              (hoverInfoForThingAtPosition ctx thingAtPosition r)
              |> Stdlib.Option.Option.Some

            | None -> Stdlib.Option.Option.None
        | None -> Stdlib.Option.Option.None

    else
      Stdlib.Option.Option.None

  | EStatement(r, first, next) ->
    // check if position is within the Statement range
    if CursorPosition.isLineNumberInRange position r then
      // check if we are hovering over the first statement
      match collectExpressionHoverInfoAtPos ctx first position with
      | Some r -> Stdlib.Option.Option.Some r
      | None ->
        // check if we are hovering over one of the next statements
        collectExpressionHoverInfoAtPos ctx next position

    else
      Stdlib.Option.Option.None

  | _ -> Stdlib.Option.Option.None


// ---------------------------
// Source File Hover Info
// ---------------------------

/// Helper function to collect hover info from module declarations
let collectModuleDeclHoverInfoAtPos
  (ctx: Context)
  (decls: List<WrittenTypes.ModuleDeclaration.Declaration>)
  (position: LanguageServerProtocol.Position.Position)
  : Stdlib.Option.Option<Info> =
  let node =
    decls
    |> Stdlib.List.filterMap (fun decl ->
      match decl with
      | Type t ->
        // Check if position is within type range for early escape
        if CursorPosition.isLineNumberInRange position t.range then
          collectTypeHoverInfoAtPosition ctx t position
        else
          Stdlib.Option.Option.None

      | Value v ->
        // Check if position is within value range for early escape
        if CursorPosition.isLineNumberInRange position v.range then
          collectValueHoverInfoAtPos ctx v position
        else
          Stdlib.Option.Option.None

      | Function f ->
        // Check if position is within function range for early escape
        if CursorPosition.isLineNumberInRange position f.range then
          collectFnHoverInfoAtPos ctx f position
        else
          Stdlib.Option.Option.None

      | SubModule m ->
        // Check if position is within submodule range for early escape
        if CursorPosition.isLineNumberInRange position m.range then
          match
            CursorPosition.checkIfPositionWithinRange
              position
              m.keywordModule
          with
          | Some r ->
            let thingAtPosition =
              CursorPosition.ThingAtPosition.Keyword("module")

            (hoverInfoForThingAtPosition ctx thingAtPosition r)
            |> Stdlib.Option.Option.Some

          | None ->
            let (nameRange, subModuleName) = m.name

            match
              CursorPosition.checkIfPositionWithinRange position nameRange
            with
            | Some r ->
              let fqName =
                (Stdlib.String.join ctx.currentModules ".")
                |> (fun currentModules ->
                  if currentModules == "" then
                    subModuleName
                  else
                    currentModules ++ "." ++ subModuleName)

              let description =
                Stdlib.Option.Option.Some(
                  "TODO: add description when /// comments are supported"
                )

              let thingAtPosition =
                CursorPosition.ThingAtPosition.SubModuleName(
                  fqName,
                  description
                )

              (hoverInfoForThingAtPosition ctx thingAtPosition r)
              |> Stdlib.Option.Option.Some

            | None ->
              let newCtx =
                Context
                  { branchId = ctx.branchId
                    pm = ctx.pm
                    owner = ctx.owner
                    currentModules =
                      Stdlib.List.append ctx.currentModules [ subModuleName ] }

              collectModuleDeclHoverInfoAtPos newCtx m.declarations position


        else
          Stdlib.Option.Option.None

      | _ -> Stdlib.Option.Option.None)

  node |> Stdlib.List.head


let collectNodeHoverInfoAtPos
  (ctx: Context)
  (decls: List<WrittenTypes.SourceFile.SourceFileDeclaration>)
  (position: LanguageServerProtocol.Position.Position)
  : Stdlib.Option.Option<Info> =
  let node =
    decls
    |> Stdlib.List.filterMap (fun decl ->
      match decl with
      | Type t ->
        // Check if position is within type range for early escape
        if CursorPosition.isLineNumberInRange position t.range then
          collectTypeHoverInfoAtPosition ctx t position
        else
          Stdlib.Option.Option.None

      | Value v ->
        // Check if position is within value range for early escape
        if CursorPosition.isLineNumberInRange position v.range then
          collectValueHoverInfoAtPos ctx v position
        else
          Stdlib.Option.Option.None

      | Function f ->
        // Check if position is within function range for early escape
        if CursorPosition.isLineNumberInRange position f.range then
          collectFnHoverInfoAtPos ctx f position
        else
          Stdlib.Option.Option.None

      | Expr e ->
        collectExpressionHoverInfoAtPos ctx e position

      | Module m ->
        // Check if position is within module range for early escape
        if CursorPosition.isLineNumberInRange position m.range then
          match
            CursorPosition.checkIfPositionWithinRange
              position
              m.keywordModule
          with
          | Some r ->
            let thingAtPosition =
              CursorPosition.ThingAtPosition.Keyword("module")

            (hoverInfoForThingAtPosition ctx thingAtPosition r)
            |> Stdlib.Option.Option.Some

          | None ->
            let (nameRange, name) = m.name

            match
              CursorPosition.checkIfPositionWithinRange position nameRange
            with
            | Some r ->
              let description =
                Stdlib.Option.Option.Some(
                  "TODO: add description when /// comments are supported"
                )

              let thingAtPosition =
                CursorPosition.ThingAtPosition.ModuleName(name, description)

              (hoverInfoForThingAtPosition ctx thingAtPosition r)
              |> Stdlib.Option.Option.Some

            | None ->
              let newCtx =
                Context
                  { branchId = ctx.branchId
                    pm = ctx.pm
                    owner = ctx.owner
                    currentModules =
                      Stdlib.List.append ctx.currentModules [ name ] }

              collectModuleDeclHoverInfoAtPos newCtx m.declarations position

        else
          Stdlib.Option.Option.None

      | SubModule m ->
        // Check if position is within submodule range for early escape
        if CursorPosition.isLineNumberInRange position m.range then
          match
            CursorPosition.checkIfPositionWithinRange
              position
              m.keywordModule
          with
          | Some r ->
            let thingAtPosition =
              CursorPosition.ThingAtPosition.Keyword("module")

            (hoverInfoForThingAtPosition ctx thingAtPosition r)
            |> Stdlib.Option.Option.Some

          | None ->
            let (nameRange, subModuleName) = m.name

            match
              CursorPosition.checkIfPositionWithinRange position nameRange
            with
            | Some r ->
              let fqName =
                (Stdlib.String.join ctx.currentModules ".")
                |> (fun currentModules ->
                  if currentModules == "" then
                    subModuleName
                  else
                    currentModules ++ "." ++ subModuleName)

              let description =
                Stdlib.Option.Option.Some(
                  "TODO: add description when /// comments are supported"
                )

              let thingAtPosition =
                CursorPosition.ThingAtPosition.SubModuleName(
                  fqName,
                  description
                )

              (hoverInfoForThingAtPosition ctx thingAtPosition r)
              |> Stdlib.Option.Option.Some

            | None ->
              let newCtx =
                Context
                  { branchId = ctx.branchId
                    pm = ctx.pm
                    owner = ctx.owner
                    currentModules =
                      Stdlib.List.append ctx.currentModules [ subModuleName ] }

              collectModuleDeclHoverInfoAtPos newCtx m.declarations position


        else
          Stdlib.Option.Option.None

      | _ -> Stdlib.Option.Option.None)

  node |> Stdlib.List.head