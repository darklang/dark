module Darklang.LanguageTools.LspServer.Approvals

// LSP handlers for the approvals system

type Json = Stdlib.AltJson.Json

/// Helper to get a string field from JSON params
let getStringField
  (fields: List<String * Json>)
  (key: String)
  : Stdlib.Result.Result<String, String> =
  match Stdlib.List.findFirst fields (fun (k, _) -> k == key) with
  | Some((_, String s)) -> Stdlib.Result.Result.Ok s
  | Some((_, _)) -> Stdlib.Result.Result.Error $"{key} must be a string"
  | None -> Stdlib.Result.Result.Error $"{key} is required"


/// Helper to get an optional string field from JSON params
let getOptionalStringField
  (fields: List<String * Json>)
  (key: String)
  : Stdlib.Option.Option<String> =
  match Stdlib.List.findFirst fields (fun (k, _) -> k == key) with
  | Some((_, String s)) -> Stdlib.Option.Option.Some s
  | _ -> Stdlib.Option.Option.None


/// Helper to get a string list field from JSON params
let getStringListField
  (fields: List<String * Json>)
  (key: String)
  : Stdlib.Result.Result<List<String>, String> =
  match Stdlib.List.findFirst fields (fun (k, _) -> k == key) with
  | Some((_, Array arr)) ->
    arr
    |> Stdlib.List.filterMap (fun item ->
      match item with
      | String s -> Stdlib.Option.Option.Some s
      | _ -> Stdlib.Option.Option.None)
    |> Stdlib.Result.Result.Ok
  | Some((_, _)) -> Stdlib.Result.Result.Error $"{key} must be an array"
  | None -> Stdlib.Result.Result.Error $"{key} is required"


/// Helper to resolve account name to UUID
let resolveAccount (name: String) : Stdlib.Result.Result<Uuid, String> =
  match Builtin.pmGetAccountByName name with
  | Some id -> Stdlib.Result.Result.Ok id
  | None -> Stdlib.Result.Result.Error $"Unknown account: {name}"


/// Helper to parse UUID string
let parseUuid (s: String) (fieldName: String) : Stdlib.Result.Result<Uuid, String> =
  match Stdlib.Uuid.parse s with
  | Ok id -> Stdlib.Result.Result.Ok id
  | Error _ -> Stdlib.Result.Result.Error $"Invalid {fieldName}: {s}"


/// Helper to get an optional UUID field from JSON params
let getOptionalUuidField
  (fields: List<String * Json>)
  (key: String)
  : Stdlib.Result.Result<Stdlib.Option.Option<Uuid>, String> =
  match Stdlib.List.findFirst fields (fun (k, _) -> k == key) with
  | Some((_, String s)) ->
    match Stdlib.Uuid.parse s with
    | Ok id -> Stdlib.Result.Result.Ok(Stdlib.Option.Option.Some id)
    | Error _ -> Stdlib.Result.Result.Error $"Invalid {key}: {s}"
  | Some((_, Null)) -> Stdlib.Result.Result.Ok(Stdlib.Option.Option.None)
  | Some((_, _)) -> Stdlib.Result.Result.Error $"{key} must be a string or null"
  | None -> Stdlib.Result.Result.Ok(Stdlib.Option.Option.None)


// -- Param types for each request --

type AccountParams = { accountId: Uuid }

type RequestIdParams = { approvalRequestId: Uuid }

type ReviewerParams =
  { approvalRequestId: Uuid
    reviewerId: Uuid }

type ReviewerWithReasonParams =
  { approvalRequestId: Uuid
    reviewerId: Uuid
    reason: String }

type ReviewerWithCommentParams =
  { approvalRequestId: Uuid
    reviewerId: Uuid
    comment: String }

type LocationsParams =
  { approvalRequestId: Stdlib.Option.Option<Uuid>
    locationIds: List<String>
    reviewerId: Uuid }

type LocationsWithReasonParams =
  { approvalRequestId: Stdlib.Option.Option<Uuid>
    locationIds: List<String>
    reviewerId: Uuid
    reason: String }

type SubmitterParams =
  { approvalRequestId: Uuid
    submitterId: Uuid }

type CreateRequestParams =
  { accountId: Uuid
    targetNamespace: String
    locationIds: List<String>
    title: Stdlib.Option.Option<String>
    description: Stdlib.Option.Option<String> }


// -- Parsers --

let parseAccountParams
  (fields: List<String * Json>)
  : Stdlib.Result.Result<AccountParams, String> =
  (getStringField fields "accountID")
  |> Stdlib.Result.andThen (fun name -> resolveAccount name)
  |> Stdlib.Result.map (fun id -> AccountParams { accountId = id })


let parseRequestIdParams
  (fields: List<String * Json>)
  : Stdlib.Result.Result<RequestIdParams, String> =
  (getStringField fields "requestId")
  |> Stdlib.Result.andThen (fun s -> parseUuid s "request ID")
  |> Stdlib.Result.map (fun id -> RequestIdParams { approvalRequestId = id })


let parseReviewerParams
  (fields: List<String * Json>)
  : Stdlib.Result.Result<ReviewerParams, String> =
  let requestIdResult =
    (getStringField fields "requestId")
    |> Stdlib.Result.andThen (fun s -> parseUuid s "request ID")

  let reviewerResult =
    (getStringField fields "reviewerId")
    |> Stdlib.Result.andThen (fun name -> resolveAccount name)

  match (requestIdResult, reviewerResult) with
  | (Ok reqId, Ok revId) ->
    Stdlib.Result.Result.Ok(
      ReviewerParams
        { approvalRequestId = reqId
          reviewerId = revId }
    )
  | (Error e, _) -> Stdlib.Result.Result.Error e
  | (_, Error e) -> Stdlib.Result.Result.Error e


let parseReviewerWithReasonParams
  (fields: List<String * Json>)
  : Stdlib.Result.Result<ReviewerWithReasonParams, String> =
  let requestIdResult =
    (getStringField fields "requestId")
    |> Stdlib.Result.andThen (fun s -> parseUuid s "request ID")

  let reviewerResult =
    (getStringField fields "reviewerId")
    |> Stdlib.Result.andThen (fun name -> resolveAccount name)

  let reason =
    (getOptionalStringField fields "reason")
    |> Stdlib.Option.withDefault ""

  match (requestIdResult, reviewerResult) with
  | (Ok reqId, Ok revId) ->
    Stdlib.Result.Result.Ok(
      ReviewerWithReasonParams
        { approvalRequestId = reqId
          reviewerId = revId
          reason = reason }
    )
  | (Error e, _) -> Stdlib.Result.Result.Error e
  | (_, Error e) -> Stdlib.Result.Result.Error e


let parseReviewerWithCommentParams
  (fields: List<String * Json>)
  : Stdlib.Result.Result<ReviewerWithCommentParams, String> =
  let requestIdResult =
    (getStringField fields "requestId")
    |> Stdlib.Result.andThen (fun s -> parseUuid s "request ID")

  let reviewerResult =
    (getStringField fields "reviewerId")
    |> Stdlib.Result.andThen (fun name -> resolveAccount name)

  let comment =
    (getOptionalStringField fields "comment")
    |> Stdlib.Option.withDefault ""

  match (requestIdResult, reviewerResult) with
  | (Ok reqId, Ok revId) ->
    Stdlib.Result.Result.Ok(
      ReviewerWithCommentParams
        { approvalRequestId = reqId
          reviewerId = revId
          comment = comment }
    )
  | (Error e, _) -> Stdlib.Result.Result.Error e
  | (_, Error e) -> Stdlib.Result.Result.Error e


let parseLocationsParams
  (fields: List<String * Json>)
  : Stdlib.Result.Result<LocationsParams, String> =
  let requestIdResult = getOptionalUuidField fields "requestId"
  let locationIdsResult = getStringListField fields "locationIds"

  let reviewerResult =
    (getStringField fields "reviewerId")
    |> Stdlib.Result.andThen (fun name -> resolveAccount name)

  match (requestIdResult, locationIdsResult, reviewerResult) with
  | (Ok reqId, Ok locIds, Ok revId) ->
    Stdlib.Result.Result.Ok(
      LocationsParams
        { approvalRequestId = reqId
          locationIds = locIds
          reviewerId = revId }
    )
  | (Error e, _, _) -> Stdlib.Result.Result.Error e
  | (_, Error e, _) -> Stdlib.Result.Result.Error e
  | (_, _, Error e) -> Stdlib.Result.Result.Error e


let parseLocationsWithReasonParams
  (fields: List<String * Json>)
  : Stdlib.Result.Result<LocationsWithReasonParams, String> =
  let requestIdResult = getOptionalUuidField fields "requestId"
  let locationIdsResult = getStringListField fields "locationIds"

  let reviewerResult =
    (getStringField fields "reviewerId")
    |> Stdlib.Result.andThen (fun name -> resolveAccount name)

  let reason =
    (getOptionalStringField fields "reason")
    |> Stdlib.Option.withDefault ""

  match (requestIdResult, locationIdsResult, reviewerResult) with
  | (Ok reqId, Ok locIds, Ok revId) ->
    Stdlib.Result.Result.Ok(
      LocationsWithReasonParams
        { approvalRequestId = reqId
          locationIds = locIds
          reviewerId = revId
          reason = reason }
    )
  | (Error e, _, _) -> Stdlib.Result.Result.Error e
  | (_, Error e, _) -> Stdlib.Result.Result.Error e
  | (_, _, Error e) -> Stdlib.Result.Result.Error e


let parseSubmitterParams
  (fields: List<String * Json>)
  : Stdlib.Result.Result<SubmitterParams, String> =
  let requestIdResult =
    (getStringField fields "requestId")
    |> Stdlib.Result.andThen (fun s -> parseUuid s "request ID")

  let submitterResult =
    (getStringField fields "submitterId")
    |> Stdlib.Result.andThen (fun name -> resolveAccount name)

  match (requestIdResult, submitterResult) with
  | (Ok reqId, Ok subId) ->
    Stdlib.Result.Result.Ok(
      SubmitterParams
        { approvalRequestId = reqId
          submitterId = subId }
    )
  | (Error e, _) -> Stdlib.Result.Result.Error e
  | (_, Error e) -> Stdlib.Result.Result.Error e


let parseCreateRequestParams
  (fields: List<String * Json>)
  : Stdlib.Result.Result<CreateRequestParams, String> =
  let accountResult =
    (getStringField fields "accountID")
    |> Stdlib.Result.andThen (fun name -> resolveAccount name)

  let namespaceResult = getStringField fields "targetNamespace"
  let locationIdsResult = getStringListField fields "locationIds"
  let title = getOptionalStringField fields "title"
  let description = getOptionalStringField fields "description"

  match (accountResult, namespaceResult, locationIdsResult) with
  | (Ok accId, Ok ns, Ok locIds) ->
    Stdlib.Result.Result.Ok(
      CreateRequestParams
        { accountId = accId
          targetNamespace = ns
          locationIds = locIds
          title = title
          description = description }
    )
  | (Error e, _, _) -> Stdlib.Result.Result.Error e
  | (_, Error e, _) -> Stdlib.Result.Result.Error e
  | (_, _, Error e) -> Stdlib.Result.Result.Error e


/// Send an error response
let sendErrorResponse
  (state: LspState)
  (requestId: JsonRPC.RequestId)
  (errorMsg: String)
  : LspState =
  log errorMsg

  let response =
    (JsonRPC.Response.Ok.make
      (Stdlib.Option.Option.Some requestId)
      (Json.Object
        [ ("success", Json.Bool false)
          ("error", Json.String errorMsg) ]))
    |> Stdlib.AltJson.format

  logAndSendToClient response
  state


/// Handle dark/listPendingLocations request
/// Returns pending locations for the given account
let handleListPendingLocationsRequest
  (state: LspState)
  (requestId: JsonRPC.RequestId)
  (accountID: Uuid)
  : LspState =
  let locations = Builtin.scmApprovalsListPendingLocationsWithDetails accountID state.branchID

  let locationsJson =
    locations
    |> Stdlib.List.map (fun loc ->
      let modulesArray =
        if loc.modules == "" then
          []
        else
          loc.modules
          |> Stdlib.String.split "."
          |> Stdlib.List.map (fun m -> Stdlib.AltJson.Json.String m)

      Stdlib.AltJson.Json.Object
        [ ("locationId", Stdlib.AltJson.Json.String loc.locationId)
          ("namespace", Stdlib.AltJson.Json.String loc.namespace_)
          ("modules", Stdlib.AltJson.Json.Array modulesArray)
          ("name", Stdlib.AltJson.Json.String loc.name)
          ("itemType", Stdlib.AltJson.Json.String loc.itemType) ])

  let response =
    (JsonRPC.Response.Ok.make
      (Stdlib.Option.Option.Some requestId)
      (Stdlib.AltJson.Json.Array locationsJson))
    |> Stdlib.AltJson.format

  logAndSendToClient response
  state


/// Handle dark/listIncomingApprovalRequests request
/// Returns incoming approval requests for namespaces the account can review
let handleListIncomingApprovalRequestsRequest
  (state: LspState)
  (requestId: JsonRPC.RequestId)
  (accountID: Uuid)
  : LspState =
  let requests = Builtin.scmApprovalsListIncomingRequests accountID

  let requestsJson =
    requests
    |> Stdlib.List.map (fun request ->
      let items = Builtin.scmApprovalsGetApprovalRequestLocations request.id
      let locationCount = Stdlib.List.length items

      Stdlib.AltJson.Json.Object
        [ ("id", Stdlib.AltJson.Json.String (Stdlib.Uuid.toString request.id))
          ("createdBy", Stdlib.AltJson.Json.String (Stdlib.Uuid.toString request.createdBy))
          ("targetNamespace", Stdlib.AltJson.Json.String request.targetNamespace)
          ("title",
            match request.title with
            | Some t -> Stdlib.AltJson.Json.String t
            | None -> Stdlib.AltJson.Json.Null)
          ("description",
            match request.description with
            | Some d -> Stdlib.AltJson.Json.String d
            | None -> Stdlib.AltJson.Json.Null)
          ("status",
            match request.status with
            | Open -> Stdlib.AltJson.Json.String "open"
            | Closed -> Stdlib.AltJson.Json.String "closed")
          ("locationCount", Stdlib.AltJson.Json.Number (Stdlib.Int64.toFloat locationCount)) ])

  let response =
    (JsonRPC.Response.Ok.make
      (Stdlib.Option.Option.Some requestId)
      (Stdlib.AltJson.Json.Array requestsJson))
    |> Stdlib.AltJson.format

  logAndSendToClient response
  state


/// Handle dark/listOutgoingApprovalRequests request
/// Returns outgoing approval requests created by the account
let handleListOutgoingApprovalRequestsRequest
  (state: LspState)
  (requestId: JsonRPC.RequestId)
  (accountID: Uuid)
  : LspState =
  let requests = Builtin.scmApprovalsListOutgoingRequests accountID

  let requestsJson =
    requests
    |> Stdlib.List.map (fun request ->
      let items = Builtin.scmApprovalsGetApprovalRequestLocations request.id
      let locationCount = Stdlib.List.length items

      Stdlib.AltJson.Json.Object
        [ ("id", Stdlib.AltJson.Json.String (Stdlib.Uuid.toString request.id))
          ("createdBy", Stdlib.AltJson.Json.String (Stdlib.Uuid.toString request.createdBy))
          ("targetNamespace", Stdlib.AltJson.Json.String request.targetNamespace)
          ("title",
            match request.title with
            | Some t -> Stdlib.AltJson.Json.String t
            | None -> Stdlib.AltJson.Json.Null)
          ("description",
            match request.description with
            | Some d -> Stdlib.AltJson.Json.String d
            | None -> Stdlib.AltJson.Json.Null)
          ("status",
            match request.status with
            | Open -> Stdlib.AltJson.Json.String "open"
            | Closed -> Stdlib.AltJson.Json.String "closed")
          ("locationCount", Stdlib.AltJson.Json.Number (Stdlib.Int64.toFloat locationCount)) ])

  let response =
    (JsonRPC.Response.Ok.make
      (Stdlib.Option.Option.Some requestId)
      (Stdlib.AltJson.Json.Array requestsJson))
    |> Stdlib.AltJson.format

  logAndSendToClient response
  state


/// Handle dark/getApprovalRequestDetails request
/// Returns details of a specific approval request including its locations
let handleGetApprovalRequestDetailsRequest
  (state: LspState)
  (requestId: JsonRPC.RequestId)
  (approvalRequestId: Uuid)
  : LspState =
  let requestOpt = Builtin.scmApprovalsGetApprovalRequest approvalRequestId

  let responseJson =
    match requestOpt with
    | Some request ->
      // Use the new function that includes full location details
      let locations =
        Builtin.scmApprovalsGetApprovalRequestLocationsWithDetails approvalRequestId

      let locationsJson =
        locations
        |> Stdlib.List.map (fun loc ->
          Stdlib.AltJson.Json.Object
            [ ("locationId", Stdlib.AltJson.Json.String loc.locationId)
              ("name", Stdlib.AltJson.Json.String loc.name)
              ("itemType", Stdlib.AltJson.Json.String loc.itemType)
              ("status",
                match loc.approvalStatus with
                | Pending -> Stdlib.AltJson.Json.String "pending"
                | Approved -> Stdlib.AltJson.Json.String "approved"
                | Rejected _ -> Stdlib.AltJson.Json.String "rejected"
                | ChangesRequested _ -> Stdlib.AltJson.Json.String "changes_requested") ])

      Stdlib.AltJson.Json.Object
        [ ("id", Stdlib.AltJson.Json.String (Stdlib.Uuid.toString request.id))
          ("createdBy", Stdlib.AltJson.Json.String (Stdlib.Uuid.toString request.createdBy))
          ("targetNamespace", Stdlib.AltJson.Json.String request.targetNamespace)
          ("title",
            match request.title with
            | Some t -> Stdlib.AltJson.Json.String t
            | None -> Stdlib.AltJson.Json.Null)
          ("description",
            match request.description with
            | Some d -> Stdlib.AltJson.Json.String d
            | None -> Stdlib.AltJson.Json.Null)
          ("status",
            match request.status with
            | Open -> Stdlib.AltJson.Json.String "open"
            | Closed -> Stdlib.AltJson.Json.String "closed")
          ("locations", Stdlib.AltJson.Json.Array locationsJson) ]

    | None -> Stdlib.AltJson.Json.Null

  let response =
    (JsonRPC.Response.Ok.make
      (Stdlib.Option.Option.Some requestId)
      responseJson)
    |> Stdlib.AltJson.format

  logAndSendToClient response
  state


/// Helper: Set status on specific locations and send success response
let setLocationStatuses
  (state: LspState)
  (requestId: JsonRPC.RequestId)
  (approvalRequestId: Uuid)
  (locationIds: List<String>)
  (status: Darklang.SCM.Approvals.ApprovalStatus)
  (reviewerId: Uuid)
  : LspState =
  locationIds
  |> Stdlib.List.iter (fun locationId ->
    Builtin.scmApprovalsSetLocationStatus approvalRequestId locationId status reviewerId)

  Builtin.scmApprovalsUpdateRequestStatusIfComplete approvalRequestId

  let response =
    (JsonRPC.Response.Ok.make
      (Stdlib.Option.Option.Some requestId)
      (Stdlib.AltJson.Json.Object [ ("success", Stdlib.AltJson.Json.Bool true) ]))
    |> Stdlib.AltJson.format

  logAndSendToClient response
  state


/// Helper: Get all location IDs for an approval request
let getAllLocationIds (approvalRequestId: Uuid) : List<String> =
  (Builtin.scmApprovalsGetApprovalRequestLocations approvalRequestId)
  |> Stdlib.List.map (fun loc -> loc.locationId)


/// Handle dark/approveRequest request
/// Approves all locations in an approval request
let handleApproveRequest
  (state: LspState)
  (requestId: JsonRPC.RequestId)
  (approvalRequestId: Uuid)
  (reviewerId: Uuid)
  : LspState =
  let locationIds = getAllLocationIds approvalRequestId

  setLocationStatuses
    state
    requestId
    approvalRequestId
    locationIds
    (Darklang.SCM.Approvals.ApprovalStatus.Approved)
    reviewerId


/// Handle dark/rejectRequest request
/// Rejects all locations in an approval request
let handleRejectRequest
  (state: LspState)
  (requestId: JsonRPC.RequestId)
  (approvalRequestId: Uuid)
  (reviewerId: Uuid)
  (reason: String)
  : LspState =
  let locationIds = getAllLocationIds approvalRequestId

  setLocationStatuses
    state
    requestId
    approvalRequestId
    locationIds
    (Darklang.SCM.Approvals.ApprovalStatus.Rejected reason)
    reviewerId


/// Handle dark/approveLocations request
/// Approves specific locations - either in an approval request (partial approval)
/// or directly (for own-namespace items when requestId is None)
let handleApproveLocations
  (state: LspState)
  (requestId: JsonRPC.RequestId)
  (approvalRequestId: Stdlib.Option.Option<Uuid>)
  (locationIds: List<String>)
  (reviewerId: Uuid)
  : LspState =
  match approvalRequestId with
  | Some reqId ->
    // Approval request workflow - update request_items table
    setLocationStatuses
      state
      requestId
      reqId
      locationIds
      (Darklang.SCM.Approvals.ApprovalStatus.Approved)
      reviewerId
  | None ->
    // Direct approval - no request, approve each location
    let results =
      locationIds
      |> Stdlib.List.map (fun locId ->
        Builtin.scmApprovalsApproveLocationDirectly locId reviewerId)

    let count =
      results |> Stdlib.List.filter (fun r -> r) |> Stdlib.List.length

    let response =
      (JsonRPC.Response.Ok.make
        (Stdlib.Option.Option.Some requestId)
        (Stdlib.AltJson.Json.Object
          [ ("success", Stdlib.AltJson.Json.Bool true)
            ("count", Stdlib.AltJson.Json.Number (Stdlib.Int64.toFloat count)) ]))
      |> Stdlib.AltJson.format

    logAndSendToClient response
    state


/// Handle dark/rejectLocations request
/// Rejects specific locations in an approval request
let handleRejectLocations
  (state: LspState)
  (requestId: JsonRPC.RequestId)
  (approvalRequestId: Stdlib.Option.Option<Uuid>)
  (locationIds: List<String>)
  (reviewerId: Uuid)
  (reason: String)
  : LspState =
  match approvalRequestId with
  | Some reqId ->
    setLocationStatuses
      state
      requestId
      reqId
      locationIds
      (Darklang.SCM.Approvals.ApprovalStatus.Rejected reason)
      reviewerId
  | None ->
    // Rejection without requestId is not supported
    sendErrorResponse state requestId "requestId is required for rejection."


/// Handle dark/requestChangesForRequest request
/// Requests changes for all locations in an approval request
let handleRequestChangesRequest
  (state: LspState)
  (requestId: JsonRPC.RequestId)
  (approvalRequestId: Uuid)
  (reviewerId: Uuid)
  (comment: String)
  : LspState =
  let locationIds = getAllLocationIds approvalRequestId

  setLocationStatuses
    state
    requestId
    approvalRequestId
    locationIds
    (Darklang.SCM.Approvals.ApprovalStatus.ChangesRequested comment)
    reviewerId


/// Handle dark/withdrawApprovalRequest request
/// Withdraws an approval request (only by the creator)
let handleWithdrawRequest
  (state: LspState)
  (requestId: JsonRPC.RequestId)
  (approvalRequestId: Uuid)
  (submitterId: Uuid)
  : LspState =
  let success = Builtin.scmApprovalsWithdrawRequest approvalRequestId submitterId

  let response =
    (JsonRPC.Response.Ok.make
      (Stdlib.Option.Option.Some requestId)
      (Stdlib.AltJson.Json.Object [ ("success", Stdlib.AltJson.Json.Bool success) ]))
    |> Stdlib.AltJson.format

  logAndSendToClient response
  state


/// Handle dark/createApprovalRequest request
/// Creates a new approval request for pending locations
let handleCreateApprovalRequest
  (state: LspState)
  (requestId: JsonRPC.RequestId)
  (accountID: Uuid)
  (targetNamespace: String)
  (locationIds: List<String>)
  (title: Stdlib.Option.Option<String>)
  (description: Stdlib.Option.Option<String>)
  : LspState =
  let request =
    Builtin.scmApprovalsCreateApprovalRequest
      accountID
      targetNamespace
      locationIds
      title
      description
      (Stdlib.Option.Option.None)

  let response =
    (JsonRPC.Response.Ok.make
      (Stdlib.Option.Option.Some requestId)
      (Stdlib.AltJson.Json.Object
        [ ("id", Stdlib.AltJson.Json.String (Stdlib.Uuid.toString request.id))
          ("success", Stdlib.AltJson.Json.Bool true) ]))
    |> Stdlib.AltJson.format

  logAndSendToClient response
  state


/// Handle dark/checkNamespaceAccess request
/// Returns whether the account has access to the given namespace
let handleCheckNamespaceAccess
  (state: LspState)
  (requestId: JsonRPC.RequestId)
  (accountID: Uuid)
  (targetNamespace: String)
  : LspState =
  let hasAccess = Builtin.scmApprovalsHasAccessToNamespace accountID targetNamespace

  let response =
    (JsonRPC.Response.Ok.make
      (Stdlib.Option.Option.Some requestId)
      (Stdlib.AltJson.Json.Object
        [ ("hasAccess", Stdlib.AltJson.Json.Bool hasAccess) ]))
    |> Stdlib.AltJson.format

  logAndSendToClient response
  state
