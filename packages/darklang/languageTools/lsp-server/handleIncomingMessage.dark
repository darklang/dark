module Darklang.LanguageTools.LspServer


let convertParserRangeToLspRange
  (range: Parser.Range)
  : LanguageServerProtocol.Range.Range =
  let lineStart =
    range.start.row
    |> Stdlib.UInt64.fromInt64
    |> Stdlib.Option.withDefault 0UL

  let characterStart =
    range.start.column
    |> Stdlib.UInt64.fromInt64
    |> Stdlib.Option.withDefault 0UL

  let lineEnd =
    range.end_.row
    |> Stdlib.UInt64.fromInt64
    |> Stdlib.Option.withDefault 0UL

  let characterEnd =
    range.end_.column
    |> Stdlib.UInt64.fromInt64
    |> Stdlib.Option.withDefault 0UL

  LanguageServerProtocol.Range.Range
    { start =
        LanguageServerProtocol.Position.Position
          { line = lineStart
            character = characterStart }
      end_ =
        LanguageServerProtocol.Position.Position
          { line = lineEnd
            character = characterEnd } }


let createDiagnostic
  (severity: LanguageServerProtocol.DiagnosticSeverity.DiagnosticSeverity)
  (range: Parser.Range)
  (message: String)
  : LanguageServerProtocol.Diagnostic.Diagnostic =
  LanguageServerProtocol.Diagnostic.Diagnostic
    { range = convertParserRangeToLspRange range
      severity = Stdlib.Option.Option.Some severity
      code = Stdlib.Option.Option.None
      codeDescription = Stdlib.Option.Option.None
      source = Stdlib.Option.Option.None
      message = message
      tags = Stdlib.Option.Option.None
      relatedInformation = Stdlib.Option.Option.None
      data = Stdlib.Option.Option.None }

let createWarningDiagnostic
  (range: Parser.Range)
  (message: String)
  : LanguageServerProtocol.Diagnostic.Diagnostic =
  createDiagnostic
    LanguageServerProtocol.DiagnosticSeverity.DiagnosticSeverity.Warning
    range
    message

let createErrorDiagnostic
  (range: Parser.Range)
  (message: String)
  : LanguageServerProtocol.Diagnostic.Diagnostic =
  createDiagnostic
    LanguageServerProtocol.DiagnosticSeverity.DiagnosticSeverity.Error
    range
    message

let createInfoDiagnostic
  (range: Parser.Range)
  (message: String)
  : LanguageServerProtocol.Diagnostic.Diagnostic =
  createDiagnostic
    LanguageServerProtocol.DiagnosticSeverity.DiagnosticSeverity.Information
    range
    message

let createHintDiagnostic
  (range: Parser.Range)
  (message: String)
  : LanguageServerProtocol.Diagnostic.Diagnostic =
  createDiagnostic
    LanguageServerProtocol.DiagnosticSeverity.DiagnosticSeverity.Hint
    range
    message


let sendDiagnostic
  (uri: LanguageServerProtocol.DocumentUri)
  (diagnostic:
    List<LanguageServerProtocol.Diagnostic.Diagnostic>)
  : Unit =
  let diagnosticsJson =
    LanguageServerProtocol
      .Messages
      .PublishDiagnostics
      .PublishDiagnosticsParams
      .toJson (
        LanguageServerProtocol.Messages.PublishDiagnostics.PublishDiagnosticsParams.PublishDiagnosticsParams
          { uri = uri
            version = Stdlib.Option.Option.None
            diagnostics = diagnostic }
      )

  let diagnosticsJson =
    JsonRPC.Request.RequestParams.Array [ diagnosticsJson ]

  (JsonRPC.Request.makeNotificationString
    "textDocument/publishDiagnostics"
    (diagnosticsJson |> Stdlib.Option.Option.Some))
  |> logAndSendToClient

/// This is how we handle incoming requests from the client.
///
/// (this is the core of Darklang's LSP server)
let handleIncomingMessage
  (state: LspState)
  (r: JsonRPC.Request.Request)
  : LspState =
  let currentState =
    match LanguageServerProtocol.parseIncomingMessage r with
    | InitializeRequest ->
      match r.id with
      | Some requestId -> handleInitializeRequest requestId
      | None ->
        log "Error: initialize request missing ID"
        { state with initialized = false; shouldShutdown = true }

    | Initialized -> // notification
      log "Received 'initialized' notification from client - server is now fully ready"
      { state with initialized = true }

    | SetTrace -> // notification
      log "TODO we should do something with this"
      state

    // asks the server to shut down but not exit
    | Shutdown -> // request
      log "shutting down"

      let response =
        (JsonRPC.Response.Ok.make (Some r.id) Json.Null)
        |> Stdlib.AltJson.format

      logAndSendToClient response
      { state with shouldShutdown = true }


    // -- textDocument synchronization
    | TextDocumentDidOpenNotification requestParams ->
      log $"adding/setting document {requestParams.textDocument.uri}"
      DocSync.handleTextDocumentDidOpen state requestParams

    | TextDocumentDidSaveNotification requestParams ->
      DocSync.handleTextDocumentDidSave state requestParams

    | TextDocumentDidChangeNotification requestParams ->
      log $"updating document {requestParams.textDocument.uri}"
      DocSync.handleTextDocumentDidChange state requestParams

    | TextDocumentDidCloseNotification requestParams ->
      log $"removing document from documentsInScope"
      DocSync.handleTextDocumentDidClose state requestParams


    // -- completion (autocomplete)
    | TextDocumentCompletionRequest(requestId, requestParams) ->
      log $"got completion request for {requestParams.textDocument.uri}"
      Completions.handleCompletionRequest state requestId requestParams


    // -- semantic tokens (which provides syntax highlighting)
    | TextDocumentSemanticTokensRequest(requestId, requestParams) ->
      log $"got semanticTokens request for {requestParams.textDocument.uri}"
      SemanticTokens.handleSemanticTokensRequest state requestId requestParams

    // -- hover
    | TextDocumentHoverRequest(requestId, requestParams) ->
      log $"got hover request for {requestParams.textDocument.uri}"
      Hover.handleHoverRequest state requestId requestParams

    // // -- The server should exit with success code 0 if the shutdown request has been received before; otherwise with error code 1
    // | Exit ->
    //   log "Exit notification received"
    //   if state.shouldShutdown then
    //     log "Exiting with success code 0 (shutdown request received)"
    //     //TODO
    //   else
    //     log "Exiting with error code 1 (shutdown request not received)"
    //     //TODO
    //   state

    // | _ when state.shouldShutdown ->
    //   log "Request received after shutdown, responding with InvalidRequest"
    //   let response =
    //     (JsonRPC.Response.Error.make
    //       (Stdlib.Option.Option.Some r.id)
    //       JsonRPC.Response.Error.KnownErrorCodes.invalidRequest
    //       "Invalid request: server is shutting down"
    //       Stdlib.Option.Option.None)
    //     |> Stdlib.AltJson.format

    //   logAndSendToClient response
    //   state

    // -- other
    | Other jsonRpcRequest ->
      match
        (jsonRpcRequest.method, jsonRpcRequest.id, jsonRpcRequest.params)
      with
      | ("fileSystem/read", Some requestId, Some(Object p)) ->
        log "Handling fileSystem/read request"

        match
          LspExtension.FileSystemProvider.ReadFile.ReadFileParams.fromJson (
            Stdlib.AltJson.Json.Object p
          )
        with
        | Ok params ->
          FileSystemProvider.ReadFile.handleReadFileRequest
            state
            requestId
            params

        | Error err ->
          log $"Error parsing fileSystem/read params: {err}"
          // Send an error response so the client doesn't hang
          let response =
            (JsonRPC.Response.Error.make
              (Stdlib.Option.Option.Some requestId)
              JsonRPC.Response.Error.KnownErrorCodes.invalidParams
              $"Failed to parse read params: {err}"
              Stdlib.Option.Option.None)
            |> Stdlib.AltJson.format

          logAndSendToClient response
          state

      | ("fileSystem/write", Some requestId, Some(Object p)) ->
        log "Handling fileSystem/write request"

        match
          LspExtension.FileSystemProvider.WriteFile.WriteFileParams.fromJson (
            Stdlib.AltJson.Json.Object p
          )
        with
        | Ok params ->
          FileSystemProvider.WriteFile.handleWriteFileRequest
            state
            requestId
            params

        | Error err ->
          log $"Error parsing fileSystem/write params: {err}"
          FileSystemProvider.WriteFile.sendErrorResponse
            state
            requestId
            [ $"Failed to parse write params: {err}" ]

      | _ ->
        let r = jsonRpcRequest

        match (r.method, r.id, r.params) with
        | ("dark/getRootNodes", Some requestId, _) ->
          TreeView.handleGetRootNodesRequest state requestId

        | ("dark/getChildNodes",
          Some requestId,
          Some(Object [ ("nodeId", String nodeId) ])) ->
          TreeView.handleGetChildNodesRequest state requestId nodeId

        | ("dark/getBranches", Some requestId, _) ->
          Branches.handleGetBranchesRequest state requestId

        | ("dark/createBranch",
          Some requestId,
          Some(Object [ ("name", String branchName) ])) ->
          Branches.handleCreateBranchRequest state requestId branchName

        | ("dark/getPendingOps", Some requestId, params) ->
          PendingOps.handleGetPendingOpsRequest state requestId params

        | ("dark/switchBranch", Some requestId, Some(Object [ ("branchID", String branchID) ])) ->
          SwitchBranch.handleSwitchBranchRequest state requestId branchID

        | ("dark/clearBranch", Some requestId, _) ->
          Branches.handleClearBranchRequest state requestId

        | ("dark/listInstances", Some requestId, _) ->
          Sync.handleListInstancesRequest state requestId

        | ("dark/setCurrentAccount", Some requestId, Some(Object params)) ->
          let accountName =
            params
            |> Stdlib.List.findFirst (fun (k, _) -> k == "accountID")
            |> Stdlib.Option.map (fun (_, v) ->
              match v with
              | String s -> s
              | _ -> "")
            |> Stdlib.Option.withDefault ""

          let newState =
            if accountName == "" then
              { state with accountID = Stdlib.Option.Option.None }
            else
              // Look up the account UUID by name
              let accountUuid = Builtin.pmGetAccountByName accountName
              { state with accountID = accountUuid }

          // Clear caches so updated data is visible with the new account context
          Builtin.pmClearAllCaches ()

          let response =
            (JsonRPC.Response.Ok.make
              (Stdlib.Option.Option.Some requestId)
              (Stdlib.AltJson.Json.Object [ ("success", Stdlib.AltJson.Json.Bool true) ]))
            |> Stdlib.AltJson.format

          logAndSendToClient response
          newState

        | ("dark/listAccounts", Some requestId, _) ->
          Accounts.handleListAccountsRequest state requestId

        | ("dark/listPendingLocations", Some requestId, Some(Object params)) ->
          match Approvals.parseAccountParams params with
          | Ok p ->
            Approvals.handleListPendingLocationsRequest state requestId p.accountId
          | Error msg ->
            log msg
            let response =
              (JsonRPC.Response.Ok.make
                (Stdlib.Option.Option.Some requestId)
                (Stdlib.AltJson.Json.Array []))
              |> Stdlib.AltJson.format
            logAndSendToClient response
            state

        | ("dark/listIncomingApprovalRequests", Some requestId, Some(Object params)) ->
          match Approvals.parseAccountParams params with
          | Ok p ->
            Approvals.handleListIncomingApprovalRequestsRequest state requestId p.accountId
          | Error msg ->
            log msg
            let response =
              (JsonRPC.Response.Ok.make
                (Stdlib.Option.Option.Some requestId)
                (Stdlib.AltJson.Json.Array []))
              |> Stdlib.AltJson.format
            logAndSendToClient response
            state

        | ("dark/listOutgoingApprovalRequests", Some requestId, Some(Object params)) ->
          match Approvals.parseAccountParams params with
          | Ok p ->
            Approvals.handleListOutgoingApprovalRequestsRequest state requestId p.accountId
          | Error msg ->
            log msg
            let response =
              (JsonRPC.Response.Ok.make
                (Stdlib.Option.Option.Some requestId)
                (Stdlib.AltJson.Json.Array []))
              |> Stdlib.AltJson.format
            logAndSendToClient response
            state

        | ("dark/getApprovalRequestDetails", Some requestId, Some(Object params)) ->
          match Approvals.parseRequestIdParams params with
          | Ok p ->
            Approvals.handleGetApprovalRequestDetailsRequest state requestId p.approvalRequestId
          | Error msg ->
            log msg
            let response =
              (JsonRPC.Response.Ok.make
                (Stdlib.Option.Option.Some requestId)
                Stdlib.AltJson.Json.Null)
              |> Stdlib.AltJson.format
            logAndSendToClient response
            state

        | ("dark/approveRequest", Some requestId, Some(Object params)) ->
          match Approvals.parseReviewerParams params with
          | Ok p ->
            Approvals.handleApproveRequest state requestId p.approvalRequestId p.reviewerId
          | Error msg ->
            Approvals.sendErrorResponse state requestId msg

        | ("dark/rejectRequest", Some requestId, Some(Object params)) ->
          match Approvals.parseReviewerWithReasonParams params with
          | Ok p ->
            Approvals.handleRejectRequest state requestId p.approvalRequestId p.reviewerId p.reason
          | Error msg ->
            Approvals.sendErrorResponse state requestId msg

        | ("dark/approveLocations", Some requestId, Some(Object params)) ->
          match Approvals.parseLocationsParams params with
          | Ok p ->
            Approvals.handleApproveLocations state requestId p.approvalRequestId p.locationIds p.reviewerId
          | Error msg ->
            Approvals.sendErrorResponse state requestId msg

        | ("dark/rejectLocations", Some requestId, Some(Object params)) ->
          match Approvals.parseLocationsWithReasonParams params with
          | Ok p ->
            Approvals.handleRejectLocations state requestId p.approvalRequestId p.locationIds p.reviewerId p.reason
          | Error msg ->
            Approvals.sendErrorResponse state requestId msg

        | ("dark/requestChangesForRequest", Some requestId, Some(Object params)) ->
          match Approvals.parseReviewerWithCommentParams params with
          | Ok p ->
            Approvals.handleRequestChangesRequest state requestId p.approvalRequestId p.reviewerId p.comment
          | Error msg ->
            Approvals.sendErrorResponse state requestId msg

        | ("dark/withdrawApprovalRequest", Some requestId, Some(Object params)) ->
          match Approvals.parseSubmitterParams params with
          | Ok p ->
            Approvals.handleWithdrawRequest state requestId p.approvalRequestId p.submitterId
          | Error msg ->
            Approvals.sendErrorResponse state requestId msg

        | ("dark/createApprovalRequest", Some requestId, Some(Object params)) ->
          match Approvals.parseCreateRequestParams params with
          | Ok p ->
            Approvals.handleCreateApprovalRequest
              state
              requestId
              p.accountId
              p.targetNamespace
              p.locationIds
              p.title
              p.description
          | Error msg ->
            Approvals.sendErrorResponse state requestId msg

        | ("dark/checkNamespaceAccess", Some requestId, Some(Object params)) ->
          let accountResult =
            (Approvals.getStringField params "accountID")
            |> Stdlib.Result.andThen (fun name -> Approvals.resolveAccount name)

          let namespaceResult = Approvals.getStringField params "namespace"

          match (accountResult, namespaceResult) with
          | (Ok accId, Ok ns) ->
            Approvals.handleCheckNamespaceAccess state requestId accId ns
          | (Error e, _) ->
            Approvals.sendErrorResponse state requestId e
          | (_, Error e) ->
            Approvals.sendErrorResponse state requestId e

        | ("dark/listPendingTodos", Some requestId, Some(Object params)) ->
          match Approvals.parseAccountParams params with
          | Ok p ->
            Todos.handleListPendingTodosRequest state requestId p.accountId
          | Error msg ->
            log msg
            let response =
              (JsonRPC.Response.Ok.make
                (Stdlib.Option.Option.Some requestId)
                (Stdlib.AltJson.Json.Array []))
              |> Stdlib.AltJson.format
            logAndSendToClient response
            state

        | ("dark/dismissTodo", Some requestId, Some(Object params)) ->
          match Todos.parseTodoIdParams params with
          | Ok todoId ->
            Todos.handleDismissTodoRequest state requestId todoId
          | Error msg ->
            Approvals.sendErrorResponse state requestId msg

        | ("dark/listPendingChanges", Some requestId, Some(Object params)) ->
          match Approvals.parseAccountParams params with
          | Ok p ->
            Todos.handleListPendingChangesRequest state requestId p.accountId
          | Error msg ->
            log msg
            let response =
              (JsonRPC.Response.Ok.make
                (Stdlib.Option.Option.Some requestId)
                (Stdlib.AltJson.Json.Array []))
              |> Stdlib.AltJson.format
            logAndSendToClient response
            state

        | ("dark/revertPendingChange", Some requestId, Some(Object params)) ->
          match Todos.parseRevertParams params with
          | Ok(locationId, accountId) ->
            Todos.handleRevertPendingChangeRequest state requestId locationId accountId
          | Error msg ->
            Approvals.sendErrorResponse state requestId msg

        | ("dark/listAvailableUpdates", Some requestId, Some(Object params)) ->
          match Approvals.parseAccountParams params with
          | Ok p ->
            Todos.handleListAvailableUpdatesRequest state requestId p.accountId
          | Error msg ->
            log msg
            let response =
              (JsonRPC.Response.Ok.make
                (Stdlib.Option.Option.Some requestId)
                (Stdlib.AltJson.Json.Array []))
              |> Stdlib.AltJson.format
            logAndSendToClient response
            state

        | ("dark/listAppliedUpdates", Some requestId, Some(Object params)) ->
          match Approvals.parseAccountParams params with
          | Ok p ->
            Todos.handleListAppliedUpdatesRequest state requestId p.accountId
          | Error msg ->
            log msg
            let response =
              (JsonRPC.Response.Ok.make
                (Stdlib.Option.Option.Some requestId)
                (Stdlib.AltJson.Json.Array []))
              |> Stdlib.AltJson.format
            logAndSendToClient response
            state

        | ("dark/listPendingBreakingTodos", Some requestId, Some(Object params)) ->
          match Approvals.parseAccountParams params with
          | Ok p ->
            Todos.handleListPendingBreakingTodosRequest state requestId p.accountId
          | Error msg ->
            log msg
            let response =
              (JsonRPC.Response.Ok.make
                (Stdlib.Option.Option.Some requestId)
                (Stdlib.AltJson.Json.Array []))
              |> Stdlib.AltJson.format
            logAndSendToClient response
            state

        | ("dark/applyUpdates", Some requestId, Some(Object params)) ->
          match Todos.parseTodoIdsParams params with
          | Ok todoIds ->
            Todos.handleApplyUpdatesRequest state requestId todoIds
          | Error msg ->
            Approvals.sendErrorResponse state requestId msg

        | ("dark/revertUpdates", Some requestId, Some(Object params)) ->
          match Todos.parseTodoIdsParams params with
          | Ok todoIds ->
            Todos.handleRevertUpdatesRequest state requestId todoIds
          | Error msg ->
            Approvals.sendErrorResponse state requestId msg

        | other ->
          log $"TODO: we don't yet support this method: {r.method}"
          state

    | _ ->
      log $"TODO: we don't yet support this method: {jsonRpcRequest.method}"
      // TODO: log more than just the method
      state

  currentState