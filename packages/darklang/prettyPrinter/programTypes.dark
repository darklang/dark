// TODO:
//alias PT = LanguageTools.ProgramTypes
//alias RT = Stdlib.RuntimeTypes

// TODO: update all of the 'namePart's to nameToStrings with fn inputs

// CLEANUP split into a few files - easier to manage, at this point.
// i.e. common, typeReference, expr, declarations, packages, sourceFile
module Darklang.PrettyPrinter.ProgramTypes


/// Formats a description string as doc comments
/// Returns empty string if description is empty
let formatDocComment (description: String) : String =
  if description == "" then
    ""
  else
    description
    |> Stdlib.String.split "\n"
    |> Stdlib.List.map (fun line -> $"/// {line}")
    |> Stdlib.String.join "\n"
    |> fun s -> s ++ "\n"


module NameResolutionError =
  let source (nre: LanguageTools.ProgramTypes.NameResolutionError) : String =
    match nre with
    | NotFound names
    | InvalidName names -> Stdlib.String.join names "."

  let error (nre: LanguageTools.ProgramTypes.NameResolutionError) : String =
    match nre with
    | NotFound names -> Stdlib.String.join names "." ++ " not found"
    | InvalidName names -> Stdlib.String.join names "." ++ " is not a valid name"


// Context for relative name resolution - when we know what module we're currently in,
// we can shorten names that share the same prefix
type Context =
  { currentModule: Stdlib.Option.Option<String>
    /// Used to resolve ESelf and EArg expressions when pretty-printing function bodies.
    /// When Some, contains (functionName, argMap) where argMap maps parameter names to indices.
    currentFunction: Stdlib.Option.Option<(String * Dict<Int64>)> }

let defaultContext =
  Context
    { currentModule = Stdlib.Option.Option.None
      currentFunction = Stdlib.Option.Option.None }

let packageNameWithContext
  (ctx: Context)
  (owner: String)
  (modules: List<String>)
  (name: String)
  : String =
  let modulesPart =
    match modules with
    | [] -> ""
    | modules ->
      let modules = Stdlib.String.join modules "."
      $"{modules}."

  let fullName = $"{owner}.{modulesPart}{name}"

  // Try to shorten relative to current context
  match ctx.currentModule with
  | Some currentModule ->
    // If we're in Darklang.Stdlib and referencing Darklang.Stdlib.Option.Option,
    // just show "Option.Option"
    if Stdlib.String.startsWith fullName currentModule then
      let prefix = currentModule ++ "."
      Stdlib.String.dropFirst fullName (Stdlib.String.length prefix)
    else if owner == "Darklang" then
      // For Darklang packages, drop the "Darklang." prefix for brevity
      let withoutDarklang = Stdlib.String.dropFirst fullName 9L // "Darklang.".length
      withoutDarklang
    else
      fullName
  | None ->
    match owner with
    | "Tests" -> $"{modulesPart}{name}"
    | "Darklang" ->
      // For Darklang packages, just show module path
      $"{modulesPart}{name}"
    | _ -> $"{owner}.{modulesPart}{name}"

// CLEANUP: this function exists for backwards compatibility
// Prefer using packageNameWithContext with a proper Context
let packageName
  (owner: String)
  (modules: List<String>)
  (name: String)
  : String =
  packageNameWithContext defaultContext owner modules name


module FQTypeName =
  module Package =
    let atDefinition
      (id: LanguageTools.ProgramTypes.FQTypeName.Package)
      : String =
      match Builtin.pmGetLocationByType id with
      | Some l -> l.name
      | None -> Stdlib.Uuid.toString id

    let fullForReference
      (id: LanguageTools.ProgramTypes.FQTypeName.Package)
      : String =
      match Builtin.pmGetLocationByType id with
      | Some l ->
        packageName l.owner l.modules l.name
      | None -> Stdlib.Uuid.toString id


  let atDefinition
    (t: LanguageTools.ProgramTypes.FQTypeName.FQTypeName)
    : String =
    match t with
    | Package p -> FQTypeName.Package.atDefinition p

  let fullForReference
    (t: LanguageTools.ProgramTypes.FQTypeName.FQTypeName)
    : String =
    match t with
    | Package p ->
      FQTypeName.Package.fullForReference p


module FQValueName =
  module Builtin =
    let fullForReference
      (t: LanguageTools.ProgramTypes.FQValueName.Builtin)
      : String =
      let namePart = t.name

      let versionPart =
        if t.version == 0 then
          ""
        else
          $"_v{Stdlib.Int32.toString t.version}"

      $"Builtin.{namePart}{versionPart}"


  module Package =
    let atDefinition
      (id: LanguageTools.ProgramTypes.FQValueName.Package)
      : String =
      match Builtin.pmGetLocationByValue id with
      | Some l -> l.name
      | None -> Stdlib.Uuid.toString id

    let fullForReference
      (id: LanguageTools.ProgramTypes.FQValueName.Package)
      : String =
      match Builtin.pmGetLocationByValue id with
      | Some l ->
        packageName l.owner l.modules l.name
      | None -> Stdlib.Uuid.toString id



  let atDefinition
    (t: LanguageTools.ProgramTypes.FQValueName.FQValueName)
    : String =
    match t with
    | Builtin b ->
      FQValueName.Builtin.fullForReference b
    | Package p ->
      FQValueName.Package.atDefinition p

  let fullForReference
    (t: LanguageTools.ProgramTypes.FQValueName.FQValueName)
    : String =
    match t with
    | Builtin b ->
      FQValueName.Builtin.fullForReference b
    | Package p ->
      FQValueName.Package.fullForReference p


module FQFnName =
  module Builtin =
    let fullForReference
      (t: LanguageTools.ProgramTypes.FQFnName.Builtin)
      : String =
      let namePart = t.name

      let versionPart =
        if t.version == 0 then
          ""
        else
          $"_v{Stdlib.Int32.toString t.version}"

      $"Builtin.{namePart}{versionPart}"


  module Package =
    let atDefinition
      (id: LanguageTools.ProgramTypes.FQFnName.Package)
      : String =
      match Builtin.pmGetLocationByFn id with
      | Some l -> l.name
      | None -> Stdlib.Uuid.toString id

    let fullForReference
      (id: LanguageTools.ProgramTypes.FQFnName.Package)
      : String =
      match Builtin.pmGetLocationByFn id with
      | Some l ->
        packageName l.owner l.modules l.name
      | None -> Stdlib.Uuid.toString id


  let atDefinition
    (t: LanguageTools.ProgramTypes.FQFnName.FQFnName)
    : String =
    match t with
    | Builtin _b ->
      "why are you trying to print a stdlib type name _definition_?"
    | Package p -> FQFnName.Package.atDefinition p

  let fullForReference
    (t: LanguageTools.ProgramTypes.FQFnName.FQFnName)
    : String =
    match t with
    | Builtin b ->
      FQFnName.Builtin.fullForReference b
    | Package p ->
      FQFnName.Package.fullForReference p


let typeReference
  (t: LanguageTools.ProgramTypes.TypeReference)
  : String =
  match t with
  | TVariable varName -> "'" ++ varName

  | TUnit -> "Unit"
  | TBool -> "Bool"
  | TInt8 -> "Int8"
  | TUInt8 -> "UInt8"
  | TInt16 -> "Int16"
  | TUInt16 -> "UInt16"
  | TInt32 -> "Int32"
  | TUInt32 -> "UInt32"
  | TInt64 -> "Int64"
  | TUInt64 -> "UInt64"
  | TInt128 -> "Int128"
  | TUInt128 -> "UInt128"
  | TFloat -> "Float"
  | TChar -> "Char"
  | TString -> "String"
  | TDateTime -> "DateTime"
  | TUuid -> "Uuid"

  | TList inner ->
    $"List<{typeReference inner}>"

  | TTuple(first, second, theRest) ->
    (Stdlib.List.append [ first; second ] theRest)
    |> Stdlib.List.map (fun item ->
      typeReference item)
    |> Stdlib.String.join " * "
    |> fun parts -> "(" ++ parts ++ ")"

  | TDict inner ->
    $"Dict<{typeReference inner}>"

  | TCustomType(typ, args) ->
    let argsPart =
      match args with
      | [] -> ""
      | args ->
        args
        |> Stdlib.List.map (fun arg ->
          typeReference arg)
        |> Stdlib.String.join ", "
        |> fun parts -> $"<{parts}>"

    let typeNamePart =
      match typ with
      | Ok name ->
        FQTypeName.fullForReference name
      | Error e -> NameResolutionError.source e

    $"{typeNamePart}{argsPart}"

  | TDB inner ->
    $"DB<{typeReference inner}>"

  | TFn(args, ret) ->
    let argPart =
      args
      |> Stdlib.List.map (fun arg ->
        typeReference arg)
      |> Stdlib.String.join " -> "

    $"{argPart} -> {typeReference ret}"
  | _ ->
    let s = Builtin.Json.serialize<LanguageTools.ProgramTypes.TypeReference> t

    $"({s})"


let letPattern (lp: LanguageTools.ProgramTypes.LetPattern) : String =
  match lp with
  | LPUnit _id -> "()"
  | LPVariable(_id, name) -> name
  | LPTuple(_id, first, second, theRest) ->
    (Stdlib.List.append [ first; second ] theRest)
    |> Stdlib.List.map (fun item -> letPattern item)
    |> Stdlib.String.join ", "
    |> fun parts -> "(" ++ parts ++ ")"

let matchPattern (mp: LanguageTools.ProgramTypes.MatchPattern) : String =
  match mp with
  | MPVariable(_id, name) -> name

  | MPUnit _id -> "()"

  | MPBool(_id, b) -> Stdlib.Bool.toString b

  | MPInt8(_id, i) -> (Stdlib.Int8.toString i) ++ "y"
  | MPUInt8(_id, i) -> (Stdlib.UInt8.toString i) ++ "uy"
  | MPInt16(_id, i) -> (Stdlib.Int16.toString i) ++ "s"
  | MPUInt16(_id, i) -> (Stdlib.UInt16.toString i) ++ "us"
  | MPInt32(_id, i) -> (Stdlib.Int32.toString i) ++ "l"
  | MPUInt32(_id, i) -> (Stdlib.UInt32.toString i) ++ "ul"
  | MPInt64(_id, i) -> (Stdlib.Int64.toString i) ++ "L"
  | MPUInt64(_id, i) -> (Stdlib.UInt64.toString i) ++ "UL"
  | MPInt128(_id, i) -> (Stdlib.Int128.toString i) ++ "Q"
  | MPUInt128(_id, i) -> (Stdlib.UInt128.toString i) ++ "Z"

  | MPFloat(_id, sign, whole, remainder) ->
    let remainderPart = PrettyPrinter.processRemainder remainder
    $"{PrettyPrinter.sign sign}{whole}.{remainderPart}"

  | MPChar(_id, c) -> $"'{c}'"
  | MPString(_id, s) -> $"\"{PrettyPrinter.escapeSpecialCharacters s}\""

  | MPList(_id, items) ->
    items
    |> Stdlib.List.map (fun item -> matchPattern item)
    |> Stdlib.String.join "; "
    |> fun parts -> "[" ++ parts ++ "]"

  | MPListCons(_id, head, tail) ->
    let headPart = matchPattern head
    let tailPart = matchPattern tail
    $"{headPart} :: {tailPart}"

  | MPTuple(_, first, second, theRest) ->
    (Stdlib.List.append [ first; second ] theRest)
    |> Stdlib.List.map (fun item -> matchPattern item)
    |> Stdlib.String.join ", "
    |> fun parts -> "(" ++ parts ++ ")"

  | MPEnum(_id, caseName, fieldPats) ->
    match fieldPats with
    | [] -> $"{caseName}"
    | fieldPats ->
      let fieldPart =
        fieldPats
        |> Stdlib.List.map (fun pat -> matchPattern pat)
        |> Stdlib.String.join ", "

      $"{caseName}({fieldPart})"

  | MPOr(_id, patterns) ->
    patterns
    |> Stdlib.List.map (fun pat -> matchPattern pat)
    |> Stdlib.String.join " | "


let binaryOperation (b: LanguageTools.ProgramTypes.BinaryOperation) : String =
  match b with
  // CLEANUP consider surrounding with spaces
  | BinOpAnd -> "&&"
  | BinOpOr -> "||"

let infixFnName (i: LanguageTools.ProgramTypes.InfixFnName) : String =
  match i with
  | ArithmeticPlus -> "+"
  | ArithmeticMinus -> "-"
  | ArithmeticMultiply -> "*"
  | ArithmeticDivide -> "/"
  | ArithmeticModulo -> "%"
  | ArithmeticPower -> "^"
  | ComparisonGreaterThan -> ">"
  | ComparisonGreaterThanOrEqual -> ">="
  | ComparisonLessThan -> "<"
  | ComparisonLessThanOrEqual -> "<="
  | ComparisonEquals -> "=="
  | ComparisonNotEquals -> "!="
  | StringConcat -> "++"

let infix (i: LanguageTools.ProgramTypes.Infix) : String =
  match i with
  | InfixFnCall i -> infixFnName i
  | BinOp b -> binaryOperation b

let stringSegment (ctx: Context) (s: LanguageTools.ProgramTypes.StringSegment) : String =
  match s with
  | StringText text -> text
  | StringInterpolation expr -> $"{{{expr ctx expr}}}"

let pipeExpr (ctx: Context) (p: LanguageTools.ProgramTypes.PipeExpr) : String =
  match p with
  | EPipeVariable(_id, varName, exprs) ->
    let exprs =
      exprs
      |> Stdlib.List.map (expr ctx)
      |> Stdlib.String.join " "
    if exprs == "" then varName else $"({varName} {exprs})"

  | EPipeLambda(_id, pats, body) ->
    let argsPart =
      pats
      |> Stdlib.List.map (fun lp -> letPattern lp)
      |> Stdlib.String.join " "
    $"fun {argsPart} -> {expr ctx body}"

  | EPipeInfix(_id, infixOp, e) ->
    let infixPart = infix infixOp
    let exprPart = expr ctx e
    $"({infixPart}) {exprPart}"

  | EPipeFnCall(_id, fnName, typeArgs, args) ->
    let fnNamePart =
      match fnName with
      | Ok name ->
        FQFnName.fullForReference  name
      | Error e -> NameResolutionError.source e

    let typeArgsPart =
      match typeArgs with
      | [] -> ""
      | _ ->
        typeArgs
        |> Stdlib.List.map (fun typeArg ->
          typeReference  typeArg)
        |> Stdlib.String.join ", "
        |> fun parts -> $"<{parts}>"

    let argsPart =
      args
      |> Stdlib.List.map (fun arg -> expr ctx arg)
      |> Stdlib.List.map (fun arg -> $"{arg}")
      |> Stdlib.String.join " "

    if argsPart == "" then
      $"{fnNamePart}{typeArgsPart}"
    else
      $"{fnNamePart}{typeArgsPart} {argsPart}"

  // LanguageTools.ID *
  // typeName: LanguageTools.ProgramTypes.TypeName.TypeName *
  // caseName: String *
  // fields: List<LanguageTools.ProgramTypes.Expr>
  | EPipeEnum(_id, typeName, caseName, fields) ->
    let typeNamePart =
      match typeName with
      | Ok name ->
        FQTypeName.fullForReference  name
      | Error e -> NameResolutionError.source e

    match fields with
    | [] -> $"{typeNamePart}.{caseName}"
    | fields ->
      let fieldPart =
        fields
        |> Stdlib.List.map (fun field -> expr ctx field)
        |> Stdlib.List.map (fun field -> $"({field})")
        |> Stdlib.String.join " "

      $"{typeNamePart}.{caseName}{fieldPart}"

let expr (ctx: Context) (e: LanguageTools.ProgramTypes.Expr) : String =
  match e with
  | EUnit _id -> "()"

  | EBool(_id, b) -> Stdlib.Bool.toString b

  | EInt8(_id, i) -> Stdlib.Int8.toString i ++ "y"
  | EUInt8(_id, i) -> Stdlib.UInt8.toString i ++ "uy"
  | EInt16(_id, i) -> Stdlib.Int16.toString i ++ "s"
  | EUInt16(_id, i) -> Stdlib.UInt16.toString i ++ "us"
  | EInt32(_id, i) -> Stdlib.Int32.toString i ++ "l"
  | EUInt32(_id, i) -> Stdlib.UInt32.toString i ++ "ul"
  | EInt64(_id, i) -> (Stdlib.Int64.toString i) ++ "L"
  | EUInt64(_id, i) -> (Stdlib.UInt64.toString i) ++ "UL"
  | EInt128(_id, i) -> Stdlib.Int128.toString i ++ "Q"
  | EUInt128(_id, i) -> Stdlib.UInt128.toString i ++ "Z"

  | EFloat(_id, sign, whole, remainder) ->
    let signPart = PrettyPrinter.sign sign
    let remainderPart = PrettyPrinter.processRemainder remainder
    $"{signPart}{whole}.{remainderPart}"

  | EChar(_id, c) -> "'" ++ c ++ "'"

  | EString(_id, segments) ->
    match segments with
    | [] -> "\"\""
    | [ StringText text ] -> $"\"{PrettyPrinter.escapeSpecialCharacters text}\""
    | segments ->
      let inner =
        segments
        |> Stdlib.List.map (fun segment -> stringSegment ctx segment)
        |> Stdlib.String.join ""
      $"$\"{inner}\""


  // structures of data
  | EList(_id, items) ->
    items
    |> Stdlib.List.map (fun item -> expr ctx item)
    |> Stdlib.String.join "; "
    |> fun parts -> "[" ++ parts ++ "]"

  | EDict(_id, pairs) ->
    let pairPart =
      pairs
      |> Stdlib.List.map (fun pair ->
        let (key, value) = pair
        $"{key} = {expr ctx value}")
      |> Stdlib.String.join "; "
      |> fun parts -> "{ " ++ parts ++ " }"

    $"Dict {pairPart}"


  | ETuple(_id, first, second, theRest) ->
    (Stdlib.List.append [ first; second ] theRest)
    |> Stdlib.List.map (fun item -> expr ctx item)
    |> Stdlib.String.join ", "
    |> fun parts -> "(" ++ parts ++ ")"

  | ERecord(_id, typeName, typeArgs, fields) ->
    let typeNamePart =
      match typeName with
      | Ok name ->
        FQTypeName.fullForReference  name
      | Error e -> NameResolutionError.source e

    let typeArgsPart =
      match typeArgs with
      | [] -> ""
      | _ ->
        typeArgs
        |> Stdlib.List.map (fun typeArg ->
          typeReference  typeArg)
        |> Stdlib.String.join ", "
        |> fun parts -> $"<{parts}>"

    let fieldPart =
      fields
      |> Stdlib.List.map (fun pair ->
        let (name, value) = pair
        $"{name} = {expr ctx value}")
      |> Stdlib.String.join "; "
      |> fun parts -> "{ " ++ parts ++ " }"

    $"{typeNamePart}{typeArgsPart} {fieldPart}"

  | EEnum(_id, typeName, typeArgs, caseName, fields) ->
    let typeNamePart =
      match typeName with
      | Ok name ->
        FQTypeName.fullForReference  name
      | Error e -> NameResolutionError.source e

    let typeArgsPart =
      match typeArgs with
      | [] -> ""
      | _ ->
        typeArgs
        |> Stdlib.List.map (fun typeArg ->
          typeReference  typeArg)
        |> Stdlib.String.join ", "
        |> fun parts -> $"<{parts}>"

    match fields with
    | [] -> $"{typeNamePart}{typeArgsPart}.{caseName}"
    | fields ->
      let fieldPart =
        fields
        |> Stdlib.List.map (fun field -> expr ctx field)
        |> Stdlib.String.join ", "
      $"{typeNamePart}{typeArgsPart}.{caseName}({fieldPart})"


  // declaring and accessing variables
  | ELet(_id, pattern, rhs, body) ->
    let patternPart = letPattern pattern
    let rhsPart = expr ctx rhs
    let bodyPart = expr ctx body
    $"let {patternPart} =\n{PrettyPrinter.indent rhsPart}\n{bodyPart}"

  | ERecordFieldAccess(_id, e, fieldName) ->
    let exprPart = expr ctx e

    // TODO: only sometimes need to wrap exprPart in parens
    match e with
    | EVariable(_, _)
    | ERecordFieldAccess(_, _, _) -> $"{exprPart}.{fieldName}"
    | _ -> $"({exprPart}).{fieldName}"

  | EVariable(_id, name) -> name

  | EArg(_id, index) ->
    // Find the parameter name that corresponds to this index
    match ctx.currentFunction with
    | Some((_fnName, argMap)) ->
      argMap
      |> Stdlib.Dict.toList
      |> Stdlib.List.findFirst (fun (name, idx) -> idx == index)
      |> Stdlib.Option.map (fun (name, _) -> name)
      |> Stdlib.Option.withDefault $"earg{Stdlib.Int64.toString index}"
    | None -> $"earg{Stdlib.Int64.toString index}"

  // control flow
  | EIf(_id, cond, thenBranch, elseBranch) ->
    let condPart = expr ctx cond

    let thenPart =
      (expr ctx thenBranch) |> PrettyPrinter.indent

    match elseBranch with
    | None -> $"if {condPart} then\n{thenPart}"
    | Some elseBranch ->
      match elseBranch with
      | EIf(_, _, _, _) ->
        let elsePart = (expr ctx elseBranch)
        $"if {condPart} then\n{thenPart}\nelse {elsePart}"

      | _ ->
        let elsePart = (expr ctx elseBranch) |> PrettyPrinter.indent
        $"if {condPart} then\n{thenPart}\nelse\n{elsePart}"

  | EMatch(_id, arg, cases) ->
    let cases =
      cases
      |> Stdlib.List.map (fun case ->
        let patternPart = matchPattern case.pat

        let whenPart =
          match case.whenCondition with
          | Some cond ->
            let whenCondition = expr ctx cond
            $" when {whenCondition}"
          | None -> ""

        let rhsPart =
          (expr ctx case.rhs) |> PrettyPrinter.indent

        $"| {patternPart}{whenPart} ->\n{rhsPart}")

    let casesPart = Stdlib.String.join cases "\n"

    let argPart = expr ctx arg

    $"match {argPart} with\n{casesPart}"


  | EPipe(_id, e, pipeExprs) ->
    // LanguageTools.ID *
    // LanguageTools.ProgramTypes.Expr *
    // List<LanguageTools.ProgramTypes.PipeExpr>
    let exprPart = expr ctx e

    let pipeParts =
      pipeExprs
      |> Stdlib.List.map (fun pe ->
        pipeExpr ctx pe)
      |> Stdlib.String.join "\n|> "

    $"{exprPart}\n|> {pipeParts}"



  // function calls

  | EInfix(_id, infixOp, left, right) ->
    let infixPart = infix infixOp
    let leftPart = expr ctx left
    let rightPart = expr ctx right
    // TODO: might need to wrap in parens
    $"({leftPart}) {infixPart} ({rightPart})"

  | ELambda(_id, pats, body) ->
    let patsPart =
      pats
      |> Stdlib.List.map (fun pat -> letPattern pat)
      |> Stdlib.String.join " "

    let bodyPart = expr ctx body

    $"(fun {patsPart} ->\n{PrettyPrinter.indent bodyPart})"

  | EApply(_id, fnName, typeArgs, args) ->
    let fnNamePart = expr ctx fnName

    let argsPart =
      args
      |> Stdlib.List.map (fun arg ->
        match arg with
        | EApply(_, _, _, _) -> $"({expr ctx arg})"
        | _ -> expr ctx arg)
      |> Stdlib.String.join " "

    match typeArgs with
    | [] -> $"{fnNamePart} {argsPart}"
    | _ ->
      let typeArgsPart =
        typeArgs
        |> Stdlib.List.map (fun typeArg ->
          typeReference  typeArg)
        |> Stdlib.String.join ", "

      $"{fnNamePart}<{typeArgsPart}> {argsPart}"

  | EFnName(_id, fnName) ->
    match fnName with
    | Ok name ->
      FQFnName.fullForReference  name
    | Error e -> NameResolutionError.source e

  // LanguageTools.ID *
  // record: LanguageTools.ProgramTypes.Expr *
  // updates: List<String * LanguageTools.ProgramTypes.Expr>
  | ERecordUpdate(_id, record, updates) ->
    let recordPart = expr ctx record

    let updatePart =
      updates
      |> Stdlib.List.map (fun pair ->
        let (fieldName, value) = pair
        $"{fieldName} = {expr ctx value}")
      |> Stdlib.String.join "; "

    // TODO: don't always need the parens

    $"{{ {recordPart} with {updatePart} }}"

  | EValue(_id, value) ->
    match value with
    | Ok name ->
      FQValueName.fullForReference  name
    | Error e -> NameResolutionError.source e

  | EStatement (_id, first, next) ->
    let firstPart = expr ctx first
    let nextPart = expr ctx next
    $"{firstPart}\n{nextPart}"

  | ESelf _id ->
    match ctx.currentFunction with
    | Some((functionName, _argMap)) -> functionName
    // This should never happen - ESelf should only appear within a function body
    // CLEANUP: consider making this a runtime error instead
    | None -> "ESelf"

  // CLEANUP: remove this case before shipping to users
  | expr ->
    let s = Builtin.Json.serialize<LanguageTools.ProgramTypes.Expr> expr

    $"{s}"

// CLEANUP this isn't currently used
// if/when we uncomment this, take note that the `m` argument is a function
// that we may not fully yet support (esp in name-resolution)
// let deprecation<'name>
//   (m: 'name -> String)
//   (d: LanguageTools.ProgramTypes.Deprecation)
//   : String =
//   match d with
//   | NotDeprecated -> "NotDeprecated"
//   | RenamedTo name -> $"RenamedTo {m name}"
//   | ReplacedBy name -> $"ReplacedBy {m name}"
//   | DeprecatedBecause reason -> $"DeprecatedBecause {reason}"

module TypeDeclaration =
  let recordField
    (d: LanguageTools.ProgramTypes.TypeDeclaration.RecordField)
    : String =
    // TODO: /// for description
    $"{d.name}: {typeReference d.typ}"

  let enumField
    (d: LanguageTools.ProgramTypes.TypeDeclaration.EnumField)
    : String =
    match d.label with
    | None -> typeReference d.typ
    | Some label ->
      $"{label}: {typeReference d.typ}"

  let enumCase
    (c: LanguageTools.ProgramTypes.TypeDeclaration.EnumCase)
    : String =
    match c.fields with
    | [] -> "| " ++ c.name
    | fields ->
      let fieldPart =
        fields
        |> Stdlib.List.map (fun field ->
          TypeDeclaration.enumField field)
        |> Stdlib.String.join " * "

      $"| {c.name} of {fieldPart}"


let customType
  (d: LanguageTools.ProgramTypes.TypeDeclaration.TypeDeclaration)
  : String =
  match d.definition with
  | Alias typeRef -> typeReference typeRef

  | Record fields ->
    let fieldsPart =
      fields
      |> Stdlib.List.map (fun field ->
        TypeDeclaration.recordField field)
      |> Stdlib.String.join "\n  "

    "{ " ++ (fieldsPart) ++ " }"

  | Enum cases ->
    cases
    |> Stdlib.List.map (fun case ->
      TypeDeclaration.enumCase case)
    |> Stdlib.String.join "\n"


module Handler =
  let cronInterval
    (c: LanguageTools.ProgramTypes.Handler.CronInterval)
    : String =
    match c with
    | EveryDay -> "Every Day"
    | EveryWeek -> "Every Week"
    | EveryFortnight -> "Every Fortnight"
    | EveryHour -> "Every Hour"
    | Every12Hours -> "Every 12 Hours"
    | EveryMinute -> "Every Minute"

  let spec (s: LanguageTools.ProgramTypes.Handler.Spec) : String =
    match s with
    | HTTP(route, method) -> $"[<HttpHandler({method}, {route})>]"
    | Worker name -> $"[<Worker({name})>]"
    | Cron(name, interval) ->
      $"[<Cron({name}, {Handler.cronInterval interval})>]"
    | REPL name -> $"[<REPL({name})>]"

let handler (ctx: Context) (h: LanguageTools.ProgramTypes.Handler.Handler) : String =
  let specPart = Handler.spec h.spec

  $"{specPart}\nlet _handler _ignored =\n  {expr ctx h.ast}"


let db
  (db: LanguageTools.ProgramTypes.DB)
  : String =
  let versionPart =
    if db.version == 0 then
      ""
    else
      $"_v{Stdlib.Int32.toString db.version}"

  let typPart = typeReference db.typ

  $"type {db.name}{versionPart} = {typPart}"



// let secret (s: Stdlib.Secret.T) : String =
//   let versionPart = if s.version == 0 then "" else $"_v{Stdlib.Int32.toString s.version}"

//   $"let {s.name}{versionPart} = \"*****\""


let packageType
  (p: LanguageTools.ProgramTypes.PackageType.PackageType)
  : String =
  // TODO: take care of deprecated
  let namePart = FQTypeName.Package.atDefinition p.id

  let typeParamPart =
    match p.declaration.typeParams with
    | [] -> ""
    | _ ->
      p.declaration.typeParams
      |> Stdlib.List.map (fun typeParam -> $"'{typeParam}")
      |> Stdlib.String.join ", "
      |> fun parts -> $"<{parts}>"

  let defPart =
    (customType p.declaration)
    |> PrettyPrinter.indent

  let docComment = formatDocComment p.description

  $"{docComment}type {namePart}{typeParamPart} =\n{defPart}"


let packageValue
  (ctx: Context)
  (p: LanguageTools.ProgramTypes.PackageValue.PackageValue)
  : String =
  let namePart = FQValueName.Package.atDefinition  p.id
  let bodyPart = expr ctx p.body

  let docComment = formatDocComment p.description

  $"{docComment}val {namePart} = {bodyPart}"


module PackageLocation =
  let packageLocation (loc: LanguageTools.ProgramTypes.PackageLocation) : String =
    let modulesPart =
      match loc.modules with
      | [] -> ""
      | modules -> (Stdlib.String.join modules ".") ++ "."

    $"{loc.owner}.{modulesPart}{loc.name}"


module PackageFn =
  let parameter
    (p: LanguageTools.ProgramTypes.PackageFn.Parameter)
    : String =
    // TODO: /// for description
    $"({p.name}: {typeReference p.typ})"


  let signature
    (f: LanguageTools.ProgramTypes.PackageFn.PackageFn)
    : String =
    let params =
      f.parameters
      |> Stdlib.List.map (fun p ->
        PackageFn.parameter p)
      |> Stdlib.String.join ", "

    let returnType =
      typeReference f.returnType

    params ++ " -> " ++ returnType


let packageFn
  (ctx: Context)
  (p: LanguageTools.ProgramTypes.PackageFn.PackageFn)
  : String =
  // TODO: handle `deprecated`
  let namePart = FQFnName.Package.atDefinition  p.id

  let typeParamPart =
    match p.typeParams with
    | [] -> ""
    | _ ->
      p.typeParams
      |> Stdlib.List.map (fun typeParam -> $"'{typeParam}")
      |> Stdlib.String.join ", "
      |> fun parts -> $"<{parts}>"

  let paramPart =
    p.parameters
    |> Stdlib.List.map (fun param ->
      PackageFn.parameter  param)
    |> Stdlib.String.join " "

  let retPart = typeReference  p.returnType

  let argMap =
    p.parameters
    |> Stdlib.List.indexedMap (fun i param -> (param.name, i))
    |> Stdlib.List.fold Stdlib.Dict.empty (fun acc (name, idx) ->
      Stdlib.Dict.set acc name idx)

  let contextWithFn =
    { ctx with
        currentFunction = Stdlib.Option.Option.Some((namePart, argMap)) }

  let bodyPart = expr contextWithFn p.body

  let docComment = formatDocComment p.description

  $"{docComment}let {namePart}{typeParamPart} {paramPart}: {retPart} =\n{PrettyPrinter.indent bodyPart}"


module BuiltinFn =
  let signature (f: LanguageTools.BuiltinFunction) : String =
    // CLEANUP: it's odd that we have to call the runtime pretty-printer here.
    // Potential solution: update RuntimeTypes (.fs) such that BuiltInFn's returnType and parameters use PT TypeReferences.
    // Main blocker: "RT comes before PT" in LibExecution, and it'd take some wrangling to get it all compiling again if we did that.

    let parameters =
      f.parameters
      |> Stdlib.List.map (fun p ->
          let params = PrettyPrinter.RuntimeTypes.typeReference p.``type``
          $"({p.name} : {params})")
      |> Stdlib.String.join ", "

    parameters ++ " -> " ++ (PrettyPrinter.RuntimeTypes.typeReference f.returnType)


module PackageOp =
  let packageOp
    (op: LanguageTools.ProgramTypes.PackageOp)
    : String =
    match op with
    | AddType typ ->
      let name =
        FQTypeName.Package.atDefinition typ.id

      let typeParamPart =
        match typ.declaration.typeParams with
        | [] -> ""
        | params ->
          params
          |> Stdlib.List.map (fun p -> "'" ++ p)
          |> Stdlib.String.join ", "
          |> fun parts -> $"<{parts}>"

      let kindPart =
        match typ.declaration.definition with
        | Alias _ -> "alias"
        | Record _ -> "record"
        | Enum _ -> "enum"

      $"AddType {name}{typeParamPart} ({kindPart})"

    | SetTypeName (id, loc) ->
      let path = PackageLocation.packageLocation loc
      $"SetTypeName → {path}"

    | AddFn fn ->
      let name =
        FQFnName.Package.atDefinition fn.id

      let signature = PackageFn.signature fn

      $"AddFn {name}: {signature}"

    | SetFnName (id, loc) ->
      let path = PackageLocation.packageLocation loc
      $"SetFnName → {path}"

    | AddValue _value ->
      let name = FQValueName.Package.atDefinition _value.id

      $"AddValue {name}"

    | SetValueName (id, loc) ->
      let path = PackageLocation.packageLocation loc
      $"SetValueName → {path}"