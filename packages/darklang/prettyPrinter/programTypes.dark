// TODO:
//alias PT = PACKAGE.Darklang.LanguageTools.ProgramTypes
//alias RT = PACKAGE.Darklang.Stdlib.RuntimeTypes

// TODO: update all of the 'namePart's to nameToStrings with fn inputs

module Darklang =
  module PrettyPrinter =
    module ProgramTypes =

      let nameResolutionError
        (nr: PACKAGE.Darklang.LanguageTools.RuntimeErrors.NameResolution.Error)
        : String =
        Builtin.String.join nr.names "."

      module FQName =
        module BuiltIn =
          let fullForReference
            (namePart: String)
            (t: PACKAGE.Darklang.LanguageTools.ProgramTypes.FQName.BuiltIn)
            : String =
            let modulesPart =
              match t.modules with
              | [] -> ""
              | modules ->
                modules |> Builtin.String.join "." |> (fun parts -> $"{parts}.")

            let versionPart =
              if t.version == 0 then
                ""
              else
                $"_v{Builtin.Int.toString t.version}"

            $"{modulesPart}{namePart}{versionPart}"


        module UserProgram =
          let atDefinition
            // TODO: take in just typ and version - modules should have already been dealt with
            (namePart: String)
            (u: PACKAGE.Darklang.LanguageTools.ProgramTypes.FQName.UserProgram)
            : String =
            match u.modules with
            | [] ->
              let versionPart =
                if u.version == 0 then
                  ""
                else
                  $"_v{Builtin.Int.toString u.version}"

              $"{namePart}{versionPart}"
            | _ -> "(UserTypeName.atDefinition unexpected nonempty u.modules)"

          let fullForReference
            (namePart: String)
            (u: PACKAGE.Darklang.LanguageTools.ProgramTypes.FQName.UserProgram)
            : String =
            let modulesPart =
              match u.modules with
              | [] -> ""
              | modules ->
                modules |> Builtin.String.join "." |> (fun parts -> $"{parts}.")

            let versionPart =
              if u.version == 0 then
                ""
              else
                $"_v{Builtin.Int.toString u.version}"

            $"{modulesPart}{namePart}{versionPart}"


        module Package =
          let atDefinition
            // TODO: take in just owner, typ, and version - modules should have already been dealt with
            (namePart: String)
            (p: PACKAGE.Darklang.LanguageTools.ProgramTypes.FQName.Package)
            : String =
            let versionPart =
              if p.version == 0 then
                ""
              else
                $"_v{Builtin.Int.toString p.version}"

            $"{namePart}{versionPart}"

          let fullForReference
            (namePart: String)
            (p: PACKAGE.Darklang.LanguageTools.ProgramTypes.FQName.Package)
            : String =
            let modulesPart = Builtin.String.join p.modules "."

            let versionPart =
              if p.version == 0 then
                ""
              else
                $"_v{Builtin.Int.toString p.version}"

            $"PACKAGE.{p.owner}.{modulesPart}.{namePart}{versionPart}"


      module TypeName =
        let name
          (name: PACKAGE.Darklang.LanguageTools.ProgramTypes.TypeName.Name)
          : String =
          match name with
          | TypeName name -> name

        module BuiltIn =
          let fullForReference
            (t: PACKAGE.Darklang.LanguageTools.ProgramTypes.TypeName.BuiltIn)
            : String =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FQName.BuiltIn.fullForReference
              (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.name t.name)
              t

        module UserProgram =
          let atDefinition
            (u: PACKAGE.Darklang.LanguageTools.ProgramTypes.TypeName.UserProgram)
            : String =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FQName.UserProgram.atDefinition
              (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.name u.name)
              u

          let fullForReference
            (u: PACKAGE.Darklang.LanguageTools.ProgramTypes.TypeName.UserProgram)
            : String =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FQName.UserProgram.fullForReference
              (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.name u.name)
              u

        module Package =
          let atDefinition
            (p: PACKAGE.Darklang.LanguageTools.ProgramTypes.TypeName.Package)
            : String =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FQName.Package.atDefinition
              (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.name p.name)
              p

          let fullForReference
            (p: PACKAGE.Darklang.LanguageTools.ProgramTypes.TypeName.Package)
            : String =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FQName.Package.fullForReference
              (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.name p.name)
              p

        let atDefinition
          (t: PACKAGE.Darklang.LanguageTools.ProgramTypes.TypeName.TypeName)
          : String =
          match t with
          | BuiltIn b ->
            "(unexpected attempt to Builtin.print a stdlib type name _definition_)"
          | UserProgram u ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.UserProgram.atDefinition
              u
          | Package p ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.Package.atDefinition
              p

        let fullForReference
          (t: PACKAGE.Darklang.LanguageTools.ProgramTypes.TypeName.TypeName)
          : String =
          match t with
          | BuiltIn b ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.BuiltIn.fullForReference
              b
          | UserProgram u ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.UserProgram.fullForReference
              u
          | Package p ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.Package.fullForReference
              p

      module ConstantName =
        let name
          (name: PACKAGE.Darklang.LanguageTools.ProgramTypes.ConstantName.Name)
          : String =
          match name with
          | ConstantName name -> name

        module BuiltIn =
          let fullForReference
            (c: PACKAGE.Darklang.LanguageTools.ProgramTypes.ConstantName.BuiltIn)
            : String =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FQName.BuiltIn.fullForReference
              (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.ConstantName.name c.name)
              c


        module UserProgram =
          let atDefinition
            (u: PACKAGE.Darklang.LanguageTools.ProgramTypes.ConstantName.UserProgram)
            : String =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FQName.UserProgram.atDefinition
              (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.ConstantName.name u.name)
              u

          let fullForReference
            (u: PACKAGE.Darklang.LanguageTools.ProgramTypes.ConstantName.UserProgram)
            : String =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FQName.UserProgram.fullForReference
              (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.ConstantName.name u.name)
              u

        module Package =
          let atDefinition
            (p: PACKAGE.Darklang.LanguageTools.ProgramTypes.ConstantName.Package)
            : String =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FQName.Package.atDefinition
              (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.ConstantName.name p.name)
              p

          let fullForReference
            (p: PACKAGE.Darklang.LanguageTools.ProgramTypes.ConstantName.Package)
            : String =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FQName.Package.fullForReference
              (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.ConstantName.name p.name)
              p

        let atDefinition
          (t: PACKAGE.Darklang.LanguageTools.ProgramTypes.ConstantName.ConstantName)
          : String =
          match t with
          | BuiltIn b ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.ConstantName.BuiltIn.fullForReference
              b
          | UserProgram u ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.ConstantName.UserProgram.atDefinition
              u
          | Package p ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.ConstantName.Package.atDefinition
              p

        let fullForReference
          (t: PACKAGE.Darklang.LanguageTools.ProgramTypes.ConstantName.ConstantName)
          : String =
          match t with
          | BuiltIn b ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.ConstantName.BuiltIn.fullForReference
              b
          | UserProgram u ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.ConstantName.UserProgram.fullForReference
              u
          | Package p ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.ConstantName.Package.fullForReference
              p


      module FnName =
        let name
          (name: PACKAGE.Darklang.LanguageTools.ProgramTypes.FnName.Name)
          : String =
          match name with
          | FnName name -> name

        module BuiltIn =
          let fullForReference
            (f: PACKAGE.Darklang.LanguageTools.ProgramTypes.FnName.BuiltIn)
            : String =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FQName.BuiltIn.fullForReference
              (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FnName.name f.name)
              f

        module UserProgram =
          let atDefinition
            (u: PACKAGE.Darklang.LanguageTools.ProgramTypes.FnName.UserProgram)
            : String =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FQName.UserProgram.atDefinition
              (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FnName.name u.name)
              u

          let fullForReference
            (u: PACKAGE.Darklang.LanguageTools.ProgramTypes.FnName.UserProgram)
            : String =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FQName.UserProgram.fullForReference
              (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FnName.name u.name)
              u

        module Package =
          let atDefinition
            (p: PACKAGE.Darklang.LanguageTools.ProgramTypes.FnName.Package)
            : String =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FQName.Package.atDefinition
              (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FnName.name p.name)
              p

          let fullForReference
            (p: PACKAGE.Darklang.LanguageTools.ProgramTypes.FnName.Package)
            : String =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FQName.Package.fullForReference
              (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FnName.name p.name)
              p

        let atDefinition
          (t: PACKAGE.Darklang.LanguageTools.ProgramTypes.FnName.FnName)
          : String =
          match t with
          | BuiltIn _b ->
            "why are you trying to Builtin.print a stdlib type name _definition_?"
          | UserProgram u ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FnName.UserProgram.atDefinition
              u
          | Package p ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FnName.Package.atDefinition p

        let fullForReference
          (t: PACKAGE.Darklang.LanguageTools.ProgramTypes.FnName.FnName)
          : String =
          match t with
          | BuiltIn b ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FnName.BuiltIn.fullForReference
              b
          | UserProgram u ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FnName.UserProgram.fullForReference
              u
          | Package p ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FnName.Package.fullForReference
              p


      let typeReference
        (t: PACKAGE.Darklang.LanguageTools.ProgramTypes.TypeReference)
        : String =
        match t with
        | TVariable varName -> "'" ++ varName

        | TUnit -> "Unit"
        | TBool -> "Bool"
        | TInt -> "Int"
        | TFloat -> "Float"
        | TChar -> "Character"
        | TString -> "String"
        | TDateTime -> "DateTime"
        | TUuid -> "Uuid"
        | TBytes -> "Bytes"
        | TPassword -> "Password"

        | TList inner ->
          $"List<{PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference inner}>"

        | TTuple(first, second, theRest) ->
          (Builtin.List.append [ first; second ] theRest)
          |> Builtin.List.map (fun item ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference item)
          |> Builtin.String.join " * "
          |> fun parts -> "(" ++ parts ++ ")"

        | TDict inner ->
          $"Dict<{PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference inner}>"

        | TCustomType(typ, args) ->
          let argsPart =
            match args with
            | [] -> ""
            | args ->
              args
              |> Builtin.List.map (fun arg ->
                PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference arg)
              |> Builtin.String.join ", "
              |> fun parts -> $"<{parts}>"

          let typeNamePart =
            match typ with
            | Ok name ->
              PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.fullForReference
                name
            | Error e ->
              PACKAGE.Darklang.PrettyPrinter.ProgramTypes.nameResolutionError e

          $"{typeNamePart}{argsPart}"

        | TDB inner ->
          $"DB<{PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference inner}>"

        | TFn(args, ret) ->
          let argPart =
            args
            |> Builtin.List.map (fun arg ->
              PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference arg)
            |> Builtin.String.join ", "
            |> fun parts -> "(" ++ parts ++ ")"

          $"{argPart} -> {PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference ret}"
        | _ ->
          let s =
            match
              Builtin.Json.serialize<PACKAGE.Darklang.LanguageTools.ProgramTypes.TypeReference>
                t
            with
            | Ok s -> s
            | Error e -> "Err" ++ e

          $"({s})"

      let constant (c: PACKAGE.Darklang.LanguageTools.ProgramTypes.Const) : String =
        match c with
        | CInt i -> Builtin.Int.toString i
        | CFloat(sign, whole, remainder) ->
          let signPart = PACKAGE.Darklang.PrettyPrinter.sign sign

          let remainderPart =
            PACKAGE.Darklang.PrettyPrinter.processRemainder remainder

          $"{signPart}{whole}.{remainderPart}"
        | CBool b -> PACKAGE.Darklang.Stdlib.Bool.toString b
        | CChar c -> $"'{Builtin.Char.toString c}'"
        | CString s -> $"\"{s}\""
        | CUnit -> "()"
        | CTuple(first, second, theRest) ->
          (Builtin.List.append [ first; second ] theRest)
          |> Builtin.List.map (fun item ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.constant item)
          |> Builtin.String.join ", "
          |> fun parts -> "(" ++ parts ++ ")"

        | CEnum(typeName, caseName, fields) ->
          let typeNamePart =
            match typeName with
            | Ok name ->
              PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.fullForReference
                name
            | Error e ->
              PACKAGE.Darklang.PrettyPrinter.ProgramTypes.nameResolutionError e

          match fields with
          | [] -> $"{typeNamePart}.{caseName}"
          | fields ->
            let fieldPart =
              fields
              |> Builtin.List.map (fun field ->
                PACKAGE.Darklang.PrettyPrinter.ProgramTypes.constant field)
              |> Builtin.String.join ", "

            $"{typeNamePart}.{caseName}({fieldPart})"

        | _ -> "TODO"


      let letPattern
        (lp: PACKAGE.Darklang.LanguageTools.ProgramTypes.LetPattern)
        : String =
        match lp with
        | LPVariable(_id, name) -> name
        | LPTuple(_id, first, second, theRest) ->
          (Builtin.List.append [ first; second ] theRest)
          |> Builtin.List.map (fun item ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.letPattern item)
          |> Builtin.String.join ", "
          |> fun parts -> "(" ++ parts ++ ")"

      let matchPattern
        (mp: PACKAGE.Darklang.LanguageTools.ProgramTypes.MatchPattern)
        : String =
        match mp with
        | MPVariable(_id, name) -> name
        | MPUnit _id -> "()"
        | MPBool(_id, b) -> PACKAGE.Darklang.Stdlib.Bool.toString b
        | MPInt(_id, i) -> Builtin.Int.toString i
        | MPFloat(_id, sign, whole, remainder) ->
          let remainderPart =
            PACKAGE.Darklang.PrettyPrinter.processRemainder remainder

          $"{PACKAGE.Darklang.PrettyPrinter.sign sign}{whole}.{remainderPart}"

        | MPChar(_id, c) -> c
        | MPString(_id, s) ->
          $"\"{PACKAGE.Darklang.PrettyPrinter.escapeSpecialCharacters s}\""

        | MPList(_id, items) ->
          items
          |> Builtin.List.map (fun item ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.matchPattern item)
          |> Builtin.String.join ", "
          |> fun parts -> "[" ++ parts ++ "]"

        | MPListCons(_id, head, tail) ->
          let headPart =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.matchPattern head

          let tailPart =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.matchPattern tail

          $"{headPart} :: {tailPart}"

        | MPTuple(_, first, second, theRest) ->
          (Builtin.List.append [ first; second ] theRest)
          |> Builtin.List.map (fun item ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.matchPattern item)
          |> Builtin.String.join ", "
          |> fun parts -> "(" ++ parts ++ ")"

        | MPEnum(_id, caseName, fieldPats) ->
          match fieldPats with
          | [] -> caseName
          | [ single ] ->
            $"{caseName} {PACKAGE.Darklang.PrettyPrinter.ProgramTypes.matchPattern single}"
          | fieldPats ->
            let fieldPart =
              fieldPats
              |> Builtin.List.map (fun pat ->
                PACKAGE.Darklang.PrettyPrinter.ProgramTypes.matchPattern pat)
              |> Builtin.String.join ", "

            $"{caseName} ({fieldPart})"


      let binaryOperation
        (b: PACKAGE.Darklang.LanguageTools.ProgramTypes.BinaryOperation)
        : String =
        match b with
        // TODO: consider surrounding with spaces
        | BinOpAnd -> "&&"
        | BinOpOr -> "||"

      let infixFnName
        (i: PACKAGE.Darklang.LanguageTools.ProgramTypes.InfixFnName)
        : String =
        match i with
        | ArithmeticPlus -> "+"
        | ArithmeticMinus -> "-"
        | ArithmeticMultiply -> "*"
        | ArithmeticDivide -> "/"
        | ArithmeticModulo -> "%"
        | ArithmeticPower -> "^"
        | ComparisonGreaterThan -> ">"
        | ComparisonGreaterThanOrEqual -> ">="
        | ComparisonLessThan -> "<"
        | ComparisonLessThanOrEqual -> "<="
        | ComparisonEquals -> "=="
        | ComparisonNotEquals -> "<>"
        | StringConcat -> "++"

      let infix (i: PACKAGE.Darklang.LanguageTools.ProgramTypes.Infix) : String =
        match i with
        | InfixFnCall i -> PACKAGE.Darklang.PrettyPrinter.ProgramTypes.infixFnName i
        | BinOp b -> PACKAGE.Darklang.PrettyPrinter.ProgramTypes.binaryOperation b

      let stringSegment
        (s: PACKAGE.Darklang.LanguageTools.ProgramTypes.StringSegment)
        : String =
        match s with
        | StringText text -> text
        | StringInterpolation expr ->
          $"{{{PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr expr}}}"

      let pipeExpr
        (p: PACKAGE.Darklang.LanguageTools.ProgramTypes.PipeExpr)
        : String =
        match p with
        | EPipeVariable(_id, varName, exprs) ->
          let exprs =
            exprs
            |> Builtin.List.map PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr
            |> Builtin.String.join " "

          $"({varName} {exprs})"

        | EPipeLambda(_id, args, body) ->
          let argsPart =
            args
            |> Builtin.List.map (fun pair ->
              PACKAGE.Darklang.Stdlib.Tuple2.second pair)
            |> Builtin.String.join " "

          let bodyPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr body
          $"fun {argsPart} -> {bodyPart}"

        | EPipeInfix(_id, infix, expr) ->
          let infixPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.infix infix
          let exprPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr expr
          $"({infixPart}) {exprPart}"

        | EPipeFnCall(_id, fnName, typeArgs, args) ->
          let fnNamePart =
            match fnName with
            | Ok name ->
              PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FnName.fullForReference
                name
            | Error e ->
              PACKAGE.Darklang.PrettyPrinter.ProgramTypes.nameResolutionError e

          let typeArgsPart =
            match typeArgs with
            | [] -> ""
            | _ ->
              typeArgs
              |> Builtin.List.map (fun typeArg ->
                PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference typeArg)
              |> Builtin.String.join ", "
              |> fun parts -> $"<{parts}>"

          let argsPart =
            args
            |> Builtin.List.map (fun arg ->
              PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr arg)
            |> Builtin.List.map (fun arg -> $"({arg})")
            |> Builtin.String.join " "

          $"{fnNamePart}{typeArgsPart} {argsPart}"

        // PACKAGE.Darklang.LanguageTools.ID *
        // typeName: PACKAGE.Darklang.LanguageTools.ProgramTypes.TypeName.TypeName *
        // caseName: String *
        // fields: List<PACKAGE.Darklang.LanguageTools.ProgramTypes.Expr>
        | EPipeEnum(_id, typeName, caseName, fields) ->
          let typeNamePart =
            match typeName with
            | Ok name ->
              PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.fullForReference
                name
            | Error e ->
              PACKAGE.Darklang.PrettyPrinter.ProgramTypes.nameResolutionError e

          match fields with
          | [] -> $"{typeNamePart}.{caseName}"
          | fields ->
            let fieldPart =
              fields
              |> Builtin.List.map (fun field ->
                PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr field)
              |> Builtin.List.map (fun field -> $"({field})")
              |> Builtin.String.join " "

            $"{typeNamePart}.{caseName} {fieldPart}"

      let expr (e: PACKAGE.Darklang.LanguageTools.ProgramTypes.Expr) : String =
        match e with
        | EUnit _id -> "()"

        // simple data
        | EBool(_id, b) -> PACKAGE.Darklang.Stdlib.Bool.toString b
        | EInt(_id, i) -> Builtin.Int.toString i
        | EFloat(_id, sign, whole, remainder) ->
          let signPart = PACKAGE.Darklang.PrettyPrinter.sign sign

          let remainderPart =
            PACKAGE.Darklang.PrettyPrinter.processRemainder remainder

          $"{signPart}{whole}.{remainderPart}"


        | EChar(_id, c) -> "\"" ++ c ++ "\""

        | EString(_id, segments) ->
          match segments with
          | [] -> "\"\""
          | [ StringText text ] ->
            $"\"{PACKAGE.Darklang.PrettyPrinter.escapeSpecialCharacters text}\""
          | segments ->
            let inner =
              segments
              |> Builtin.List.map (fun segment ->
                PACKAGE.Darklang.PrettyPrinter.ProgramTypes.stringSegment segment)
              |> Builtin.String.join ""

            $"$\"{inner}\""


        // structures of data

        | EList(_id, items) ->
          items
          |> Builtin.List.map (fun item ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr item)
          |> Builtin.String.join "; "
          |> fun parts -> "[" ++ parts ++ "]"

        | EDict(_id, pairs) ->
          let pairPart =
            pairs
            |> Builtin.List.map (fun pair ->
              let (key, value) = pair
              $"{key} = {PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr value}")
            |> Builtin.String.join "; "
            |> fun parts -> "{ " ++ parts ++ " }"

          $"(Dict {pairPart})"


        | ETuple(_id, first, second, theRest) ->
          (Builtin.List.append [ first; second ] theRest)
          |> Builtin.List.map (fun item ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr item)
          |> Builtin.String.join ", "
          |> fun parts -> "(" ++ parts ++ ")"

        | ERecord(_id, typeName, fields) ->
          let typeNamePart =
            match typeName with
            | Ok name ->
              PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.fullForReference
                name
            | Error e ->
              PACKAGE.Darklang.PrettyPrinter.ProgramTypes.nameResolutionError e

          let fieldPart =
            fields
            |> Builtin.List.map (fun pair ->
              let (name, expr) = pair
              $"{name} = {PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr expr}")
            |> Builtin.String.join "; "
            |> fun parts -> "{ " ++ parts ++ " }"
            |> PACKAGE.Darklang.PrettyPrinter.indent

          $"{typeNamePart}\n{fieldPart}"

        | EEnum(_id, typeName, caseName, fields) ->
          let typeNamePart =
            match typeName with
            | Ok name ->
              PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.fullForReference
                name
            | Error e ->
              PACKAGE.Darklang.PrettyPrinter.ProgramTypes.nameResolutionError e

          match fields with
          | [] -> $"{typeNamePart}.{caseName}"
          | fields ->
            let fieldPart =
              fields
              |> Builtin.List.map (fun field ->
                PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr field)
              |> Builtin.String.join ", "

            $"{typeNamePart}.{caseName}({fieldPart})"


        // declaring and accessing variables

        | ELet(_id, pattern, rhs, body) ->
          let patternPart =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.letPattern pattern

          let rhsPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr rhs
          let bodyPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr body

          $"let {patternPart} =\n{PACKAGE.Darklang.PrettyPrinter.indent rhsPart}\n{bodyPart}"

        | EFieldAccess(id, expr, fieldName) ->
          let exprPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr expr

          // TODO: only sometimes need to wrap exprPart in parens

          $"({exprPart}).{fieldName}"

        | EVariable(_id, name) -> name


        // control flow

        | EIf(id, cond, thenBranch, elseBranch) ->
          let condPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr cond

          let thenPart =
            (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr thenBranch)
            |> PACKAGE.Darklang.PrettyPrinter.indent

          match elseBranch with
          | None -> $"if {condPart} then\n{thenPart}"
          | Some elseBranch ->
            let elsePart =
              (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr elseBranch)
              |> PACKAGE.Darklang.PrettyPrinter.indent

            $"if {condPart} then\n{thenPart}\nelse\n{elsePart}"

        | EMatch(_id, arg, cases) ->
          let cases =
            cases
            |> Builtin.List.map (fun pair ->
              let (pattern, body) = pair

              let patternPart =
                PACKAGE.Darklang.PrettyPrinter.ProgramTypes.matchPattern pattern

              let bodyPart =
                (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr body)
                |> PACKAGE.Darklang.PrettyPrinter.indent

              $"| {patternPart} ->\n{bodyPart}")

          let casesPart = Builtin.String.join cases "\n"

          let argPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr arg

          $"match {argPart} with \n{casesPart}"


        | EPipe(_id, expr, pipeExprs) ->
          // PACKAGE.Darklang.LanguageTools.ID *
          // PACKAGE.Darklang.LanguageTools.ProgramTypes.Expr *
          // List<PACKAGE.Darklang.LanguageTools.ProgramTypes.PipeExpr>
          let exprPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr expr

          let pipeParts =
            pipeExprs
            |> Builtin.List.map (fun (pipeExpr) ->
              PACKAGE.Darklang.PrettyPrinter.ProgramTypes.pipeExpr pipeExpr)
            |> Builtin.String.join " \n|> "

          $"{exprPart} \n|> {pipeParts}"



        // function calls

        | EInfix(_id, infix, left, right) ->
          let infixPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.infix infix

          let leftPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr left

          let rightPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr right

          // TODO: might need to wrap in parens
          $"({leftPart}) {infixPart} ({rightPart})"

        | ELambda(_id, args, body) ->
          let argsPart =
            args
            |> Builtin.List.map (fun pair ->
              PACKAGE.Darklang.Stdlib.Tuple2.second pair)
            |> Builtin.String.join " "

          let bodyPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr body

          $"(fun {argsPart} -> \n {PACKAGE.Darklang.PrettyPrinter.indent bodyPart})"

        | EApply(_id, fnName, typeArgs, args) ->
          let fnNamePart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr fnName

          let argsPart =
            args
            |> Builtin.List.map (fun arg ->
              PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr arg)
            |> Builtin.String.join " "

          match typeArgs with
          | [] -> $"{fnNamePart} {argsPart}"
          | _ ->
            let typeArgsPart =
              typeArgs
              |> Builtin.List.map (fun typeArg ->
                PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference typeArg)
              |> Builtin.String.join ", "

            $"{fnNamePart}<{typeArgsPart}> {argsPart}"

        | EFnName(_id, fnName) ->
          match fnName with
          | Ok name ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FnName.fullForReference name
          | Error e ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.nameResolutionError e

        // PACKAGE.Darklang.LanguageTools.ID *
        // record: PACKAGE.Darklang.LanguageTools.ProgramTypes.Expr *
        // updates: List<String * PACKAGE.Darklang.LanguageTools.ProgramTypes.Expr>
        | ERecordUpdate(_id, record, updates) ->
          let recordPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr record

          let updatePart =
            updates
            |> Builtin.List.map (fun pair ->
              let (fieldName, expr) = pair
              $"{fieldName} = {PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr expr}")
            |> Builtin.String.join "; "

          // TODO: don't always need the parens

          $"{{ ({recordPart}) with {updatePart} }}"

        | EConstant(_id, constant) ->
          match constant with
          | Ok name ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.ConstantName.fullForReference
              name
          | Error e ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.nameResolutionError e

        // CLEANUP: remove this case before shipping to users
        | expr ->
          let s =
            (Builtin.Json.serialize<PACKAGE.Darklang.LanguageTools.ProgramTypes.Expr>
              expr)
            |> Builtin.unwrap

          $"{s}"

      // CLEANUP this isn't currently used
      // if/when we uncomment this, take note that the `m` argument is a function
      // that we may not fully yet support (esp in name-resolution)
      // let deprecation<'name>
      //   (m: 'name -> String)
      //   (d: PACKAGE.Darklang.LanguageTools.ProgramTypes.Deprecation)
      //   : String =
      //   match d with
      //   | NotDeprecated -> "NotDeprecated"
      //   | RenamedTo name -> $"RenamedTo {m name}"
      //   | ReplacedBy name -> $"ReplacedBy {m name}"
      //   | DeprecatedBecause reason -> $"DeprecatedBecause {reason}"

      module TypeDeclaration =
        let recordField
          (d: PACKAGE.Darklang.LanguageTools.ProgramTypes.TypeDeclaration.RecordField)
          : String =
          // TODO: /// for description
          $"{d.name} : {PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference d.typ}"

        let enumField
          (d: PACKAGE.Darklang.LanguageTools.ProgramTypes.TypeDeclaration.EnumField)
          : String =
          match d.label with
          | None -> PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference d.typ
          | Some label ->
            $"{label}: {PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference d.typ}"

        let enumCase
          (d: PACKAGE.Darklang.LanguageTools.ProgramTypes.TypeDeclaration.EnumCase)
          : String =
          match d.fields with
          | [] -> "| " ++ d.name
          | fields ->
            let fieldPart =
              fields
              |> Builtin.List.map (fun field ->
                PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeDeclaration.enumField
                  field)
              |> Builtin.String.join " * "

            $"| {d.name} of {fieldPart}"


      let customType
        (d:
          PACKAGE.Darklang.LanguageTools.ProgramTypes.TypeDeclaration.TypeDeclaration)
        : String =
        match d.definition with
        | Alias typeRef ->
          PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference typeRef

        | Record fields ->
          let fieldsPart =
            fields
            |> Builtin.List.map (fun field ->
              PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeDeclaration.recordField
                field)
            |> Builtin.String.join "\n"

          "{\n" ++ (PACKAGE.Darklang.PrettyPrinter.indent fieldsPart) ++ "\n}"

        | Enum cases ->
          cases
          |> Builtin.List.map (fun case ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeDeclaration.enumCase
              case)
          |> Builtin.String.join "\n"


      module Handler =
        let cronInterval
          (c: PACKAGE.Darklang.LanguageTools.ProgramTypes.Handler.CronInterval)
          : String =
          match c with
          | EveryDay -> "Every Day"
          | EveryWeek -> "Every Week"
          | EveryFortnight -> "Every Fortnight"
          | EveryHour -> "Every Hour"
          | Every12Hours -> "Every 12 Hours"
          | EveryMinute -> "Every Minute"

        let spec
          (s: PACKAGE.Darklang.LanguageTools.ProgramTypes.Handler.Spec)
          : String =
          match s with
          | HTTP(route, method) -> $"[<HttpHandler({method}, {route})>]"
          | Worker name -> $"[<Worker({name})>]"
          | Cron(name, interval) ->
            $"[<Cron({name}, {PACKAGE.Darklang.PrettyPrinter.ProgramTypes.Handler.cronInterval interval})>]"
          | REPL name -> $"[<REPL({name})>]"

      let handler
        (h: PACKAGE.Darklang.LanguageTools.ProgramTypes.Handler.Handler)
        : String =
        let specPart =
          PACKAGE.Darklang.PrettyPrinter.ProgramTypes.Handler.spec h.spec

        $"{specPart}\nlet _handler _ignored =\n  {PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr h.ast}"


      let db (db: PACKAGE.Darklang.LanguageTools.ProgramTypes.DB) : String =
        let versionPart =
          if db.version == 0 then
            ""
          else
            $"_v{Builtin.Int.toString db.version}"

        let typPart =
          PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference db.typ

        $"type {db.name}{versionPart} = {typPart}"


      let userType
        (userType: PACKAGE.Darklang.LanguageTools.ProgramTypes.UserType)
        : String =
        let namePart =
          PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.UserProgram.atDefinition
            userType.name

        let typeParamPart =
          match userType.declaration.typeParams with
          | [] -> ""
          | _ ->
            userType.declaration.typeParams
            |> Builtin.List.map (fun typeParam -> $"'{typeParam}")
            |> Builtin.String.join ", "
            |> fun parts -> $"<{parts}>"

        let defPart =
          PACKAGE.Darklang.PrettyPrinter.ProgramTypes.customType userType.declaration

        $"type {namePart}{typeParamPart} =\n{PACKAGE.Darklang.PrettyPrinter.indent defPart}"


      module UserFunction =
        let parameter
          (p: PACKAGE.Darklang.LanguageTools.ProgramTypes.UserFunction.Parameter)
          : String =
          // TODO: handle `description`
          let typPart =
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference p.typ

          $"({p.name}: {typPart})"

      let userFunction
        (u: PACKAGE.Darklang.LanguageTools.ProgramTypes.UserFunction.UserFunction)
        : String =
        // TODO: do something with description and deprecated
        // TODO: shouldn't there be modules here somewhere?
        let namePart =
          PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FnName.UserProgram.atDefinition
            u.name

        let typeParamsPart = Builtin.String.join u.typeParams " "

        let paramsPart =
          Builtin.String.join
            (Builtin.List.map u.parameters (fun p ->
              PACKAGE.Darklang.PrettyPrinter.ProgramTypes.UserFunction.parameter p))
            " "

        let retPart =
          PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference u.returnType

        let bodyPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr u.body
        $"let {namePart} {typeParamsPart} {paramsPart} : {retPart} =\n{PACKAGE.Darklang.PrettyPrinter.indent bodyPart}"

      // module Toplevel =
      //   type T =
      //     | TLHandler of Handler.Handler
      //     | TLDB of DB
      //     | TLFunction of UserFunction.UserFunction
      //     | TLType of UserType.T


      // let secret (s: PACKAGE.Darklang.Stdlib.Secret.T) : String =
      //   let versionPart = if s.version == 0 then "" else $"_v{Builtin.Int.toString s.version}"

      //   $"let {s.name}{versionPart} = \"*****\""


      module PackageFn =
        let parameter
          (p: PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageFn.Parameter)
          : String =
          // TODO: /// for description
          $"({p.name}: {PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference p.typ})"

      let packageFn
        (p: PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageFn.PackageFn)
        : String =
        // TODO: handle `deprecated`, `description`
        let namePart =
          PACKAGE.Darklang.PrettyPrinter.ProgramTypes.FnName.Package.atDefinition
            p.name

        let typeParamPart =
          match p.typeParams with
          | [] -> ""
          | _ ->
            p.typeParams
            |> Builtin.List.map (fun typeParam -> $"'{typeParam}")
            |> Builtin.String.join ", "
            |> fun parts -> $"<{parts}>"

        let paramPart =
          p.parameters
          |> Builtin.List.map (fun param ->
            PACKAGE.Darklang.PrettyPrinter.ProgramTypes.PackageFn.parameter param)
          |> Builtin.String.join " "

        let retPart =
          PACKAGE.Darklang.PrettyPrinter.ProgramTypes.typeReference p.returnType

        let bodyPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.expr p.body

        $"let {namePart}{typeParamPart} {paramPart} : {retPart} =\n{PACKAGE.Darklang.PrettyPrinter.indent bodyPart}"


      let packageType
        (p: PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageType)
        : String =
        // TODO: take care of deprecated and description
        let namePart =
          PACKAGE.Darklang.PrettyPrinter.ProgramTypes.TypeName.Package.atDefinition
            p.name

        let typeParamPart =
          match p.declaration.typeParams with
          | [] -> ""
          | _ ->
            p.declaration.typeParams
            |> Builtin.List.map (fun typeParam -> $"'{typeParam}")
            |> Builtin.String.join ", "
            |> fun parts -> $"<{parts}>"

        let defPart =
          (PACKAGE.Darklang.PrettyPrinter.ProgramTypes.customType p.declaration)
          |> PACKAGE.Darklang.PrettyPrinter.indent

        $"type {namePart}{typeParamPart} =\n{defPart}"


      let packageConstant
        (p: PACKAGE.Darklang.LanguageTools.ProgramTypes.PackageConstant)
        : String =
        let namePart =
          PACKAGE.Darklang.PrettyPrinter.ProgramTypes.ConstantName.Package.atDefinition
            p.name

        let bodyPart = PACKAGE.Darklang.PrettyPrinter.ProgramTypes.constant p.body

        $"let {namePart} = {bodyPart}"