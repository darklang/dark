module Darklang.PrettyPrinter

module ModuleDeclaration =
  type Module =
    { name: String
      types: List<LanguageTools.ProgramTypes.PackageType.PackageType>
      fns: List<LanguageTools.ProgramTypes.PackageFn.PackageFn>
      values: List<LanguageTools.ProgramTypes.PackageValue.PackageValue>
      exprs: List<LanguageTools.ProgramTypes.Expr * List<String>>
      submodules: List<Module> }

  let withTypeHelper
    (ms: List<Module>)
    (t: LanguageTools.ProgramTypes.PackageType.PackageType)
    (modulePath: List<String>)
    : List<Module> =
    match modulePath with
    | [] ->
      [ Module
          { name = "type has no modules"
            types = [ t ]
            fns = []
            values = []
            exprs = []
            submodules = [] } ]

    | firstModuleNamePart :: submoduleNames ->
      let (foundModuleMaybe, otherModules) =
        ms |> Stdlib.List.partition (fun m -> m.name == firstModuleNamePart)

      match (foundModuleMaybe, submoduleNames) with
      | [], [] ->
        let newModule =
          Module
            { name = firstModuleNamePart
              types = [ t ]
              fns = []
              values = []
              exprs = []
              submodules = [] }

        Stdlib.List.append otherModules [ newModule ]

      | [], submoduleNames ->
        let newModuleWithSubmodule =
          Module
            { name = firstModuleNamePart
              types = []
              fns = []
              values = []
              exprs = []
              submodules = withTypeHelper [] t submoduleNames }

        Stdlib.List.append otherModules [ newModuleWithSubmodule ]

      | [ foundModule ], [] ->
        let updatedModule =
          { foundModule with
              types = Stdlib.List.append foundModule.types [ t ] }

        Stdlib.List.append otherModules [ updatedModule ]

      | [ foundModule ], submoduleNames ->
        let updatedModule =
          { foundModule with
              submodules = withTypeHelper foundModule.submodules t submoduleNames }

        Stdlib.List.append otherModules [ updatedModule ]

  let withType
    (ms: List<Module>)
    (t: LanguageTools.ProgramTypes.PackageType.PackageType)
    : List<Module> =
    match Builtin.pmGetLocationByType t.id with
    | None ->
      [ Module
          { name = "type with unknown location"
            types = [ t ]
            fns = []
            values = []
            exprs = []
            submodules = [] } ]
    | Some location ->
      let fullPath = Stdlib.List.push location.modules location.owner
      withTypeHelper ms t fullPath


  let withFnHelper
    (ms: List<Module>)
    (f: LanguageTools.ProgramTypes.PackageFn.PackageFn)
    (modulePath: List<String>)
    : List<Module> =
    match modulePath with
    | [] ->
      [ Module
          { name = "fn has no modules"
            types = []
            fns = [ f ]
            values = []
            exprs = []
            submodules = [] } ]

    | firstModuleNamePart :: submoduleNames ->
      let (foundModuleMaybe, otherModules) =
        ms |> Stdlib.List.partition (fun m -> m.name == firstModuleNamePart)

      match (foundModuleMaybe, submoduleNames) with
      | [], [] ->
        let newModule =
          Module
            { name = firstModuleNamePart
              types = []
              fns = [ f ]
              values = []
              exprs = []
              submodules = [] }

        Stdlib.List.append otherModules [ newModule ]

      | [], submoduleNames ->
        let newModuleWithSubmodule =
          Module
            { name = firstModuleNamePart
              types = []
              fns = []
              values = []
              exprs = []
              submodules = withFnHelper [] f submoduleNames }

        Stdlib.List.append otherModules [ newModuleWithSubmodule ]

      | [ foundModule ], [] ->
        let updatedModule =
          { foundModule with
              fns = Stdlib.List.append foundModule.fns [ f ] }

        Stdlib.List.append otherModules [ updatedModule ]

      | [ foundModule ], submoduleNames ->
        let updatedModule =
          { foundModule with
              submodules = withFnHelper foundModule.submodules f submoduleNames }

        Stdlib.List.append otherModules [ updatedModule ]

  let withFn
    (ms: List<Module>)
    (f: LanguageTools.ProgramTypes.PackageFn.PackageFn)
    : List<Module> =
    match Builtin.pmGetLocationByFn f.id with
    | None ->
      [ Module
          { name = "fn with unknown location"
            types = []
            fns = [ f ]
            values = []
            exprs = []
            submodules = [] } ]
    | Some location ->
      let fullPath = Stdlib.List.push location.modules location.owner
      withFnHelper ms f fullPath

  let withValueHelper
    (ms: List<Module>)
    (v: LanguageTools.ProgramTypes.PackageValue.PackageValue)
    (modulePath: List<String>)
    : List<Module> =
    match modulePath with
    | [] ->
      [ Module
          { name = "value has no modules"
            types = []
            fns = []
            values = [ v ]
            exprs = []
            submodules = [] } ]

    | firstModuleNamePart :: submoduleNames ->
      let (foundModuleMaybe, otherModules) =
        ms |> Stdlib.List.partition (fun m -> m.name == firstModuleNamePart)

      match (foundModuleMaybe, submoduleNames) with
      | [], [] ->
        let newModule =
          Module
            { name = firstModuleNamePart
              types = []
              fns = []
              values = [ v ]
              exprs = []
              submodules = [] }

        Stdlib.List.append otherModules [ newModule ]

      | [], submoduleNames ->
        let newModuleWithSubmodule =
          Module
            { name = firstModuleNamePart
              types = []
              fns = []
              values = []
              exprs = []
              submodules = withValueHelper [] v submoduleNames }

        Stdlib.List.append otherModules [ newModuleWithSubmodule ]

      | [ foundModule ], [] ->
        let updatedModule =
          { foundModule with
              values = Stdlib.List.append foundModule.values [ v ] }

        Stdlib.List.append otherModules [ updatedModule ]

      | [ foundModule ], submoduleNames ->
        let updatedModule =
          { foundModule with
              submodules = withValueHelper foundModule.submodules v submoduleNames }

        Stdlib.List.append otherModules [ updatedModule ]

  let withValue
    (ms: List<Module>)
    (v: LanguageTools.ProgramTypes.PackageValue.PackageValue)
    : List<Module> =
    match Builtin.pmGetLocationByValue v.id with
    | None ->
      [ Module
          { name = "value with unknown location"
            types = []
            fns = []
            values = [ v ]
            exprs = []
            submodules = [] } ]
    | Some location ->
      let fullPath = Stdlib.List.push location.modules location.owner
      withValueHelper ms v fullPath


  let withExpr
    (ms: List<Module>)
    (e: (LanguageTools.ProgramTypes.Expr * List<String>))
    : List<Module> =
    let (expr, modules) = e

    match modules with
    | [] ->
      [ Module
          { name = "expression has no modules"
            types = []
            fns = []
            values = []
            exprs = [ (expr, []) ]
            submodules = [] } ]

    | firstModuleNamePart :: submoduleNames ->
      let (foundModuleMaybe, otherModules) =
        ms |> Stdlib.List.partition (fun m -> m.name == firstModuleNamePart)

      match (foundModuleMaybe, submoduleNames) with
      | [], [] ->
        let newModule =
          Module
            { name = firstModuleNamePart
              types = []
              fns = []
              values = []
              exprs = [ (expr, []) ]
              submodules = [] }

        Stdlib.List.append otherModules [ newModule ]

      | [], submoduleNames ->
        let newModuleWithSubmodule =
          Module
            { name = firstModuleNamePart
              types = []
              fns = []
              values = []
              exprs = []
              submodules = withExpr [] (expr, submoduleNames) }

        Stdlib.List.append otherModules [ newModuleWithSubmodule ]

      | [ foundModule ], [] ->
        let updatedModule =
          { foundModule with
              exprs = Stdlib.List.append foundModule.exprs [ (expr, []) ] }

        Stdlib.List.append otherModules [ updatedModule ]

      | [ foundModule ], submoduleNames ->
        let updatedModule =
          { foundModule with
              submodules = withExpr foundModule.submodules (expr, submoduleNames) }

        Stdlib.List.append otherModules [ updatedModule ]



  let toModules
    (p: LanguageTools.ProgramTypes.Definitions)
    : List<Module> =
    let empty = []

    let modulesAfterTypes =
      Stdlib.List.fold p.types empty (fun modules t ->
        ModuleDeclaration.withType modules t)

    let modulesWithTypesAndFns =
      Stdlib.List.fold p.fns modulesAfterTypes (fun modules f ->
        ModuleDeclaration.withFn modules f)

    let modulesWithTypesAndFnsAndValues =
      Stdlib.List.fold p.values modulesWithTypesAndFns (fun modules v ->
        ModuleDeclaration.withValue modules v)

    let modulesWithTypesAndFnsAndValuesAndExprs =
      Stdlib.List.fold
        p.exprs
        modulesWithTypesAndFnsAndValues
        (fun modules e -> withExpr modules e)


    modulesWithTypesAndFnsAndValuesAndExprs


let moduleDeclaration
  (ctx: PrettyPrinter.ProgramTypes.Context)
  (m: ModuleDeclaration.Module)
  : String =
  let headerPart = $"module {m.name} =\n"

  let typesPart =
    match m.types with
    | [] -> Stdlib.Option.Option.None
    | types ->
      m.types
      |> Stdlib.List.map (fun t -> PrettyPrinter.ProgramTypes.packageType t)
      |> Stdlib.String.join "\n\n"
      |> Stdlib.Option.Option.Some

  let fnsPart =
    match m.fns with
    | [] -> Stdlib.Option.Option.None
    | fns ->
      m.fns
      |> Stdlib.List.map (fun f -> PrettyPrinter.ProgramTypes.packageFn ctx f)
      |> Stdlib.String.join "\n\n"
      |> Stdlib.Option.Option.Some

  let valuesPart =
    match m.values with
    | [] -> Stdlib.Option.Option.None
    | values ->
      m.values
      |> Stdlib.List.map (fun v -> PrettyPrinter.ProgramTypes.packageValue ctx v)
      |> Stdlib.String.join "\n\n"
      |> Stdlib.Option.Option.Some

  let exprsPart =
    match m.exprs with
    | [] -> Stdlib.Option.Option.None
    | exprs ->
      m.exprs
      |> Stdlib.List.map (fun (e, _) -> PrettyPrinter.ProgramTypes.expr ctx e)
      |> Stdlib.String.join "\n\n"
      |> Stdlib.Option.Option.Some


  let submodulesPart =
    match m.submodules with
    | [] -> Stdlib.Option.Option.None
    | submodules ->
      submodules
      |> Stdlib.List.map (fun m -> PrettyPrinter.moduleDeclaration ctx m)
      |> Stdlib.String.join "\n\n"
      |> Stdlib.Option.Option.Some

  let parts =
    [ typesPart; fnsPart; valuesPart; exprsPart; submodulesPart ]
    |> Stdlib.List.filterMap (fun s -> s)

  match parts with
  | [] ->
    // CLEANUP: actually error
    "Error - module defined somehow without parts"
  | parts ->
    let bodyPart = (Stdlib.String.join parts "\n\n") |> PrettyPrinter.indent

    $"module {m.name} =\n{bodyPart}"


let definitions
  (ctx: PrettyPrinter.ProgramTypes.Context)
  (p: LanguageTools.ProgramTypes.Definitions)
  : String =
  let modules = ModuleDeclaration.toModules p

  // CLEANUP make ordering 'better' in some way
  modules
  |> Stdlib.List.map (fun m -> PrettyPrinter.moduleDeclaration ctx m)
  |> Stdlib.String.join "\n\n"