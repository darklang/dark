module Darklang.Cli.Completion

type ParsedInput =
  { commandName: String
    args: List<String>
    isCompletingCommand: Bool }


let parseInput (input: String) : ParsedInput =
  let trimmed = Stdlib.String.trim input

  if Stdlib.String.isEmpty trimmed then
    ParsedInput { commandName = ""; args = []; isCompletingCommand = true }
  else
    let words = Stdlib.String.split trimmed " "
    match words with
    | [] -> ParsedInput { commandName = ""; args = []; isCompletingCommand = true }
    | [command] -> ParsedInput { commandName = command; args = []; isCompletingCommand = true }
    | command :: args -> ParsedInput { commandName = command; args = args; isCompletingCommand = false }


let getPartialCompletion (parsed: ParsedInput) : String =
  if parsed.isCompletingCommand then
    parsed.commandName
  else
    match Stdlib.List.last parsed.args with
    | Some lastArg -> lastArg
    | None -> ""


let buildCompletedCommand (parsed: ParsedInput) (completion: String) : String =
  if parsed.isCompletingCommand then
    completion
  else
    // Replace last argument with completion
    let argsWithoutLast = Stdlib.List.dropLast parsed.args
    let newArgs = Stdlib.List.append argsWithoutLast [completion]
    let fullCommand = Stdlib.List.append [parsed.commandName] newArgs
    Stdlib.String.join fullCommand " "


let getHintFromCompletions (partial: String) (completions: List<String>) : String =
  match completions with
  | [] -> ""
  | [singleCompletion] ->
    if Stdlib.String.startsWith singleCompletion partial then
      Stdlib.String.dropFirst singleCompletion (Stdlib.String.length partial)
    else
      ""
  | multiple ->
    let commonPrefix = findCommonPrefix multiple
    if Stdlib.String.startsWith commonPrefix partial && Stdlib.String.length commonPrefix > Stdlib.String.length partial then
      Stdlib.String.dropFirst commonPrefix (Stdlib.String.length partial)
    else
      ""


// Standard completion for commands that complete with other command names
// (right now, just `help`)
let commandNamesCompletion (_state: AppState) (args: List<String>) : List<String> =
  match args with
  | [] ->
    // Suggest all command names and aliases
    let commands = Registry.allCommands ()
    let commandNames = Stdlib.List.map commands (fun cmd -> cmd.name)
    let allAliases = Stdlib.List.fold commands [] (fun acc cmd -> Stdlib.List.append acc cmd.aliases)
    Stdlib.List.append commandNames allAliases
  | [partialArg] ->
    // Filter by partial match
    let commands = Registry.allCommands ()
    let commandNames = Stdlib.List.map commands (fun cmd -> cmd.name)
    let allAliases = Stdlib.List.fold commands [] (fun acc cmd -> Stdlib.List.append acc cmd.aliases)
    let allOptions = Stdlib.List.append commandNames allAliases
    Stdlib.List.filter allOptions (fun name -> Stdlib.String.startsWith name partialArg)
  | _ ->
    // Only complete first argument
    []


// Helper functions for finding common prefixes in completions
let findCommonLength (str1: String) (str2: String) (index: Int64) (maxLen: Int64) : Int64 =
  if index >= maxLen then
    index
  else
    let char1 = Stdlib.String.slice str1 index (index + 1L)
    let char2 = Stdlib.String.slice str2 index (index + 1L)
    if char1 == char2 then
      findCommonLength str1 str2 (index + 1L) maxLen
    else
      index

let findCommonPrefix (strings: List<String>) : String =
  match strings with
  | [] -> ""
  | [single] -> single
  | first :: rest ->
    Stdlib.List.fold rest first (fun acc next ->
      let maxLen = Stdlib.Int64.min (Stdlib.String.length acc) (Stdlib.String.length next)
      let commonLen = findCommonLength acc next 0L maxLen
      Stdlib.String.slice acc 0L commonLen)


// Filesystem completion helpers

/// Add trailing slashes to directory names in a file list
let addSlashToDirectories (baseDir: String) (files: List<String>) : List<String> =
  files
  |> Stdlib.List.map (fun file ->
    if Stdlib.Cli.FileSystem.isDirectoryAtPath baseDir file then
      $"{file}/"
    else
      file)


/// Complete filesystem paths, handling . .. and / separators
let completeFilesystemPath (partialArg: String) : List<String> =
  let currentDir = "."

  if partialArg == "." then
    addSlashToDirectories currentDir (Stdlib.Cli.FileSystem.getDirectoryContents ".")
  else if partialArg == ".." then
    [ "../" ]
  else if Stdlib.String.contains partialArg "/" then
    match Stdlib.String.lastIndexOf partialArg "/" with
    | Some idx ->
      let dirPart = Stdlib.String.slice partialArg 0L (idx + 1L)
      let filePart = Stdlib.String.dropFirst partialArg (idx + 1L)

      let fullPath =
        if Stdlib.String.startsWith dirPart "/" then
          dirPart
        else
          $"{currentDir}/{dirPart}"

      (Stdlib.Cli.FileSystem.getDirectoryContents fullPath)
      |> Stdlib.List.filter (fun f -> Stdlib.String.startsWith f filePart)
      |> Stdlib.List.map (fun f ->
        if Stdlib.Cli.FileSystem.isDirectoryAtPath fullPath f then
          $"{dirPart}{f}/"
        else
          $"{dirPart}{f}")
    | None -> []
  else
    let files =
      (Stdlib.Cli.FileSystem.getDirectoryContents ".")
      |> Stdlib.List.filter (fun f -> Stdlib.String.startsWith f partialArg)

    addSlashToDirectories currentDir files
