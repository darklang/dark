module Darklang.Cli.Completion

type ParsedInput =
  { commandName: String
    args: List<String>
    isCompletingCommand: Bool }


let parseInput (input: String) : ParsedInput =
  let trimmed = Stdlib.String.trim input

  if Stdlib.String.isEmpty trimmed then
    ParsedInput { commandName = ""; args = []; isCompletingCommand = true }
  else
    let words = Stdlib.String.split trimmed " "
    match words with
    | [] -> ParsedInput { commandName = ""; args = []; isCompletingCommand = true }
    | [command] -> ParsedInput { commandName = command; args = []; isCompletingCommand = true }
    | command :: args -> ParsedInput { commandName = command; args = args; isCompletingCommand = false }


let getPartialCompletion (parsed: ParsedInput) : String =
  if parsed.isCompletingCommand then
    parsed.commandName
  else
    match Stdlib.List.last parsed.args with
    | Some lastArg -> lastArg
    | None -> ""


let buildCompletedCommand (parsed: ParsedInput) (completion: String) : String =
  if parsed.isCompletingCommand then
    completion
  else
    // Replace last argument with completion
    let argsWithoutLast = Stdlib.List.dropLast parsed.args
    let newArgs = Stdlib.List.append argsWithoutLast [completion]
    let fullCommand = Stdlib.List.append [parsed.commandName] newArgs
    Stdlib.String.join fullCommand " "


let getHintFromCompletions (partial: String) (completions: List<String>) : String =
  match completions with
  | [] -> ""
  | [singleCompletion] ->
    if Stdlib.String.startsWith singleCompletion partial then
      Stdlib.String.dropFirst singleCompletion (Stdlib.String.length partial)
    else
      ""
  | multiple ->
    let commonPrefix = findCommonPrefix multiple
    if Stdlib.String.startsWith commonPrefix partial && Stdlib.String.length commonPrefix > Stdlib.String.length partial then
      Stdlib.String.dropFirst commonPrefix (Stdlib.String.length partial)
    else
      ""


// Standard completion for commands that complete with other command names
// (right now, just `help`)
let commandNamesCompletion (_state: AppState) (args: List<String>) : List<String> =
  match args with
  | [] ->
    // Suggest all command names and aliases
    let commands = Registry.allCommands ()
    let commandNames = Stdlib.List.map commands (fun cmd -> cmd.name)
    let allAliases = Stdlib.List.fold commands [] (fun acc cmd -> Stdlib.List.append acc cmd.aliases)
    Stdlib.List.append commandNames allAliases
  | [partialArg] ->
    // Filter by partial match
    let commands = Registry.allCommands ()
    let commandNames = Stdlib.List.map commands (fun cmd -> cmd.name)
    let allAliases = Stdlib.List.fold commands [] (fun acc cmd -> Stdlib.List.append acc cmd.aliases)
    let allOptions = Stdlib.List.append commandNames allAliases
    Stdlib.List.filter allOptions (fun name -> Stdlib.String.startsWith name partialArg)
  | _ ->
    // Only complete first argument
    []


// Helper functions for finding common prefixes in completions
let findCommonLength (str1: String) (str2: String) (index: Int64) (maxLen: Int64) : Int64 =
  if index >= maxLen then
    index
  else
    let char1 = Stdlib.String.slice str1 index (index + 1L)
    let char2 = Stdlib.String.slice str2 index (index + 1L)
    if char1 == char2 then
      findCommonLength str1 str2 (index + 1L) maxLen
    else
      index

let findCommonPrefix (strings: List<String>) : String =
  match strings with
  | [] -> ""
  | [single] -> single
  | first :: rest ->
    Stdlib.List.fold rest first (fun acc next ->
      let maxLen = Stdlib.Int64.min (Stdlib.String.length acc) (Stdlib.String.length next)
      let commonLen = findCommonLength acc next 0L maxLen
      Stdlib.String.slice acc 0L commonLen)
