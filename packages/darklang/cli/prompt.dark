module Darklang.Cli.Prompt

/// State for prompt-specific fields (text, cursor, history)
type State =
  { text: String
    cursorPosition: Int64
    commandHistory: List<String>
    historyIndex: Int64
    savedPrompt: String
    /// Tracks text length from last display update, used to calculate cursor row for long lines
    previousTextLength: Int64 }

let initState () : State =
  State
    { text = ""
      cursorPosition = 0L
      commandHistory = []
      historyIndex = -1L
      savedPrompt = ""
      previousTextLength = 0L }


module Editing =
  /// Insert text at cursor position
  let insertAtCursor (state: State) (char: String) : State =
    let prevLen = Stdlib.String.length state.text
    let beforeCursor = Stdlib.String.slice state.text 0L state.cursorPosition
    let afterCursor = Stdlib.String.dropFirst state.text state.cursorPosition
    let newText = beforeCursor ++ char ++ afterCursor
    { state with
        text = newText
        cursorPosition = state.cursorPosition + (Stdlib.String.length char)
        historyIndex = -1L
        savedPrompt = ""
        previousTextLength = prevLen }

  /// Delete character before cursor (backspace)
  let deleteBeforeCursor (state: State) : State =
    if state.cursorPosition > 0L then
      let prevLen = Stdlib.String.length state.text
      let beforeCursor = Stdlib.String.slice state.text 0L (state.cursorPosition - 1L)
      let afterCursor = Stdlib.String.dropFirst state.text state.cursorPosition
      let newText = beforeCursor ++ afterCursor
      { state with
          text = newText
          cursorPosition = state.cursorPosition - 1L
          historyIndex = -1L
          previousTextLength = prevLen }
    else
      state

  /// Delete character at cursor (delete key)
  let deleteAtCursor (state: State) : State =
    let textLength = Stdlib.String.length state.text

    if state.cursorPosition < textLength then
      let prevLen = textLength
      let beforeCursor = Stdlib.String.slice state.text 0L state.cursorPosition
      let afterCursor = Stdlib.String.dropFirst state.text (state.cursorPosition + 1L)
      let newText = beforeCursor ++ afterCursor
      { state with text = newText; historyIndex = -1L; previousTextLength = prevLen }
    else
      state

  /// Move cursor left
  let moveCursorLeft (state: State) : State =
    let newCursorPos = Stdlib.Int64.max 0L (state.cursorPosition - 1L)
    { state with cursorPosition = newCursorPos }

  /// Move cursor right
  let moveCursorRight (state: State) : State =
    let textLength = Stdlib.String.length state.text
    let newCursorPos = Stdlib.Int64.min textLength (state.cursorPosition + 1L)
    { state with cursorPosition = newCursorPos }

  /// Move cursor to start of line
  let moveCursorHome (state: State) : State =
    { state with cursorPosition = 0L }

  /// Move cursor to end of line
  let moveCursorEnd (state: State) : State =
    let textLength = Stdlib.String.length state.text
    { state with cursorPosition = textLength }

  /// Clear the prompt text
  let clear (state: State) : State =
    let prevLen = Stdlib.String.length state.text
    { state with
        text = ""
        cursorPosition = 0L
        historyIndex = -1L
        previousTextLength = prevLen }

  /// Set the prompt text and move cursor to end
  let setText (state: State) (text: String) : State =
    let prevLen = Stdlib.String.length state.text
    let textLength = Stdlib.String.length text
    { state with text = text; cursorPosition = textLength; previousTextLength = prevLen }


module History =
  /// Add command to history (avoiding duplicates at the front)
  let addCommand (state: State) (command: String) : State =
    let updatedHistory =
      if Stdlib.List.isEmpty state.commandHistory || Stdlib.List.head state.commandHistory != Stdlib.Option.Option.Some command then
        Stdlib.List.append [command] state.commandHistory
      else
        state.commandHistory
    { state with
        commandHistory = updatedHistory
        historyIndex = -1L }

  /// Navigate to previous command in history
  let navigatePrevious (state: State) : State =
    if Stdlib.Bool.not (Stdlib.List.isEmpty state.commandHistory) then
      let prevLen = Stdlib.String.length state.text
      let historyLength = Stdlib.List.length state.commandHistory
      let newIndex =
        if state.historyIndex == -1L then
          0L  // Start from the most recent command
        else
          if state.historyIndex < (historyLength - 1L) then
            state.historyIndex + 1L
          else
            state.historyIndex  // Stay at oldest command
      match Stdlib.List.getAt state.commandHistory newIndex with
      | Some command ->
        let commandLength = Stdlib.String.length command
        let newSavedPrompt =
          if state.historyIndex == -1L then
            state.text
          else
            state.savedPrompt
        { state with
            text = command
            cursorPosition = commandLength
            historyIndex = newIndex
            savedPrompt = newSavedPrompt
            previousTextLength = prevLen }
      | None ->
        state
    else
      state

  /// Navigate to next command in history
  let navigateNext (state: State) : State =
    if Stdlib.Bool.not (Stdlib.List.isEmpty state.commandHistory) && state.historyIndex >= 0L then
      let prevLen = Stdlib.String.length state.text
      let newIndex =
        if state.historyIndex > 0L then
          state.historyIndex - 1L
        else
          -1L  // Go back to empty prompt
      if newIndex == -1L then
        let restoredPromptLength = Stdlib.String.length state.savedPrompt
        { state with
            text = state.savedPrompt
            cursorPosition = restoredPromptLength
            historyIndex = newIndex
            previousTextLength = prevLen }
      else
        match Stdlib.List.getAt state.commandHistory newIndex with
        | Some command ->
          let commandLength = Stdlib.String.length command
          { state with
              text = command
              cursorPosition = commandLength
              historyIndex = newIndex
              previousTextLength = prevLen }
        | None ->
          state
    else
      state


module Display =
  /// Format the complete prompt with input and optional hint
  let formatPromptWithInput
    (locationStr: String)
    (text: String)
    (hint: String)
    : String =
    let formattedLocation =
      if Stdlib.String.isEmpty locationStr then
        ""
      else
        Colors.dimText $"{locationStr} "

    if Stdlib.String.isEmpty hint then
      formattedLocation ++ "> " ++ text
    else
      formattedLocation ++ "> " ++ text ++ (Colors.hint hint)

  /// Calculate the column where user input starts (after location + "> ")
  let calculateInputStartColumn (locationStr: String) : Int64 =
    let locationLength =
      if Stdlib.String.isEmpty locationStr then
        0L
      else
        (Stdlib.String.length locationStr) + 1L  // +1 for the space after path

    locationLength
    + (Stdlib.String.length "> ")
    + 1L
