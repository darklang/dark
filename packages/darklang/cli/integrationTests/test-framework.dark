module Darklang =
  module Cli =
    module IntegrationTests =
      module TestFramework =
        type InteractiveStep =
          | SendInput of input: String
          | ExpectOutput of pattern: String
          | Wait of milliseconds: Int64
          | SendQuit

        type InteractiveCliTest =
          { name: String
            steps: List<InteractiveStep>
            timeoutSeconds: Int64 }

        type CliTest =
          { name: String
            arguments: List<String>
            expectedOutputFile: String
            isInteractive: Bool
            interactiveTest: Stdlib.Option.Option<InteractiveCliTest> }

        type TestResult =
          | Success of message: String
          | Failure of message: String
          | SetupComplete of message: String


        let makeCliTest
          (name: String)
          (arguments: List<String>)
          (expectedOutputFile: String): CliTest =
          CliTest
            { name = name
              arguments = arguments
              expectedOutputFile = expectedOutputFile
              isInteractive = false
              interactiveTest = Stdlib.Option.Option.None }

        let makeInteractiveCliTest
          (name: String)
          (steps: List<InteractiveStep>)
          (timeoutSeconds: Int64): CliTest =
          let interactiveTest =
            InteractiveCliTest
              { name = name
                steps = steps
                timeoutSeconds = timeoutSeconds }
          CliTest
            { name = name
              arguments = []
              expectedOutputFile = ""
              isInteractive = true
              interactiveTest = Stdlib.Option.Option.Some interactiveTest }


        let createDirectories (): Stdlib.Result.Result<Unit, String> =
          match TestUtils.createDirectory (TestConfig.getActualDir ()) with
          | Error e -> Stdlib.Result.Result.Error $"Failed to create actual directory: {e}"
          | Ok _ ->
            match TestUtils.createDirectory (TestConfig.getExpectedDir ()) with
            | Error e -> Stdlib.Result.Result.Error $"Failed to create expected directory: {e}"
            | Ok _ -> Stdlib.Result.Result.Ok ()


        let runCliCommand (command: String) (outputFile: String): Stdlib.Result.Result<Unit, String> =
          let fullCommand = $"cd {TestConfig.projectRoot} && {command} > {outputFile} 2>&1"
          let result = Builtin.cliExecute fullCommand
          if result.exitCode == 0L then
            Stdlib.Result.Result.Ok ()
          else
            Error $"CLI command failed with exit code {Stdlib.Int64.toString result.exitCode}: {result.stderr}"


        let isFileEmpty (filePath: String): Bool =
          match TestUtils.getFileContent filePath with
          | Ok content -> Stdlib.Bool.not (Stdlib.String.isEmpty content)
          | Error _ -> false

        let filesAreEqual (file1: String) (file2: String): Bool =
          let result = Builtin.cliExecute $"diff -q {file1} {file2}"
          result.exitCode == 0L

        let generateDiff (expectedFile: String) (actualFile: String): String =
          let result = Builtin.cliExecute $"diff --unified=3 --color=always {expectedFile} {actualFile}"
          result.stdout

        let copyFile (source: String) (destination: String): Stdlib.Result.Result<Unit, String> =
          match TestUtils.getFileContent source with
          | Ok content -> TestUtils.writeFileContent destination content
          | Error e -> Error e

        // ====================================================================
        // INTERACTIVE TEST EXECUTION USING EXPECT
        // ====================================================================
        // expect is an automation tool that can control interactive programs
        // It works by:
        // 1. Spawning a subprocess (our CLI)
        // 2. Sending input to it (like a user typing)
        // 3. Waiting for specific output patterns to appear
        // 4. Timing out if expected patterns don't appear

        module InteractiveTestRunner =
          // Generates input commands for expect script
          let generateInputCommand (input: String): String =
            let escapedInput = TestUtils.escapeForExpect input
            $"send \"{escapedInput}\\r\""  // Send the whole command + Enter

          // Generates a complete expect script that automates CLI interaction
          let generateExpectScript (steps: List<InteractiveStep>) (timeoutSeconds: Int64): String =
            // Find expect executable location
            let expectLocation =
              let whichResult = Builtin.cliExecute "which expect"
              if whichResult.exitCode == 0L then
                Stdlib.String.trim whichResult.stdout
              else
                "/usr/bin/expect"  // Common default location

            // Script header: shebang, timeout setting, and spawn CLI process
            let header = $"#!{expectLocation} -f\nset timeout {Stdlib.Int64.toString timeoutSeconds}\nspawn ./scripts/run-cli\nsleep 1\n"

            // Convert each test step into expect script commands
            let stepCommands =
              steps
              |> Stdlib.List.indexedMap (fun i step ->
                match step with
                // SendInput: Simulates user typing a command
                | SendInput input -> generateInputCommand input

                // ExpectOutput: Waits for a pattern to appear in CLI output
                // If pattern doesn't appear within timeout, test fails with detailed error
                | ExpectOutput pattern ->
                  $"expect {{\n  -re \"{pattern}\" {{}}\n  timeout {{ puts \"âŒ STEP {Stdlib.Int64.toString (i + 1L)}: TIMEOUT - Expected pattern '{pattern}' not found after {Stdlib.Int64.toString timeoutSeconds} seconds\"; exit 1 }}\n  eof {{ puts \"âŒ STEP {Stdlib.Int64.toString (i + 1L)}: EOF - Process ended unexpectedly while waiting for '{pattern}'\"; exit 1 }}\n}}"
                | Wait milliseconds -> $"after {Stdlib.Int64.toString milliseconds}"
                | SendQuit -> "send \"\\033\""  // \033 is Escape key
              )
              |> Stdlib.String.join "\n"

            // Script footer: wait for CLI process to end cleanly
            let footer = "expect eof\n"

            $"{header}{stepCommands}\n{footer}"

          // Executes an interactive test by:
          // 1. Generating expect script
          // 2. Writing script to temporary file
          // 3. Making script executable
          // 4. Running script and capturing output
          // 5. Parsing results for success/failure
          let runInteractiveTest (interactiveTest: InteractiveCliTest): TestResult =
            let expectScript = generateExpectScript interactiveTest.steps interactiveTest.timeoutSeconds
            let expectFile = $"{TestConfig.testDir}/temp-expect-{TestUtils.safeFileName interactiveTest.name}.exp"

            // Write the generated expect script to a file
            match TestUtils.writeFileContent expectFile expectScript with
            | Error e -> TestResult.Failure $"Failed to write expect script: {e}"
            | Ok _ ->
              // Make the script executable (chmod +x)
              let chmodResult = Builtin.cliExecute $"chmod +x {expectFile}"
              if chmodResult.exitCode != 0L then
                TestResult.Failure "Failed to make expect script executable"
              else
                // Run the expect script and capture all output
                let result = Builtin.cliExecute $"cd {TestConfig.projectRoot} && {expectFile} 2>&1"

                // Clean up temporary script file
                TestUtils.deleteFile expectFile

                if result.exitCode == 0L then
                  TestResult.Success $"Interactive test {interactiveTest.name} passed - all ExpectOutput validations succeeded"
                else
                  let errorOutput = Stdlib.String.trim result.stdout
                  let specificError =
                    if Stdlib.String.contains errorOutput "Expected pattern '" then
                      // Extract which pattern failed to match
                      let parts = Stdlib.String.split errorOutput "Expected pattern '"
                      if Stdlib.List.length parts >= 2L then
                        let afterPattern = Stdlib.List.getAt parts 1L
                        match afterPattern with
                        | Some patternPart ->
                          let patternEnd = Stdlib.String.split patternPart "' not found"
                          let pattern = Stdlib.List.getAt patternEnd 0L
                          match pattern with
                          | Some p -> $"Expected pattern '{p}' was not found"
                          | None -> "Pattern matching failed"
                        | None -> "Pattern matching failed"
                      else
                        "Pattern matching failed"
                    else if Stdlib.String.contains errorOutput "EOF" then
                      "CLI process ended unexpectedly"
                    else
                      "Interactive test failed"

                  TestUtils.printlnColored CliColors.red $"âœ— FAIL - {interactiveTest.name}"
                  TestUtils.printlnColored CliColors.red specificError
                  TestResult.Failure $"Interactive test {interactiveTest.name} failed - {specificError}"


        let runCliTest (config: CliTest): TestResult =
          if config.isInteractive then
            match config.interactiveTest with
            | Some interactiveTest -> InteractiveTestRunner.runInteractiveTest interactiveTest
            | None -> TestResult.Failure "Interactive test configuration missing"
          else
            let expectedFile = TestConfig.getExpectedFilePath config.expectedOutputFile
            let actualFile = TestConfig.getActualFilePath config.name
            let command = TestConfig.buildCliCommand config.arguments

            match createDirectories() with
            | Error e -> TestResult.Failure $"Failed to create directories: {e}"
            | Ok _ ->
              match runCliCommand command actualFile with
              | Error e ->
                TestUtils.printlnColored CliColors.red "âœ— CLI command failed"
                Builtin.printLine "CLI output:"
                match TestUtils.getFileContent actualFile with
                | Ok content when Stdlib.Bool.not (Stdlib.String.isEmpty content) ->
                  Builtin.printLine content
                | _ ->
                  Builtin.printLine "No output captured"
                TestResult.Failure $"CLI command failed: {e}"
              | Ok _ ->
                if Stdlib.Bool.not (isFileEmpty actualFile) then
                  TestUtils.printlnColored CliColors.red "âœ— Output file is empty."
                  TestResult.Failure "Output file is empty"
                else
                  if Stdlib.Bool.not (TestUtils.fileExists expectedFile) then
                    TestUtils.printlnColored CliColors.yellow $"âš  Expected output file not found: {expectedFile}"
                    TestUtils.printlnColored CliColors.yellow "â„¹ Creating it with current output for future comparisons"
                    match copyFile actualFile expectedFile with
                    | Ok _ ->
                      TestUtils.printlnColored CliColors.green "âœ“ Test setup complete. Expected output saved."
                      Builtin.printLine ""
                      TestResult.SetupComplete "Expected output file created"
                    | Error e ->
                      TestResult.Failure $"Failed to create expected file: {e}"
                  else
                    if filesAreEqual expectedFile actualFile then
                      TestUtils.deleteFile actualFile
                      TestResult.Success $"{config.name} output matches expected"
                    else
                      TestUtils.printlnColored CliColors.red $"âœ— FAIL - {config.name} output differs from expected"
                      Builtin.printLine ""
                      TestUtils.printlnColored CliColors.blue "ðŸ“„ Detailed diff:"
                      Builtin.printLine "-----------------"
                      TestUtils.printlnColored CliColors.yellow "Expected vs Actual:"
                      let diffOutput = generateDiff expectedFile actualFile
                      Builtin.printLine diffOutput
                      Builtin.printLine ""
                      TestUtils.printMessageWithBorder
                        "Tip: If the new output is correct, update expected with:"
                        $"cp \"{actualFile}\" \"{expectedFile}\""
                      Builtin.printLine ""
                      TestResult.Failure $"{config.name} output differs from expected"


        let getRecordCommand (config: CliTest): String =
          if config.isInteractive then
            "./scripts/run-cli"
          else
            TestConfig.buildCliCommand config.arguments

        let getInteractiveSteps (config: CliTest): List<InteractiveStep> =
          if config.isInteractive then
            match config.interactiveTest with
            | Some test -> test.steps
            | None -> []
          else
            []

        let testResultToExitCode (result: TestResult): Int64 =
          match result with
          | Success _ -> 0L
          | SetupComplete _ -> 0L
          | Failure _ -> 1L
