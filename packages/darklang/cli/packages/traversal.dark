module Darklang.Cli.Packages.Traversal

// Path segment type for navigation
type PathSegment =
  | Root           // Go to root (/)
  | Here           // Stay here (.)
  | Up             // Go up one level (..)
  | Into of String // Go into a named entity/module

let parsePath (pathStr: String) : List<PathSegment> =
  if pathStr == "/" then
    [PathSegment.Root]
  else
    // Check if path ends with a dot - this means user wants to complete within that location
    let endsWithDot = Stdlib.String.endsWith pathStr "."

    // Split on / first, then handle each part separately
    let parts =
      pathStr
      |> Stdlib.String.split "/"
      |> Stdlib.List.map (fun part ->
        // Don't split ".." on dots - it's a special case
        if part == ".." then
          [part]
        else
          Stdlib.String.split part "."
      )
      |> Stdlib.List.flatten
      |> Stdlib.List.filter (fun p -> Stdlib.Bool.not (Stdlib.String.isEmpty p))

    // If path ended with dot, add empty string to indicate completion at that level
    let finalParts = if endsWithDot then Stdlib.List.append parts [""] else parts

    let segments =
      finalParts
      |> Stdlib.List.map (fun part ->
        match part with
        | "." -> PathSegment.Here
        | ".." -> PathSegment.Up
        | name -> PathSegment.Into name
      )

    if Stdlib.String.startsWith pathStr "/" then
      // Absolute path from root
      Stdlib.List.append [PathSegment.Root] segments
    else
      segments


let getCurrentModulePath (location: PackageLocation) : List<String> =
  match location with
  | Module path -> path
  | Type t -> Stdlib.List.append [t.owner] t.modules
  | Value v -> Stdlib.List.append [v.owner] v.modules
  | Function f -> Stdlib.List.append [f.owner] f.modules


let applySegment
  (branchID: Stdlib.Option.Option<Uuid>)
  (location: PackageLocation)
  (segment: PathSegment)
  : Stdlib.Result.Result<PackageLocation, String> =
  match segment with
  | Root ->
    Stdlib.Result.Result.Ok (PackageLocation.Module [])

  | Here ->
    Stdlib.Result.Result.Ok location

  | Up ->
    match location with
    | Module [] ->
      Stdlib.Result.Result.Error "Already at root - cannot go to parent"
    | Module modules ->
      let newModules = Stdlib.List.dropLast modules
      Stdlib.Result.Result.Ok (PackageLocation.Module newModules)
    | Type name ->
      let parentModules = Stdlib.List.append [name.owner] name.modules
      Stdlib.Result.Result.Ok (PackageLocation.Module parentModules)
    | Value name ->
      let parentModules = Stdlib.List.append [name.owner] name.modules
      Stdlib.Result.Result.Ok (PackageLocation.Module parentModules)
    | Function name ->
      let parentModules = Stdlib.List.append [name.owner] name.modules
      Stdlib.Result.Result.Ok (PackageLocation.Module parentModules)

  | Into name ->
    let currentPath = getCurrentModulePath location
    resolveEntity branchID currentPath name


// Resolve a name to an actual entity (module, type, fn, or value)
let resolveEntity
  (branchID: Stdlib.Option.Option<Uuid>)
  (basePath: List<String>)
  (name: String)
  : Stdlib.Result.Result<PackageLocation, String> =
  // First see if it's a module
  let modulePath = Stdlib.List.append basePath [name]
  let moduleResults = Query.searchContents branchID modulePath

  let isAModule = Query.hasContent moduleResults

  if isAModule then
    Stdlib.Result.Result.Ok (PackageLocation.Module modulePath)
  // Not a module -- check if it's a type/value/fn
  else
    let entityResults = Query.searchEntity branchID basePath name

    // Access lists directly to avoid type parameter loss
    match entityResults.types with
    | item :: _ -> Stdlib.Result.Result.Ok (PackageLocation.Type item.location)
    | [] ->
      match entityResults.fns with
      | item :: _ -> Stdlib.Result.Result.Ok (PackageLocation.Function item.location)
      | [] ->
        match entityResults.values with
        | item :: _ -> Stdlib.Result.Result.Ok (PackageLocation.Value item.location)
        | [] -> Stdlib.Result.Result.Error "Not found"


let applyPath
  (branchID: Stdlib.Option.Option<Uuid>)
  (start: PackageLocation)
  (segments: List<PathSegment>)
  : Stdlib.Result.Result<PackageLocation, String> =
  segments
  |> Stdlib.List.fold (Stdlib.Result.Result.Ok start) (fun accResult segment ->
    match accResult with
    | Error e -> Stdlib.Result.Result.Error e
    | Ok loc -> applySegment branchID loc segment
  )


// Search for module names under Darklang owner (fallback search)
let searchDarklangModules
  (branchID: Stdlib.Option.Option<Uuid>)
  (prefixText: String)
  : List<String> =
  let darklangResults = Query.searchContents branchID ["Darklang"]
  let currentPathLength = 1L
  let moduleNames = Query.getDirectSubmodules darklangResults currentPathLength

  moduleNames
  |> Stdlib.List.filter (fun name -> Stdlib.String.startsWith name prefixText)
  |> Stdlib.List.map (fun name -> "Darklang." ++ name) // Return fully qualified names

// Get all available names at a location for completion
let getAvailableNames
  (branchID: Stdlib.Option.Option<Uuid>)
  (location: PackageLocation)
  (prefixText: String)
  : List<String> =
  let currentPath = getCurrentModulePath location
  // Get all available entities in this module
  let allResults = Query.searchContents branchID currentPath

  let currentPathLength = Stdlib.List.length currentPath
  let moduleNames = Query.getDirectSubmodules allResults currentPathLength
  let typeNames = allResults.types |> Stdlib.List.map (fun item -> item.location.name)
  let fnNames = allResults.fns |> Stdlib.List.map (fun item -> item.location.name)
  let valueNames = allResults.values |> Stdlib.List.map (fun item -> item.location.name)

  let allNames =
    moduleNames
    |> Stdlib.List.append typeNames
    |> Stdlib.List.append fnNames
    |> Stdlib.List.append valueNames
    |> Stdlib.List.unique
    |> Stdlib.List.sort

  // Primary results: filter by prefix if we have search text
  let primaryResults =
    if Stdlib.String.isEmpty prefixText then
      allNames
    else
      allNames |> Stdlib.List.filter (fun name -> Stdlib.String.startsWith name prefixText)

  // At root level: prioritize owners, then add fallback
  match location with
  | Module [] when Stdlib.Bool.not (Stdlib.String.isEmpty prefixText) ->
    let ownerMatches = primaryResults |> Stdlib.List.filter (fun result -> Stdlib.Bool.not (Stdlib.String.contains result "."))

    if Stdlib.Bool.not (Stdlib.List.isEmpty ownerMatches) then
      ownerMatches
    else
      let fallbackResults = searchDarklangModules branchID prefixText
      primaryResults |> Stdlib.List.append fallbackResults |> Stdlib.List.unique |> Stdlib.List.sort
  | _ ->
    primaryResults

// Simple completion: traverse exact path, then fuzzy search the last part
let completePartialPath
  (branchID: Stdlib.Option.Option<Uuid>)
  (start: PackageLocation)
  (partialPath: String)
  : List<String> =
  let segments = parsePath partialPath


  match Stdlib.List.reverse segments with
  | [] ->
    // Empty path - get completions from current location
    getAvailableNames branchID start ""

  | (Into fuzzyPart) :: exactSegmentsReversed ->
    // Navigate to exact path, then fuzzy search
    let exactSegments = Stdlib.List.reverse exactSegmentsReversed
    match applyPath branchID start exactSegments with
    | Error _ -> []
    | Ok contextLocation ->
      let completionNames = getAvailableNames branchID contextLocation fuzzyPart

      // Build prefix for the completions, preserving the separator style
      let prefix =
        if Stdlib.List.isEmpty exactSegments then
          ""
        else
          // Check if original path uses / separator
          let usesSlash = Stdlib.String.contains partialPath "/"
          let separator = if usesSlash then "/" else "."

          let pathStr =
            exactSegments
            |> Stdlib.List.map (fun segment ->
              match segment with
              | Root -> ""
              | Here -> "."
              | Up -> ".."
              | Into name -> name
            )
            |> Stdlib.List.filter (fun s -> Stdlib.Bool.not (Stdlib.String.isEmpty s))
            |> Stdlib.String.join separator
          pathStr ++ separator

      completionNames |> Stdlib.List.map (fun name -> prefix ++ name)

  | _ ->
    // Last segment is Root, Here, or Up - no fuzzy completion
    []


// Main traverse function
let traverse
  (branchID: Stdlib.Option.Option<Uuid>)
  (start: PackageLocation)
  (path: String)
  : Stdlib.Result.Result<PackageLocation, String> =
  let segments = parsePath path
  applyPath branchID start segments
