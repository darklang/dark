module Darklang.Cli.Packages.Traversal

// Path segment type for navigation
type PathSegment =
  | Root           // Go to root (/)
  | Here           // Stay here (.)
  | Up             // Go up one level (..)
  | Into of String // Go into a named entity/module

let parsePath (pathStr: String) : List<PathSegment> =
  if pathStr == "/" then
    [PathSegment.Root]
  else
    // Check if path ends with a dot - this means user wants to complete within that location
    let endsWithDot =
      (Stdlib.String.endsWith pathStr ".") && Stdlib.Bool.not (Stdlib.String.endsWith pathStr "..")

    // Split on / first, then handle each part separately
    let parts =
      pathStr
      |> Stdlib.String.split "/"
      |> Stdlib.List.map (fun part ->
        // Don't split ".." on dots - it's a special case
        if part == ".." then
          [part]
        else
          Stdlib.String.split part "."
      )
      |> Stdlib.List.flatten
      |> Stdlib.List.filter (fun p -> Stdlib.Bool.not (Stdlib.String.isEmpty p))

    // If path ended with dot, add empty string to indicate completion at that level
    let finalParts = if endsWithDot then Stdlib.List.append parts [""] else parts

    let segments =
      finalParts
      |> Stdlib.List.map (fun part ->
        match part with
        | "." -> PathSegment.Here
        | ".." -> PathSegment.Up
        | name -> PathSegment.Into name
      )

    if Stdlib.String.startsWith pathStr "/" then
      // Absolute path from root
      Stdlib.List.append [PathSegment.Root] segments
    else
      segments


let getCurrentModulePath (location: PackageLocation) : List<String> =
  match location with
  | Module path -> path
  | Type t -> Stdlib.List.append [t.owner] t.modules
  | Value v -> Stdlib.List.append [v.owner] v.modules
  | Function f -> Stdlib.List.append [f.owner] f.modules


let applySegment
  (location: PackageLocation)
  (segment: PathSegment)
  : Stdlib.Result.Result<PackageLocation, String> =
  match segment with
  | Root ->
    Stdlib.Result.Result.Ok (PackageLocation.Module [])

  | Here ->
    Stdlib.Result.Result.Ok location

  | Up ->
    match location with
    | Module [] ->
      Stdlib.Result.Result.Error "Already at root - cannot go to parent"
    | Module modules ->
      let newModules = Stdlib.List.dropLast modules
      Stdlib.Result.Result.Ok (PackageLocation.Module newModules)
    | Type name ->
      let parentModules = Stdlib.List.append [name.owner] name.modules
      Stdlib.Result.Result.Ok (PackageLocation.Module parentModules)
    | Value name ->
      let parentModules = Stdlib.List.append [name.owner] name.modules
      Stdlib.Result.Result.Ok (PackageLocation.Module parentModules)
    | Function name ->
      let parentModules = Stdlib.List.append [name.owner] name.modules
      Stdlib.Result.Result.Ok (PackageLocation.Module parentModules)

  | Into name ->
    let currentPath = getCurrentModulePath location
    resolveEntity currentPath name


// Resolve a name to an actual entity (module, type, fn, or value)
let resolveEntity
  (basePath: List<String>)
  (name: String)
  : Stdlib.Result.Result<PackageLocation, String> =
  // First see if it's a module
  let modulePath = Stdlib.List.append basePath [name]
  let moduleResults = Query.allDirectDescendants modulePath

  let isAModule = Query.hasContent moduleResults

  if isAModule then
    Stdlib.Result.Result.Ok (PackageLocation.Module modulePath)
  // Not a module -- check if it's a type/value/fn
  else
    let entityResults = Query.searchExactMatch basePath name

    // Access lists directly to avoid type parameter loss
    match entityResults.types with
    | item :: _ -> Stdlib.Result.Result.Ok (PackageLocation.Type item.location)
    | [] ->
      match entityResults.fns with
      | item :: _ -> Stdlib.Result.Result.Ok (PackageLocation.Function item.location)
      | [] ->
        match entityResults.values with
        | item :: _ -> Stdlib.Result.Result.Ok (PackageLocation.Value item.location)
        | [] -> Stdlib.Result.Result.Error "Not found"


let applyPath
  (start: PackageLocation)
  (segments: List<PathSegment>)
  : Stdlib.Result.Result<PackageLocation, String> =
  segments
  |> Stdlib.List.fold (Stdlib.Result.Result.Ok start) (fun accResult segment ->
    match accResult with
    | Error e -> Stdlib.Result.Result.Error e
    | Ok loc -> applySegment loc segment
  )


// Search for modules globally where a segment starts with the prefix
// Returns only the path up to the matching segment, not descendants
let searchModulesByPrefix
  (prefixText: String)
  : List<String> =
  // Search from root with AllDescendants - database returns all matching paths
  let query =
    LanguageTools.ProgramTypes.Search.SearchQuery
      { currentModule = []
        text = prefixText
        searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.AllDescendants
        entityTypes = []
        exactMatch = false }

  let results = LanguageTools.PackageManager.Search.search query

  // For each result, find the first segment starting with prefix and truncate there
  results.submodules
  |> Stdlib.List.filterMap (fun modulePath ->
    // Find index of first segment starting with prefix
    let indexed = Stdlib.List.indexedMap modulePath (fun idx seg -> (idx, seg))
    let found = Stdlib.List.findFirst indexed (fun pair ->
      let (_, seg) = pair
      Stdlib.String.startsWith seg prefixText)

    match found with
    | Some pair ->
      let (idx, _) = pair
      // Return path up to and including the matching segment
      Stdlib.Option.Option.Some (Stdlib.List.take modulePath (idx + 1L))
    | None -> Stdlib.Option.Option.None)
  |> Stdlib.List.unique
  |> Stdlib.List.map (fun path -> Stdlib.String.join path ".")

// Get all available items at a location for completion
let getAvailableItems
  (location: PackageLocation)
  (prefixText: String)
  : List<Cli.Completion.CompletionItem> =
  let currentPath = getCurrentModulePath location
  // Get all available entities in this module
  let allResults = Query.allDirectDescendants currentPath

  let currentPathLength = Stdlib.List.length currentPath

  let moduleItems =
    (Query.getDirectSubmodules allResults currentPathLength)
    |> Stdlib.List.map (fun name -> Cli.Completion.withIcon EntityType.Module name)

  let typeItems =
    allResults.types
    |> Stdlib.List.map (fun item -> Cli.Completion.withIcon EntityType.Type item.location.name)

  let fnItems =
    allResults.fns
    |> Stdlib.List.map (fun item -> Cli.Completion.withIcon EntityType.Function item.location.name)

  let valueItems =
    allResults.values
    |> Stdlib.List.map (fun item -> Cli.Completion.withIcon EntityType.Value item.location.name)

  let flatItems = Stdlib.List.flatten [moduleItems; typeItems; fnItems; valueItems]
  let allItems = flatItems |> Stdlib.List.sortBy (fun item -> item.value)

  // Primary results: filter by prefix if we have search text
  let primaryResults =
    if Stdlib.String.isEmpty prefixText then
      allItems
    else
      allItems |> Stdlib.List.filter (fun item -> Stdlib.String.startsWith item.value prefixText)

  // At root level: prioritize owners, then add fallback
  match location with
  | Module [] when Stdlib.Bool.not (Stdlib.String.isEmpty prefixText) ->
    let ownerMatches =
      primaryResults
      |> Stdlib.List.filter (fun item -> Stdlib.Bool.not (Stdlib.String.contains item.value "."))

    if Stdlib.Bool.not (Stdlib.List.isEmpty ownerMatches) then
      ownerMatches
    else
      let fallbackResults =
        (searchModulesByPrefix prefixText)
        |> Stdlib.List.map (fun name -> Cli.Completion.withIcon EntityType.Module name)

      let combined = Stdlib.List.append primaryResults fallbackResults
      combined |> Stdlib.List.sortBy (fun item -> item.value)
  | _ ->
    primaryResults

// Simple completion: traverse exact path, then fuzzy search the last part
let completePartialPath
  (start: PackageLocation)
  (partialPath: String)
  : List<Cli.Completion.CompletionItem> =
  let segments = parsePath partialPath

  match Stdlib.List.reverse segments with
  | [] ->
    // Empty path - get completions from current location
    getAvailableItems start ""

  | (Into fuzzyPart) :: exactSegmentsReversed ->
    // Navigate to exact path, then fuzzy search
    let exactSegments = Stdlib.List.reverse exactSegmentsReversed
    match applyPath start exactSegments with
    | Error _ -> []
    | Ok contextLocation ->
      let completionItems = getAvailableItems contextLocation fuzzyPart

      // Build prefix for the completions, preserving the separator style
      let prefix =
        if Stdlib.List.isEmpty exactSegments then
          ""
        else
          // Check if original path uses / separator
          let usesSlash = Stdlib.String.contains partialPath "/"
          let separator = if usesSlash then "/" else "."

          let pathStr =
            exactSegments
            |> Stdlib.List.map (fun segment ->
              match segment with
              | Root -> ""
              | Here -> "."
              | Up -> ".."
              | Into name -> name
            )
            |> Stdlib.List.filter (fun s -> Stdlib.Bool.not (Stdlib.String.isEmpty s))
            |> Stdlib.String.join separator
          pathStr ++ separator

      // Add prefix to both display and value
      completionItems
      |> Stdlib.List.map (fun item ->
        Cli.Completion.CompletionItem
          { display = item.display
            value = prefix ++ item.value })

  | _ ->
    // Last segment is Root, Here, or Up - no fuzzy completion
    []


// Main traverse function
let traverse
  (start: PackageLocation)
  (path: String)
  : Stdlib.Result.Result<PackageLocation, String> =
  let segments = parsePath path
  applyPath start segments
