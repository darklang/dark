module Darklang.Cli.Packages.Create.Type

/// Create a type by opening $EDITOR
/// Example: createType "User" when in Darklang.Foo -> opens editor for Darklang.Foo.User
let createType
  (currentLocation: Packages.PackageLocation)
  (locationStr: String)
  : Cli.AppState -> Cli.AppState =
  fun state ->
    // Parse location relative to current position
    let parsedLocation = Location.parseRelativeTo currentLocation locationStr

    match parsedLocation with
    | Error msg ->
      Stdlib.printLine (Colors.error $"Invalid location: {msg}")
      state

    | Ok loc ->
      let fullPath =
        [ [ loc.owner ]; loc.modules; [ loc.name ] ]
        |> Stdlib.List.flatten
        |> Stdlib.String.join "."

      Stdlib.printLine ""
      Stdlib.printLine (Colors.boldText "Creating type:")
      Stdlib.printLine $"  Location: {fullPath}"
      Stdlib.printLine ""
      Stdlib.printLine (Colors.dimText "TODO: Open $EDITOR with type template")
      Stdlib.printLine ""

      // Flow would be:
      // 1. Generate template:
      //    type <Name> =
      //      | CaseOne
      //      | CaseTwo of String
      // 2. Write to temp file
      // 3. Open in $EDITOR (via Builtin.cliFileEdit or similar)
      // 4. User edits and saves
      // 5. Parse file to WrittenTypes.TypeDeclaration
      // 6. Convert to ProgramTypes.PackageType
      // 7. Create ops: [AddType(pt), SetTypeName(pt.id, location)]
      // 8. Ask for confirmation: "Create type Darklang.Foo.Bar? [y/n]"
      // 9. If yes: Call Darklang.SCM.PackageOps.commitToCurrent ops
      // 10. Show success message

      state


let execute (state: Cli.AppState) (args: List<String>) : Cli.AppState =
  match args with
  | [ location ] -> createType state.packageData.currentLocation location state

  | _ -> help state


let help (state: Cli.AppState) : Cli.AppState =
  Stdlib.printLine "Create a new type"
  Stdlib.printLine ""
  Stdlib.printLine "Usage: dark type <location>"
  Stdlib.printLine ""
  Stdlib.printLine "Opens $EDITOR with a type template"
  Stdlib.printLine ""
  Stdlib.printLine "Examples:"
  Stdlib.printLine "  # Absolute path:"
  Stdlib.printLine "  dark type /Darklang.Foo.User"
  Stdlib.printLine ""
  Stdlib.printLine "  # Relative path (if you're in Darklang.Foo):"
  Stdlib.printLine "  dark type User"
  Stdlib.printLine "  dark type Models.User"
  Stdlib.printLine ""
  state


let complete (state: Cli.AppState) (args: List<String>) : List<String> = []
