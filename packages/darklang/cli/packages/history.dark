module Darklang.Cli.Packages.History


let execute (state: Cli.AppState) (args: List<String>) : Cli.AppState =
  match args with
  | [location] ->
    // Parse location
    let parts = Stdlib.String.split location "."

    match parts with
    | [] ->
      Stdlib.printLine (Colors.error "Empty location")
      state

    | [_] ->
      Stdlib.printLine (Colors.error "Location must have at least owner and name")
      state

    | owner :: rest ->
      let name = (Stdlib.List.last rest) |> Builtin.unwrap
      let modules = Stdlib.List.dropLast rest

      // Get history for all item types and combine
      let fnHistory = Darklang.SCM.History.getNameHistory owner modules name "fn"
      let typeHistory = Darklang.SCM.History.getNameHistory owner modules name "type"
      let valueHistory = Darklang.SCM.History.getNameHistory owner modules name "value"

      let allHistory =
        (Stdlib.List.append fnHistory typeHistory)
        |> Stdlib.List.append valueHistory
        |> Stdlib.List.sortBy (fun entry -> entry.timestamp)

      match allHistory with
      | [] ->
        Stdlib.printLine $"No history found for {location}"
        state

      | entries ->
        Stdlib.printLine ""
        Stdlib.printLine (Colors.boldText $"History for {location}:")
        Stdlib.printLine ""

        entries
        |> Stdlib.List.iter (fun entry ->
          let timestampStr = Stdlib.DateTime.toString entry.timestamp

          let branchStr =
            match entry.branchId with
            | Some id ->
              let idShort = Stdlib.String.slice id 0L 8L
              $"branch {idShort}..."
            | None -> "main"

          let idShort = Stdlib.String.slice entry.itemId 0L 8L

          Stdlib.printLine
            $"  {timestampStr} | {branchStr} | {entry.opType} -> {idShort}...")

        Stdlib.printLine ""
        state

  | _ -> help state


let help (state: Cli.AppState) : Cli.AppState =
  [
    "View history of what a name pointed to"
    ""
    "Usage: history <location>"
    "Example: history Darklang.Stdlib.List.map"
    ""
    "Shows all times the name was pointed to different items"
    ""
  ] |> Stdlib.printLines

  state

let complete (state: Cli.AppState) (args: List<String>) : List<String> =
  match args with
  | [] ->
    Packages.Traversal.completePartialPath
      state.currentBranchId
      state.packageData.currentLocation
      ""
  | [partialPath] ->
    Packages.Traversal.completePartialPath
      state.currentBranchId
      state.packageData.currentLocation
      partialPath
  | _ -> []
