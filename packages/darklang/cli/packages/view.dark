module Darklang.Cli.Packages.View

let viewEntity (location: PackageLocation) : Unit =
  match location with
  | Module path ->
    // Display module contents (similar to list but with more detail)
    let results = Query.allDirectDescendants path

    let locationStr = Packages.formatLocation location
    Stdlib.printLine locationStr
    Stdlib.printLine (Stdlib.String.repeat "=" (Stdlib.String.length locationStr))
    Stdlib.printLine ""

    // Display submodules
    let currentPathLength = Stdlib.List.length path
    let directSubmodules = Query.getDirectSubmodules results currentPathLength

    // Display in order: modules, types, values, functions
    if Stdlib.Bool.not (Stdlib.List.isEmpty directSubmodules) then
      Stdlib.printLine (Display.getSectionHeader "submodule")
      directSubmodules
      |> Stdlib.List.iter (fun name -> Stdlib.printLine $"  {name}/")
      Stdlib.printLine ""

    // Display types
    if Stdlib.Bool.not (Stdlib.List.isEmpty results.types) then
      Stdlib.printLine (Display.getSectionHeader "type")
      results.types
      |> Stdlib.List.iter (fun item ->
        Stdlib.printLine $"  {item.location.name}")
      Stdlib.printLine ""

    // Display values
    if Stdlib.Bool.not (Stdlib.List.isEmpty results.values) then
      Stdlib.printLine (Display.getSectionHeader "value")
      results.values
      |> Stdlib.List.iter (fun item ->
        Stdlib.printLine $"  {item.location.name}")
      Stdlib.printLine ""

    // Display functions
    if Stdlib.Bool.not (Stdlib.List.isEmpty results.fns) then
      Stdlib.printLine (Display.getSectionHeader "function")
      results.fns
      |> Stdlib.List.iter (fun item ->
        Stdlib.printLine $"  {item.location.name}")
      Stdlib.printLine ""

  | Type name ->
    // Find and display the specific type
    let modulePath = Stdlib.List.append [name.owner] name.modules
    let results = Query.searchExactMatch modulePath name.name

    // Access the first type directly from results.types
    match results.types with
    | [] ->
      let locationStr = Packages.formatLocation location
      Stdlib.printLine $"Type '{locationStr}' not found."
    | item :: _ ->
      let prettyPrinted = PrettyPrinter.ProgramTypes.packageType item.entity
      let highlighted = SyntaxHighlighting.highlightCode prettyPrinted
      Stdlib.printLine highlighted

  | Function name ->
    // Find and display the specific function
    let modulePath = Stdlib.List.append [name.owner] name.modules
    let results = Query.searchExactMatch modulePath name.name

    // Access the first function directly from results.fns
    match results.fns with
    | [] ->
      let locationStr = Packages.formatLocation location
      Stdlib.printLine $"Function '{locationStr}' not found."
    | item :: _ ->
      let ctx = PrettyPrinter.ProgramTypes.defaultContext
      let prettyPrinted = PrettyPrinter.ProgramTypes.packageFn ctx item.entity
      let highlighted = SyntaxHighlighting.highlightCode prettyPrinted
      Stdlib.printLine highlighted

  | Value name ->
    // Find and display the specific value
    let modulePath = Stdlib.List.append [name.owner] name.modules
    let results = Query.searchExactMatch modulePath name.name

    // Access the first value directly from results.values
    match results.values with
    | [] ->
      let locationStr = Packages.formatLocation location
      Stdlib.printLine $"Value '{locationStr}' not found."
    | item :: _ ->
      let ctx = PrettyPrinter.ProgramTypes.defaultContext
      let prettyPrinted = PrettyPrinter.ProgramTypes.packageValue ctx item.entity
      let highlighted = SyntaxHighlighting.highlightCode prettyPrinted
      Stdlib.printLine highlighted


// VIEW command - view modules, functions, types, or constants
let execute (state: AppState) (args: List<String>) : AppState =
  match args with
  | [] ->
    // No args - view current location
    viewEntity state.packageData.currentLocation
    state
  | [pathArg] ->
    // Navigate to the path and view
    match Traversal.traverse state.packageData.currentLocation pathArg with
    | Error errorMsg ->
      Stdlib.printLine (Colors.error $"Cannot view: {errorMsg}")
      state
    | Ok newLocation ->
      viewEntity newLocation
      state
  | _ ->
    help state
    state

let complete (state: AppState) (args: List<String>) : List<Completion.CompletionItem> =
  match args with
  | [] ->
    Traversal.completePartialPath state.packageData.currentLocation ""
  | [partialPath] ->
    Traversal.completePartialPath state.packageData.currentLocation partialPath
  | _ -> []


let help (_state: AppState) : Unit =
  [
    "Usage: view [path]"
    "View detailed information about functions, types, values, or modules."
    ""
    "With path: View the specified entity with syntax highlighting."
    "Without path: View current location."
    ""
    "Examples:"
    "  view                    - View current location"
    "  view List.head          - View the List.head function"
    "  view Option             - View the Option type"
    "  view Stdlib.List        - View contents of Stdlib.List module"
  ] |> Stdlib.printLines
