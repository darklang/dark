module Darklang.Cli.Packages.Branch

let displayBranchInfo (branch: SCM.Branch.Branch) : Unit =
  let mergedAtText =
    match branch.mergedAt with
    | Some dt -> Stdlib.DateTime.toString dt
    | None -> "(not merged)"

  [ ""
    (Colors.boldText "Branch Information:")
    ""
    $"  ID:             {Stdlib.Uuid.toString branch.id}"
    $"  Name:           {branch.name}"
    $"  Created at:     {Stdlib.DateTime.toString branch.createdAt}"
    $"  Merged at:      {mergedAtText}"
    "" ]
  |> Stdlib.printLines


let execute (state: Cli.AppState) (args: List<String>) : Cli.AppState =
  match args with
  | [] -> help state

  | ["list"] ->
    let branches = Darklang.SCM.Branch.list ()
    Stdlib.printLine ""
    Stdlib.printLine (Colors.boldText "Branches:")

    branches
    |> Stdlib.List.iter (fun b ->
      let marker =
        match state.currentBranchId with
        | Some currentId -> if b.id == currentId then "* " else "  "
        | None -> "  "

      // Show creation date for disambiguation when there are name collisions
      let dateStr = Stdlib.DateTime.toString b.createdAt
      Stdlib.printLine $"{marker}{b.name} (created {dateStr})")

    Stdlib.printLine ""
    state

  | ["create"; name] ->
    let branch = Darklang.SCM.Branch.create name
    Stdlib.printLine $"Created and switched to branch: {name}"

    { state with
        currentBranchId = Stdlib.Option.Option.Some branch.id
        needsFullRedraw = true }

  | ["switch"; name] ->
    let branches = Darklang.SCM.Branch.findByName name

    match branches with
    | [] ->
      Stdlib.printLine (Colors.error $"Branch not found: {name}")
      state

    | [branch] ->
      Stdlib.printLine $"Switched to branch: {name}"

      { state with
          currentBranchId = Stdlib.Option.Option.Some branch.id
          needsFullRedraw = true }

    | multipleBranches ->
      // Name collision - show options
      [ (Colors.error $"Multiple branches found with name '{name}':")
        "" ]
      |> Stdlib.printLines

      multipleBranches
      |> Stdlib.List.iter (fun b ->
        let dateStr = Stdlib.DateTime.toString b.createdAt
        let idShort = Stdlib.String.slice (Stdlib.Uuid.toString b.id) 0L 8L
        Stdlib.printLine $"  {b.name} (id: {idShort}..., created {dateStr})")

      [ ""
        "Please use 'branch switch-id <branch-id>' to switch" ]
      |> Stdlib.printLines

      state

  | ["switch-id"; branchIdStr] ->
    match Stdlib.Uuid.parse branchIdStr with
    | Ok branchID ->
      let branch = Darklang.SCM.Branch.get branchID

      match branch with
      | Some b ->
        Stdlib.printLine $"Switched to branch: {b.name}"

        { state with
            currentBranchId = Stdlib.Option.Option.Some b.id
            needsFullRedraw = true }

      | None ->
        Stdlib.printLine (Colors.error $"Branch not found: {branchIdStr}")
        state

    | Error _ ->
      Stdlib.printLine (Colors.error $"Invalid branch ID: {branchIdStr}")
      state

  | ["status"] ->
    let currentBranch =
      match state.currentBranchId with
      | Some branchID -> Darklang.SCM.Branch.get branchID
      | None -> Stdlib.Option.Option.None

    match currentBranch with
    | Some branch ->
      [ ""
        $"Branch: {branch.name}"
        $"ID: {Stdlib.Uuid.toString branch.id}"
        "" ]
      |> Stdlib.printLines

    | None -> Stdlib.printLine (Colors.error "Not currently on a branch. Use 'branch switch <name>' to switch to one, or 'branch list' to see available branches.")

    state

  | ["info"] ->
    let currentBranch =
      match state.currentBranchId with
      | Some branchID -> Darklang.SCM.Branch.get branchID
      | None -> Stdlib.Option.Option.None

    match currentBranch with
    | Some branch ->
      displayBranchInfo branch
      state

    | None ->
      Stdlib.printLine (Colors.error "Not currently on a branch. Use 'branch switch <name>' to switch to one, or 'branch list' to see available branches.")
      state

  | ["info"; name] ->
    let branches = Darklang.SCM.Branch.findByName name

    match branches with
    | [] ->
      Stdlib.printLine (Colors.error $"Branch not found: {name}")
      state

    | [branch] ->
      displayBranchInfo branch
      state

    | multipleBranches ->
      // Multiple branches with same name
      [ (Colors.error $"Multiple branches found with name '{name}':")
        "" ]
      |> Stdlib.printLines

      multipleBranches
      |> Stdlib.List.iter (fun b ->
        let dateStr = Stdlib.DateTime.toString b.createdAt
        let idShort = Stdlib.String.slice (Stdlib.Uuid.toString b.id) 0L 8L
        Stdlib.printLine $"  {b.name} (id: {idShort}..., created {dateStr})")

      Stdlib.printLine ""
      state

  | ["clear"]
  | ["unset"]
  | ["none"] ->
    Stdlib.printLine "Cleared current branch (now searching all packages)"

    { state with
        currentBranchId = Stdlib.Option.Option.None
        needsFullRedraw = true }

  | _ ->
    Stdlib.printLine (Colors.error "Unknown branch command")
    help state


let help (state: Cli.AppState) : Cli.AppState =
  let lines =
    [ "Branch Management Commands"
      ""
      "  branch list                   List all branches"
      "  branch create NAME            Create and switch to new branch"
      "  branch switch NAME            Switch to existing branch"
      "  branch switch-id ID           Switch to branch by ID"
      "  branch status                 Show current branch status"
      "  branch info                   Show detailed info (current branch)"
      "  branch info NAME              Show detailed info (specific branch)"
      "  branch [clear|unset|none]     Clear current branch (search all packages)"
      "" ]

  Stdlib.List.iter lines Stdlib.printLine
  state


let complete (state: Cli.AppState) (args: List<String>) : List<String> =
  match args with
  | [] -> [ "list"; "create"; "switch"; "switch-id"; "status"; "unset"; "none"; "clear" ]

  | [partial] ->
    [ "list"; "create"; "switch"; "switch-id"; "status"; "unset"; "none"; "clear" ]
    |> Stdlib.List.filter (fun cmd -> Stdlib.String.startsWith cmd partial)

  | ["switch"] ->
    let branches = Darklang.SCM.Branch.list ()
    Stdlib.List.map branches (fun b -> b.name)

  | ["switch"; partial] ->
    let branches = Darklang.SCM.Branch.list ()

    branches
    |> Stdlib.List.map (fun b -> b.name)
    |> Stdlib.List.filter (fun name -> Stdlib.String.startsWith name partial)

  | _ -> []
