module Darklang.Cli.Packages.Branch

let displayBranchInfo (branch: SCM.Branch.Branch) : Unit =
  Stdlib.printLine ""
  Stdlib.printLine (Colors.boldText "Branch Information:")
  Stdlib.printLine ""

  let stateText =
    match branch.state with
    | Active -> "active"
    | Merged -> "merged"
    | Abandoned -> "abandoned"

  Stdlib.printLine $"  ID:             {Stdlib.Uuid.toString branch.id}"

  let createdByText =
    match branch.createdBy with
    | Some uuid -> Stdlib.Uuid.toString uuid
    | None -> "(none)"

  Stdlib.printLine $"  Created by:     {createdByText}"
  Stdlib.printLine $"  Title:          {branch.title}"
  Stdlib.printLine $"  State:          {stateText}"
  Stdlib.printLine $"  Created at:     {Stdlib.DateTime.toString branch.createdAt}"
  Stdlib.printLine $"  Last active:    {Stdlib.DateTime.toString branch.lastActiveAt}"

  let mergedAtText =
    match branch.mergedAt with
    | Some dt -> Stdlib.DateTime.toString dt
    | None -> "(not merged)"

  Stdlib.printLine $"  Merged at:      {mergedAtText}"
  Stdlib.printLine ""


let execute (state: Cli.AppState) (args: List<String>) : Cli.AppState =
  let accountId = Darklang.SCM.Account.getCurrentId ()

  match args with
  | [] -> help state

  | ["list"] ->
    let branches = Darklang.SCM.Branch.list ()
    Stdlib.printLine ""
    Stdlib.printLine (Colors.boldText "Active Branches:")

    branches
    |> Stdlib.List.filter (fun b ->
      match b.state with
      | Active -> true
      | _ -> false)
    |> Stdlib.List.iter (fun b ->
      let marker =
        match state.currentBranchId with
        | Some currentId -> if b.id == currentId then "* " else "  "
        | None -> "  "

      // Show creation date for disambiguation when there are name collisions
      let dateStr = Stdlib.DateTime.toString b.createdAt
      Stdlib.printLine $"{marker}{b.title} (created {dateStr})")

    Stdlib.printLine ""
    state

  | ["create"; name] ->
    let branch = Darklang.SCM.Branch.create (Stdlib.Option.Option.Some accountId) name
    Darklang.SCM.Account.setCurrentBranch branch.id
    Stdlib.printLine $"Created and switched to branch: {name}"

    { state with
        currentBranchId = Stdlib.Option.Option.Some branch.id
        needsFullRedraw = true }

  | ["switch"; name] ->
    let branches = Darklang.SCM.Branch.findByTitle name

    match branches with
    | [] ->
      Stdlib.printLine (Colors.error $"Branch not found: {name}")
      state

    | [branch] ->
      Darklang.SCM.Branch.updateLastActive branch.id
      Darklang.SCM.Account.setCurrentBranch branch.id
      Stdlib.printLine $"Switched to branch: {name}"

      { state with
          currentBranchId = Stdlib.Option.Option.Some branch.id
          needsFullRedraw = true }

    | multipleBranches ->
      // Name collision - show options
      Stdlib.printLine (Colors.error $"Multiple branches found with name '{name}':")
      Stdlib.printLine ""

      multipleBranches
      |> Stdlib.List.iter (fun b ->
        let dateStr = Stdlib.DateTime.toString b.createdAt
        let idShort = Stdlib.String.slice b.id 0L 8L
        Stdlib.printLine $"  {b.title} (id: {idShort}..., created {dateStr})")

      Stdlib.printLine ""
      Stdlib.printLine "Please use 'dark branch switch-id <branch-id>' to switch"
      state

  | ["switch-id"; branchIdStr] ->
    match Stdlib.Uuid.parse branchIdStr with
    | Ok branchId ->
      let branch = Darklang.SCM.Branch.get branchId

      match branch with
      | Some b ->
        Darklang.SCM.Branch.updateLastActive b.id
        Darklang.SCM.Account.setCurrentBranch b.id
        Stdlib.printLine $"Switched to branch: {b.title}"

        { state with
            currentBranchId = Stdlib.Option.Option.Some b.id
            needsFullRedraw = true }

      | None ->
        Stdlib.printLine (Colors.error $"Branch not found: {branchIdStr}")
        state

    | Error _ ->
      Stdlib.printLine (Colors.error $"Invalid branch ID: {branchIdStr}")
      state

  | ["status"] ->
    let currentBranch =
      match state.currentBranchId with
      | Some branchId -> Darklang.SCM.Branch.get branchId
      | None -> Stdlib.Option.Option.None

    match currentBranch with
    | Some branch ->
      Stdlib.printLine ""

      let statusText =
        match branch.state with
        | Active -> "active"
        | Merged -> "merged"
        | Abandoned -> "abandoned"

      Stdlib.printLine $"Branch: {branch.title} ({statusText})"
      Stdlib.printLine $"ID: {Stdlib.Uuid.toString branch.id}"
      Stdlib.printLine $"Last active: {Stdlib.DateTime.toString branch.lastActiveAt}"
      Stdlib.printLine ""

    | None -> Stdlib.printLine (Colors.error "Current branch not found")

    state

  | ["info"] ->
    let currentBranch =
      match state.currentBranchId with
      | Some branchId -> Darklang.SCM.Branch.get branchId
      | None -> Stdlib.Option.Option.None

    match currentBranch with
    | Some branch ->
      displayBranchInfo branch
      state

    | None ->
      Stdlib.printLine (Colors.error "Current branch not found")
      state

  | ["info"; name] ->
    let branches = Darklang.SCM.Branch.findByTitle name

    match branches with
    | [] ->
      Stdlib.printLine (Colors.error $"Branch not found: {name}")
      state

    | [branch] ->
      displayBranchInfo branch
      state

    | multipleBranches ->
      // Multiple branches with same name
      Stdlib.printLine (Colors.error $"Multiple branches found with name '{name}':")
      Stdlib.printLine ""

      multipleBranches
      |> Stdlib.List.iter (fun b ->
        let dateStr = Stdlib.DateTime.toString b.createdAt
        let idShort = Stdlib.String.slice (Stdlib.Uuid.toString b.id) 0L 8L
        Stdlib.printLine $"  {b.title} (id: {idShort}..., created {dateStr})")

      Stdlib.printLine ""
      state

  | ["clear"] ->
    Darklang.SCM.Account.clearCurrentBranch ()
    Stdlib.printLine "Cleared current branch (now searching all packages)"

    { state with
        currentBranchId = Stdlib.Option.Option.None
        needsFullRedraw = true }

  | ["unset"] ->
    Darklang.SCM.Account.clearCurrentBranch ()
    Stdlib.printLine "Unset current branch (now searching all packages)"

    { state with
        currentBranchId = Stdlib.Option.Option.None
        needsFullRedraw = true }

  | ["none"] ->
    Darklang.SCM.Account.clearCurrentBranch ()
    Stdlib.printLine "Unset current branch (now searching all packages)"

    { state with
        currentBranchId = Stdlib.Option.Option.None
        needsFullRedraw = true }

  | _ ->
    Stdlib.printLine (Colors.error "Unknown branch command")
    help state


let help (state: Cli.AppState) : Cli.AppState =
  Stdlib.printLine "Branch Management Commands"
  Stdlib.printLine ""
  Stdlib.printLine "  dark branch list           List all branches"
  Stdlib.printLine "  dark branch create NAME    Create and switch to new branch"
  Stdlib.printLine "  dark branch switch NAME    Switch to existing branch"
  Stdlib.printLine "  dark branch switch-id ID   Switch to branch by ID"
  Stdlib.printLine "  dark branch status         Show current branch status"
  Stdlib.printLine "  dark branch info           Show detailed info (current branch)"
  Stdlib.printLine "  dark branch info NAME      Show detailed info (specific branch)"
  Stdlib.printLine "  dark branch unset          Unset current branch (search all packages)"
  Stdlib.printLine "  dark branch none           Alias for 'unset'"
  Stdlib.printLine "  dark branch clear          Deprecated alias for 'unset'"
  Stdlib.printLine ""
  state


let complete (state: Cli.AppState) (args: List<String>) : List<String> =
  match args with
  | [] -> [ "list"; "create"; "switch"; "switch-id"; "status"; "unset"; "none"; "clear" ]

  | [partial] ->
    [ "list"; "create"; "switch"; "switch-id"; "status"; "unset"; "none"; "clear" ]
    |> Stdlib.List.filter (fun cmd -> Stdlib.String.startsWith cmd partial)

  | ["switch"] ->
    let branches = Darklang.SCM.Branch.list ()
    Stdlib.List.map branches (fun b -> b.title)

  | ["switch"; partial] ->
    let branches = Darklang.SCM.Branch.list ()

    branches
    |> Stdlib.List.map (fun b -> b.title)
    |> Stdlib.List.filter (fun name -> Stdlib.String.startsWith name partial)

  | _ -> []
