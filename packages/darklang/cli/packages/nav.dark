/// Navigate between packages, modules, and entities
module Darklang.Cli.Packages.Nav

module Interactive =
  // Terminal screen management
  let enterAlternateScreen () : Unit =
    Stdlib.print "\u001b[?1049h"  // Switch to alternate screen buffer

  let exitAlternateScreen () : Unit =
    Stdlib.print "\u001b[?1049l"  // Switch back to main screen buffer

  // Interactive navigation types
  type NavItem =
    { name: String
      entityType: String             // "module", "type", "function", "value"
      location: PackageLocation }

  type Mode =
    | Nav                             // Normal navigation mode
    | Search                          // Search mode
    | Focus of Mode                   // Focused view on selected item (with mode to return to)

  type State =
    { items: List<NavItem>           // Current directory contents
      selectedIndex: Int64           // Which item is focused/selected
      scrollOffset: Int64            // For scrolling long lists
      currentLocation: PackageLocation
      mode: Mode                      // Current interaction mode
      branchID: Stdlib.Option.Option<Uuid>  // Branch context for package operations
      searchQuery: String             // Current search query
      allItems: List<NavItem> }       // Unfiltered items for restoring after search

  // Create interactive navigation state for a location
  let buildState
    (branchID: Stdlib.Option.Option<Uuid>)
    (location: PackageLocation)
    : State =
    let modulePath =
      match location with
      | Module path -> path
      | Type t -> Stdlib.List.append [t.owner] t.modules
      | Value v -> Stdlib.List.append [v.owner] v.modules
      | Function f -> Stdlib.List.append [f.owner] f.modules

    // Get all entities in this location
    let results = Query.searchContents branchID modulePath

    // Get submodules
    let currentPathLength = Stdlib.List.length modulePath
    let submoduleItems =
      (Query.getDirectSubmodules results currentPathLength)
      |> Stdlib.List.map (fun name ->
        NavItem
          { name = name
            entityType = "module"
            location = PackageLocation.Module (Stdlib.List.append modulePath [name]) })

    // Get types, values, functions
    let typeItems =
      results.types
      |> Stdlib.List.map (fun t ->
        NavItem
          { name = t.location.name
            entityType = "type"
            location = PackageLocation.Type t.location })

    let valueItems =
      results.values
      |> Stdlib.List.map (fun v ->
        NavItem
          { name = v.location.name
            entityType = "value"
            location = PackageLocation.Value v.location })

    let functionItems =
      results.fns
      |> Stdlib.List.map (fun fn ->
        NavItem
          { name = fn.location.name
            entityType = "function"
            location = PackageLocation.Function fn.location })

    // Combine in standard order: modules, types, values, functions
    let allItems =
      submoduleItems
      |> Stdlib.List.append typeItems
      |> Stdlib.List.append valueItems
      |> Stdlib.List.append functionItems

    State
      { items = allItems
        selectedIndex = 0L
        scrollOffset = 0L
        currentLocation = location
        mode = Mode.Nav
        branchID = branchID
        searchQuery = ""
        allItems = allItems }

  // Truncated view for inline display to avoid flooding screen with large modules
  let viewEntityTruncated
    (branchID: Stdlib.Option.Option<Uuid>)
    (location: PackageLocation)
    : Unit =
    let maxItemsPerCategory = 3L
    let maxTotalLines = 12L

    match location with
    | Module path ->
      let results = Query.searchContents branchID path
      let locationStr = Packages.formatLocation location
      Stdlib.printLine locationStr

      let currentPathLength = Stdlib.List.length path
      let directSubmodules = Query.getDirectSubmodules results currentPathLength

      let lineCount = 1L // Start with location line
      let lineCount =
        if Stdlib.Bool.not (Stdlib.List.isEmpty directSubmodules) then
          Stdlib.printLine (Display.getSectionHeader "submodule")
          let itemsToShow = Stdlib.List.take directSubmodules maxItemsPerCategory
          itemsToShow |> Stdlib.List.iter (fun name -> Stdlib.printLine $"  {name}/")

          let remaining = (Stdlib.List.length directSubmodules) - maxItemsPerCategory
          if remaining > 0L then
            Stdlib.printLine $"  ... and {Stdlib.Int64.toString remaining} more modules"

          lineCount + 1L + (Stdlib.List.length itemsToShow) + (if remaining > 0L then 1L else 0L)
        else
          lineCount

      // Only show other categories if we haven't exceeded line limit
      if lineCount < maxTotalLines then
        let remainingLines = maxTotalLines - lineCount
        let itemsPerRemaining = Stdlib.Int64.min 2L remainingLines

        // Show types (limited)
        if Stdlib.Bool.not (Stdlib.List.isEmpty results.types) && itemsPerRemaining > 0L then
          Stdlib.printLine (Display.getSectionHeader "type")
          let typesToShow = Stdlib.List.take results.types itemsPerRemaining
          typesToShow |> Stdlib.List.iter (fun t -> Stdlib.printLine $"  {t.location.name}")

          let remaining = (Stdlib.List.length results.types) - itemsPerRemaining
          if remaining > 0L then
            Stdlib.printLine $"  ... and {Stdlib.Int64.toString remaining} more types"

    | _ ->
      // For individual entities, show full view since they're typically small
      View.viewEntity branchID location

  // Display the interactive navigation interface
  let display (navState: State) : Unit =
    // Clear alternate screen and show header (main screen is preserved)
    Stdlib.print "\u001b[?25l\u001b[2J\u001b[H"

    let locationStr = Packages.formatLocation navState.currentLocation

    // Mode-specific header
    match navState.mode with
    | Nav ->
      Stdlib.printLine (Colors.boldText $"ðŸ“ {locationStr}")
      Stdlib.printLine (Stdlib.String.repeat "â”€" 60L)
    | Search ->
      Stdlib.printLine (Colors.boldText $"ðŸ” Search from {locationStr}")
      Stdlib.printLine (Stdlib.String.repeat "â”" 60L)
      Stdlib.printLine $"  {navState.searchQuery}_"
      Stdlib.printLine (Stdlib.String.repeat "â”" 60L)
    | Focus _ ->
      Stdlib.printLine (Colors.boldText $"ðŸ‘  {locationStr} (Focus Mode)")
      Stdlib.printLine (Stdlib.String.repeat "â”€" 60L)

    // Calculate viewport
    let viewportHeight = 12L
    let totalItems = Stdlib.List.length navState.items

    if totalItems == 0L then
      Stdlib.printLine "  (empty directory)"
    else
      // Calculate visible items
      let startIndex = navState.scrollOffset
      let endIndex = Stdlib.Int64.min (startIndex + viewportHeight) totalItems

      let visibleItems =
        navState.items
        |> Stdlib.List.drop startIndex
        |> Stdlib.List.take (endIndex - startIndex)

      // Display items
      visibleItems
      |> Stdlib.List.indexedMap (fun relativeIndex item ->
        let absoluteIndex = startIndex + relativeIndex
        let isSelected = absoluteIndex == navState.selectedIndex

        let icon = Display.getIcon item.entityType
        let cursor = if isSelected then "> " else "  "
        let nameDisplay =
          if item.entityType == "module" then
            item.name ++ "/"
          else
            item.name

        let line = cursor ++ icon ++ " " ++ nameDisplay

        if isSelected then
          Stdlib.printLine (Colors.info line)
        else
          Stdlib.printLine line
      )
      |> Stdlib.List.iter (fun _ -> ())

    // Show inline view and actions if in Focus mode and there are items
    match navState.mode with
    | Focus _ ->
      if totalItems > 0L then
        match Stdlib.List.getAt navState.items navState.selectedIndex with
        | Some selectedItem ->
          Stdlib.printLine ""
          Stdlib.printLine (Stdlib.String.repeat "â”€" 60L)
          viewEntityTruncated navState.branchID selectedItem.location
          Stdlib.printLine ""
          Stdlib.printLine (Stdlib.String.repeat "â”€" 60L)
          Stdlib.printLine (Colors.boldText "Available Actions:")
          match selectedItem.entityType with
          | "module" ->
            Stdlib.printLine "  â†’ : Navigate into module"
            Stdlib.printLine "  u : Update module"
          | "type" ->
            Stdlib.printLine "  u : Update type definition"
            Stdlib.printLine "  â†’ : View type details"
          | "function" ->
            Stdlib.printLine "  u : Update function"
            Stdlib.printLine "  â†’ : View function details"
          | "value" ->
            Stdlib.printLine "  u : Update value"
            Stdlib.printLine "  â†’ : View value details"
          | _ -> ()
        | None -> ()
    | _ -> ()

    Stdlib.printLine ""
    let helpText =
      match navState.mode with
      | Nav ->
        "â†‘/â†“: Navigate â€¢ â†: Up â€¢ â†’: Enter â€¢ Enter: Select â€¢ Space: Focus â€¢ /: Search â€¢ Esc: Exit"
      | Search ->
        "Type to search â€¢ â†‘/â†“: Navigate â€¢ Enter: Select â€¢ Space: Focus â€¢ Esc: Exit"
      | Focus _ ->
        "u: Update â€¢ â†’: Navigate/View â€¢ â†: Up â€¢ Esc: Back"
    Stdlib.printLine (Colors.hint helpText)

  // Perform search and update items based on query
  let performSearch (navState: State) : State =
    if Stdlib.String.isEmpty navState.searchQuery then
      // Empty query - restore all items
      { navState with
          items = navState.allItems
          selectedIndex = 0L
          scrollOffset = 0L }
    else
      // Search through package system
      let currentModule =
        match navState.currentLocation with
        | Module path -> path
        | Type t -> Stdlib.List.append [t.owner] t.modules
        | Value v -> Stdlib.List.append [v.owner] v.modules
        | Function f -> Stdlib.List.append [f.owner] f.modules

      let query =
        LanguageTools.ProgramTypes.Search.SearchQuery
          { currentModule = currentModule
            text = navState.searchQuery
            searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.AllDescendants
            entityTypes = []
            exactMatch = false }

      let results = LanguageTools.PackageManager.Search.search navState.branchID query

      // Convert search results to NavItems
      let moduleItems =
        match results.submodules with
        | [] -> []
        | [submodulePaths] ->
          submodulePaths
          |> Stdlib.List.map (fun modulePath ->
            NavItem
              { name = Stdlib.String.join modulePath "."
                entityType = "module"
                location = PackageLocation.Module modulePath })
        | _ -> []

      let typeItems =
        results.types
        |> Stdlib.List.map (fun t ->
          let fullPath =
            [ [ t.location.owner ]; t.location.modules; [ t.location.name ] ]
            |> Stdlib.List.flatten
            |> Stdlib.String.join "."
          NavItem
            { name = fullPath
              entityType = "type"
              location = PackageLocation.Type t.location })

      let valueItems =
        results.values
        |> Stdlib.List.map (fun v ->
          let fullPath =
            [ [ v.location.owner ]; v.location.modules; [ v.location.name ] ]
            |> Stdlib.List.flatten
            |> Stdlib.String.join "."
          NavItem
            { name = fullPath
              entityType = "value"
              location = PackageLocation.Value v.location })

      let fnItems =
        results.fns
        |> Stdlib.List.map (fun fn ->
          let fullPath =
            [ [ fn.location.owner ]; fn.location.modules; [ fn.location.name ] ]
            |> Stdlib.List.flatten
            |> Stdlib.String.join "."
          NavItem
            { name = fullPath
              entityType = "function"
              location = PackageLocation.Function fn.location })

      let searchItems =
        moduleItems
        |> Stdlib.List.append typeItems
        |> Stdlib.List.append valueItems
        |> Stdlib.List.append fnItems

      { navState with
          items = searchItems
          selectedIndex = 0L
          scrollOffset = 0L }

  // Handle key input for interactive navigation
  let handleKey (state: Cli.AppState) (key: Stdlib.Cli.Stdin.Key.Key) (keyChar: Stdlib.Option.Option<String>) (navState: State) : Cli.AppState =
    match navState.mode with
    | Search ->
      // Search mode - handle typing and search controls
      match key with
      | Escape ->
        // Exit search mode and restore original items
        let newNavState =
          { navState with
              mode = Mode.Nav
              searchQuery = ""
              items = navState.allItems
              selectedIndex = 0L
              scrollOffset = 0L }
        { state with currentPage = Page.InteractiveNav newNavState }

      | Backspace ->
        // Delete last character from search query
        let newQuery =
          if Stdlib.String.length navState.searchQuery > 0L then
            Stdlib.String.dropLast navState.searchQuery 1L
          else
            ""
        let newNavState = { navState with searchQuery = newQuery }
        let searchedNavState = performSearch newNavState
        { state with currentPage = Page.InteractiveNav searchedNavState }

      | UpArrow ->
        // Navigate up in search results
        let totalItems = Stdlib.List.length navState.items
        if totalItems > 0L then
          let newIndex =
            if navState.selectedIndex > 0L then
              navState.selectedIndex - 1L
            else
              totalItems - 1L
          let newScrollOffset =
            if newIndex < navState.scrollOffset then
              newIndex
            else
              navState.scrollOffset
          let newNavState =
            { navState with
                selectedIndex = newIndex
                scrollOffset = newScrollOffset }
          { state with currentPage = Page.InteractiveNav newNavState }
        else
          state

      | DownArrow ->
        // Navigate down in search results
        let totalItems = Stdlib.List.length navState.items
        if totalItems > 0L then
          let newIndex =
            if navState.selectedIndex < totalItems - 1L then
              navState.selectedIndex + 1L
            else
              0L
          let viewportHeight = 12L
          let newScrollOffset =
            if newIndex >= navState.scrollOffset + viewportHeight then
              newIndex - viewportHeight + 1L
            else
              navState.scrollOffset
          let newNavState =
            { navState with
                selectedIndex = newIndex
                scrollOffset = newScrollOffset }
          { state with currentPage = Page.InteractiveNav newNavState }
        else
          state

      | Enter ->
        // Select from search results and exit
        let totalItems = Stdlib.List.length navState.items
        if totalItems > 0L then
          match Stdlib.List.getAt navState.items navState.selectedIndex with
          | Some selectedItem ->
            Interactive.exitAlternateScreen ()
            let newState = navTo state selectedItem.location
            let locationStr = Packages.formatLocation selectedItem.location
            Stdlib.printLine (Colors.success $"Selected: {locationStr}")
            { newState with
                currentPage = Page.MainPrompt
                needsFullRedraw = true
                mainPrompt = ""
                cursorPosition = 0L }
          | None ->
            state
        else
          state

      | LeftArrow ->
        // Block left/right in search mode
        state

      | RightArrow ->
        // Block left/right in search mode
        state

      | Spacebar ->
        // Enter focus mode from search
        let newNavState = { navState with mode = Mode.Focus Mode.Search }
        { state with currentPage = Page.InteractiveNav newNavState }

      | _ ->
        // For any other key, try to add it to search query if it's a typeable character
        match keyChar with
        | Some char ->
          let newQuery = navState.searchQuery ++ char
          let newNavState = { navState with searchQuery = newQuery }
          let searchedNavState = performSearch newNavState
          { state with currentPage = Page.InteractiveNav searchedNavState }
        | None ->
          // Ignore non-typeable keys
          state

    | Nav ->
      // Navigation mode
      match key with
      | Spacebar ->
        // Enter focus mode
        let newNavState = { navState with mode = Mode.Focus Mode.Nav }
        { state with currentPage = Page.InteractiveNav newNavState }

      | UpArrow ->
        // Move selection up
        let totalItems = Stdlib.List.length navState.items
        if totalItems > 0L then
          let newIndex =
            if navState.selectedIndex > 0L then
              navState.selectedIndex - 1L
            else
              totalItems - 1L  // Wrap to bottom

          // Adjust scroll if needed
          let newScrollOffset =
            if newIndex < navState.scrollOffset then
              newIndex
            else
              navState.scrollOffset

          let newNavState =
            { navState with
                selectedIndex = newIndex
                scrollOffset = newScrollOffset }

          { state with currentPage = Page.InteractiveNav newNavState }
        else
          state

      | DownArrow ->
        // Move selection down
        let totalItems = Stdlib.List.length navState.items
        if totalItems > 0L then
          let newIndex =
            if navState.selectedIndex < totalItems - 1L then
              navState.selectedIndex + 1L
            else
              0L  // Wrap to top

          // Adjust scroll if needed
          let viewportHeight = 12L
          let newScrollOffset =
            if newIndex >= navState.scrollOffset + viewportHeight then
              newIndex - viewportHeight + 1L
            else
              navState.scrollOffset

          let newNavState =
            { navState with
                selectedIndex = newIndex
                scrollOffset = newScrollOffset }

          { state with currentPage = Page.InteractiveNav newNavState }
        else
          state

      | RightArrow ->
        // Navigate into modules (dig deeper)
        let totalItems = Stdlib.List.length navState.items
        if totalItems > 0L then
          match Stdlib.List.getAt navState.items navState.selectedIndex with
          | Some selectedItem ->
            if selectedItem.entityType == "module" then
              // Navigate into this location
              let newState = navTo state selectedItem.location
              let newNavState = buildState state.currentBranchId selectedItem.location
              { newState with currentPage = Page.InteractiveNav newNavState }
            else
              // Can't navigate into non-modules, ignore
              state
          | None ->
            state
        else
          state

      | LeftArrow ->
        // Go up to parent directory
        match Traversal.applySegment navState.branchID navState.currentLocation Traversal.PathSegment.Up with
        | Ok parentLocation ->
          let newState = navTo state parentLocation
          let newNavState = buildState state.currentBranchId parentLocation
          { newState with currentPage = Page.InteractiveNav newNavState }
        | Error _ ->
          // Already at root or error, ignore
          state

      | Enter ->
        // Choose/select current item and exit interactive mode
        let totalItems = Stdlib.List.length navState.items
        if totalItems > 0L then
          match Stdlib.List.getAt navState.items navState.selectedIndex with
          | Some selectedItem ->
            Interactive.exitAlternateScreen ()
            let newState = navTo state selectedItem.location
            let locationStr = Packages.formatLocation selectedItem.location
            Stdlib.printLine (Colors.success $"Selected: {locationStr}")
            { newState with
                currentPage = Page.MainPrompt
                needsFullRedraw = true
                mainPrompt = ""
                cursorPosition = 0L }
          | None ->
            // Exit without selection
            Interactive.exitAlternateScreen ()
            { state with
                currentPage = Page.MainPrompt
                needsFullRedraw = true
                mainPrompt = ""
                cursorPosition = 0L }
        else
          // Exit without selection
          Interactive.exitAlternateScreen ()
          { state with
              currentPage = Page.MainPrompt
              needsFullRedraw = true
              mainPrompt = ""
              cursorPosition = 0L }

      | Escape ->
        // Exit interactive navigation without making changes
        Interactive.exitAlternateScreen ()
        { state with
            currentPage = Page.MainPrompt
            needsFullRedraw = true
            mainPrompt = ""
            cursorPosition = 0L }

      | _ ->
        // Check if it's the / key to enter search mode
        match keyChar with
        | Some "/" ->
          let newNavState = { navState with mode = Mode.Search }
          { state with currentPage = Page.InteractiveNav newNavState }
        | _ ->
          // Ignore other keys
          state

    | Focus returnMode ->
      // Focus mode - shows item details with available actions
      match key with
      | Spacebar ->
        // Exit focus mode back to previous mode
        let newNavState = { navState with mode = returnMode }
        { state with currentPage = Page.InteractiveNav newNavState }

      | U ->
        // Update action - open editor/updater for selected item
        let totalItems = Stdlib.List.length navState.items
        if totalItems > 0L then
          match Stdlib.List.getAt navState.items navState.selectedIndex with
          | Some selectedItem ->
            // TODO: Implement update flow - for now just show a message
            Interactive.exitAlternateScreen ()
            let locationStr = Packages.formatLocation selectedItem.location
            Stdlib.printLine (Colors.info $"Update mode for {locationStr} (coming soon)")
            { state with
                currentPage = Page.MainPrompt
                needsFullRedraw = true
                mainPrompt = ""
                cursorPosition = 0L }
          | None ->
            state
        else
          state

      | UpArrow ->
        // Move selection up
        let totalItems = Stdlib.List.length navState.items
        if totalItems > 0L then
          let newIndex =
            if navState.selectedIndex > 0L then
              navState.selectedIndex - 1L
            else
              totalItems - 1L
          let newScrollOffset =
            if newIndex < navState.scrollOffset then
              newIndex
            else
              navState.scrollOffset
          let newNavState =
            { navState with
                selectedIndex = newIndex
                scrollOffset = newScrollOffset }
          { state with currentPage = Page.InteractiveNav newNavState }
        else
          state

      | DownArrow ->
        // Move selection down
        let totalItems = Stdlib.List.length navState.items
        if totalItems > 0L then
          let newIndex =
            if navState.selectedIndex < totalItems - 1L then
              navState.selectedIndex + 1L
            else
              0L
          let viewportHeight = 12L
          let newScrollOffset =
            if newIndex >= navState.scrollOffset + viewportHeight then
              newIndex - viewportHeight + 1L
            else
              navState.scrollOffset
          let newNavState =
            { navState with
                selectedIndex = newIndex
                scrollOffset = newScrollOffset }
          { state with currentPage = Page.InteractiveNav newNavState }
        else
          state

      | RightArrow ->
        // Navigate into modules
        let totalItems = Stdlib.List.length navState.items
        if totalItems > 0L then
          match Stdlib.List.getAt navState.items navState.selectedIndex with
          | Some selectedItem ->
            if selectedItem.entityType == "module" then
              let newState = navTo state selectedItem.location
              let newNavState = buildState state.currentBranchId selectedItem.location
              { newState with currentPage = Page.InteractiveNav newNavState }
            else
              state
          | None ->
            state
        else
          state

      | LeftArrow ->
        // Go up to parent directory
        match Traversal.applySegment navState.branchID navState.currentLocation Traversal.PathSegment.Up with
        | Ok parentLocation ->
          let newState = navTo state parentLocation
          let newNavState = buildState state.currentBranchId parentLocation
          { newState with currentPage = Page.InteractiveNav newNavState }
        | Error _ ->
          state

      | Enter ->
        // Select and exit
        let totalItems = Stdlib.List.length navState.items
        if totalItems > 0L then
          match Stdlib.List.getAt navState.items navState.selectedIndex with
          | Some selectedItem ->
            Interactive.exitAlternateScreen ()
            let newState = navTo state selectedItem.location
            let locationStr = Packages.formatLocation selectedItem.location
            Stdlib.printLine (Colors.success $"Selected: {locationStr}")
            { newState with
                currentPage = Page.MainPrompt
                needsFullRedraw = true
                mainPrompt = ""
                cursorPosition = 0L }
          | None ->
            Interactive.exitAlternateScreen ()
            { state with
                currentPage = Page.MainPrompt
                needsFullRedraw = true
                mainPrompt = ""
                cursorPosition = 0L }
        else
          Interactive.exitAlternateScreen ()
          { state with
              currentPage = Page.MainPrompt
              needsFullRedraw = true
              mainPrompt = ""
              cursorPosition = 0L }

      | Escape ->
        // Go back to previous mode (Nav or Search)
        let newNavState = { navState with mode = returnMode }
        { state with currentPage = Page.InteractiveNav newNavState }

      | _ ->
        // Check for / key to enter search
        match keyChar with
        | Some "/" ->
          let newNavState = { navState with mode = Mode.Search }
          { state with currentPage = Page.InteractiveNav newNavState }
        | _ ->
          state

let navTo (state: Cli.AppState) (location: PackageLocation): Cli.AppState =
  // if the intended state is the same as the current state (cd .), then short-circuit
  if location == state.packageData.currentLocation then
    state
  else
    // Update history by adding current location before moving
    let newHistory = Stdlib.List.append state.packageData.locationHistory [state.packageData.currentLocation]

    // Update state with new location and history
    { state with
        needsFullRedraw = true
        mainPrompt = ""
        cursorPosition = 0L
        packageData =
          { state.packageData with
              currentLocation = location
              locationHistory = newHistory }
    }


let execute (state: Cli.AppState) (args: List<String>) : Cli.AppState =
  match args with
  | [] ->
    // Enter interactive navigation mode
    Interactive.enterAlternateScreen ()
    let navState = Interactive.buildState state.currentBranchId state.packageData.currentLocation
    { state with
        currentPage = Page.InteractiveNav navState
        needsFullRedraw = true
        mainPrompt = ""
        cursorPosition = 0L }

  | [pathArg] ->
    // Use traverse to handle the path navigation
    match Traversal.traverse state.currentBranchId state.packageData.currentLocation pathArg with
    | Error errorMsg ->
      // Navigation failed - show error and don't change location
      Stdlib.printLine (Colors.error $"Navigation failed: {errorMsg}")
      state
    | Ok newLocation ->
      // Navigation succeeded - update state using navTo
      let locationStr = Packages.formatLocation newLocation
      Stdlib.printLine (Colors.success $"Changed to: {locationStr}")
      navTo state newLocation
  | _ ->
    help state


let complete (state: Cli.AppState) (args: List<String>) : List<String> =
  match args with
  | [] ->
    // No args - complete from current location
    Traversal.completePartialPath state.currentBranchId state.packageData.currentLocation ""
  | [partialPath] ->
    Traversal.completePartialPath state.currentBranchId state.packageData.currentLocation partialPath
  | _ ->
    // Too many arguments
    []


let help (_state: Cli.AppState) : Cli.AppState =
  [
    "Usage: nav [path]"
    "Navigate package space - modules, types, values, and functions ."
    ""
    "With path: Navigate directly to the specified location."
    "Without path: Enter interactive navigation mode."
    ""
    "Examples:"
    "  nav /                - Go to root"
    "  nav /Darklang/Stdlib - Go to absolute path from root"
    "  nav ..               - Go to parent"
    "  nav ../..            - Go to grandparent"
    "  nav Submodule        - Go to a submodule of current location"
    "  nav Stdlib/List      - Go to Stdlib.List module"
    "  nav equals           - Go to equals function"
    "  nav Option           - Go to Option type"
  ] |> Stdlib.printLines
  _state