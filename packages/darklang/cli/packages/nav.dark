/// Navigate between packages, modules, and entities
module Darklang.Cli.Packages.Nav

let navTo (state: AppState) (location: PackageLocation): AppState =
  // if the intended state is the same as the current state (cd .), then short-circuit
  if location == state.packageData.currentLocation then
    state
  else
    // Update history by adding current location before moving
    let newHistory = Stdlib.List.append state.packageData.locationHistory [state.packageData.currentLocation]

    // Update state with new location and history
    { state with
        needsFullRedraw = true
        prompt = Prompt.Editing.clear state.prompt
        packageData =
          { state.packageData with
              currentLocation = location
              locationHistory = newHistory }
    }


let execute (state: AppState) (args: List<String>) : AppState =
  match args with
  | [] ->
    // Enter interactive navigation mode
    NavInteractive.enterAlternateScreen ()
    let navState = NavInteractive.buildState state.packageData.currentLocation
    { state with
        currentPage = Page.InteractiveNav navState
        needsFullRedraw = true
        prompt = Prompt.Editing.clear state.prompt }

  | [pathArg] ->
    // Use traverse to handle the path navigation
    match Traversal.traverse state.packageData.currentLocation pathArg with
    | Error errorMsg ->
      // Navigation failed - show error and don't change location
      Stdlib.printLine (Colors.error $"Navigation failed: {errorMsg}")
      state
    | Ok newLocation ->
      // Navigation succeeded - update state using navTo
      let locationStr = Packages.formatLocation newLocation
      Stdlib.printLine (Colors.success $"Changed to: {locationStr}")
      navTo state newLocation
  | _ ->
    help state


let complete (state: AppState) (args: List<String>) : List<Completion.CompletionItem> =
  match args with
  | [] ->
    // No args - complete from current location
    Traversal.completePartialPath state.packageData.currentLocation ""
  | [partialPath] ->
    Traversal.completePartialPath state.packageData.currentLocation partialPath
  | _ ->
    // Too many arguments
    []


let help (_state: AppState) : AppState =
  [
    "Usage: nav [path]"
    "Navigate package space - modules, types, values, and functions ."
    ""
    "With path: Navigate directly to the specified location."
    "Without path: Enter interactive navigation mode."
    ""
    "Examples:"
    "  nav /                - Go to root"
    "  nav /Darklang/Stdlib - Go to absolute path from root"
    "  nav ..               - Go to parent"
    "  nav ../..            - Go to grandparent"
    "  nav Submodule        - Go to a submodule of current location"
    "  nav Stdlib/List      - Go to Stdlib.List module"
    "  nav equals           - Go to equals function"
    "  nav Option           - Go to Option type"
  ] |> Stdlib.printLines
  _state
