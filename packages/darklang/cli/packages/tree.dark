/// Tree command - display package hierarchy
module Darklang.Cli.Packages.Tree


// Table of contents categories with their package paths and descriptions
type TocEntry =
  { category: String
    path: String
    description: String }

// Define the table of contents structure
let tocEntries: List<TocEntry> =
  [ // Platform Core
    TocEntry
      { category = "PLATFORM CORE"
        path = "Darklang.Canvas"
        description = "Editor UI components" }
    TocEntry
      { category = "PLATFORM CORE"
        path = "Darklang.Cli"
        description = "Command-line interface" }

    // Protocols & Integration
    TocEntry
      { category = "PROTOCOLS & INTEGRATION"
        path = "Darklang.JsonRPC"
        description = "JSON-RPC protocol" }
    TocEntry
      { category = "PROTOCOLS & INTEGRATION"
        path = "Darklang.LanguageServerProtocol"
        description = "LSP types" }
    TocEntry
      { category = "PROTOCOLS & INTEGRATION"
        path = "Darklang.VSCode"
        description = "VS Code extension" }
    TocEntry
      { category = "PROTOCOLS & INTEGRATION"
        path = "Darklang.GitHub"
        description = "GitHub integration" }

    // Standard Library
    TocEntry
      { category = "STANDARD LIBRARY"
        path = "Darklang.Stdlib"
        description = "Core standard library" }

    // Language Tools
    TocEntry
      { category = "LANGUAGE TOOLS"
        path = "Darklang.LanguageTools"
        description = "Parser, analyzer, etc." }
    TocEntry
      { category = "LANGUAGE TOOLS"
        path = "Darklang.PrettyPrinter"
        description = "Code formatting" }

    // Testing & Utilities
    TocEntry
      { category = "TESTING & UTILITIES"
        path = "Darklang.Tests"
        description = "Test helpers" }
    TocEntry
      { category = "TESTING & UTILITIES"
        path = "Darklang.DarkPackages"
        description = "Package metadata" } ]


// Display the table of contents
let displayTableOfContents (): Unit =
  Stdlib.printLine ""
  Stdlib.printLine (Colors.colorize Colors.bold "DARKLANG PACKAGE TABLE OF CONTENTS")
  Stdlib.printLine (Colors.colorize Colors.bold "===================================")
  Stdlib.printLine ""

  // Group entries by category
  let grouped =
    tocEntries
    |> Stdlib.List.fold Stdlib.Dict.empty (fun acc entry ->
      let existing =
        match Stdlib.Dict.get acc entry.category with
        | Some list -> list
        | None -> []

      Stdlib.Dict.setOverridingDuplicates
        acc
        entry.category
        (Stdlib.List.append existing [ entry ]))

  // Display in order (use a list to preserve order)
  let categories =
    [ "PLATFORM CORE"
      "PROTOCOLS & INTEGRATION"
      "STANDARD LIBRARY"
      "LANGUAGE TOOLS"
      "TESTING & UTILITIES" ]

  categories
  |> Stdlib.List.iter (fun category ->
    match Stdlib.Dict.get grouped category with
    | Some entries ->
      Stdlib.printLine (Colors.colorize Colors.bold category)

      entries
      |> Stdlib.List.iter (fun entry ->
        let pathDisplay = Colors.colorize Colors.cyan entry.path
        let descDisplay = Colors.colorize Colors.dim entry.description
        Stdlib.printLine $"  {pathDisplay}"
        Stdlib.printLine $"    {descDisplay}")

      Stdlib.printLine ""
    | None -> ())

  Stdlib.printLine (Colors.hint "Use 'tree <path>' to explore a specific package")
  Stdlib.printLine (Colors.hint "Use 'tree --depth=N' for deeper views (max 10)")


let execute (state: AppState) (args: List<String>): AppState =
  // Check for --toc flag
  let showToc =
    match Stdlib.List.findFirst args (fun arg -> arg == "--toc") with
    | Some _ -> true
    | None -> false

  if showToc then
    displayTableOfContents ()
    state
  else
    // Parse depth option (default is 2 for better initial view)
    let maxDepth =
      match Stdlib.List.findFirst args (fun arg -> Stdlib.String.startsWith arg "--depth=") with
      | Some depthArg ->
        let depthStr = Stdlib.String.dropFirst depthArg 8L // Remove "--depth="
        match Stdlib.Int64.parse depthStr with
        | Ok depth ->
          if depth > 0L && depth <= 10L then depth else 2L // Limit to reasonable range
        | Error _ -> 2L
      | None -> 2L // Default depth of 2 for concise but useful view

    // Determine starting location
    let branchId = Stdlib.Option.Option.Some state.currentBranchId
    let startLocation =
      let pathArgs =
        args
        |> Stdlib.List.filter (fun arg -> Stdlib.Bool.not (Stdlib.String.startsWith arg "--"))

      match pathArgs with
      | [] -> state.packageData.currentLocation
      | [ pathStr ] ->
        match Traversal.traverse branchId state.packageData.currentLocation pathStr with
        | Ok location -> location
        | Error _ -> state.packageData.currentLocation
      | _ -> state.packageData.currentLocation

    // Display tree
    let locationStr = Packages.formatLocation startLocation
    Stdlib.printLine $"Package tree from {locationStr}:"
    Stdlib.printLine ""
    displayTree branchId startLocation maxDepth 0L ""

    state


// Display tree recursively from a given location
let displayTree
  (branchId: Stdlib.Option.Option<Uuid>)
  (location: PackageLocation)
  (remainingDepth: Int64)
  (currentDepth: Int64)
  (prefix: String)
  : Unit =
  if remainingDepth <= 0L then
    ()
  else
    let modulePath =
      match location with
      | Module path -> path
      | Type t -> Stdlib.List.append [t.owner] t.modules
      | Value v -> Stdlib.List.append [v.owner] v.modules
      | Function f -> Stdlib.List.append [f.owner] f.modules

    // Get all entities in this module
    let results = Query.allDirectDescendants branchId modulePath

    // Get submodules
    let currentPathLength = Stdlib.List.length modulePath
    let submoduleNames = Query.getDirectSubmodules results currentPathLength

    // Get entity names
    let functionNames = results.fns |> Stdlib.List.map (fun f -> f.location.name) |> Stdlib.List.sort
    let typeNames = results.types |> Stdlib.List.map (fun t -> t.location.name) |> Stdlib.List.sort
    let valueNames = results.values |> Stdlib.List.map (fun v -> v.location.name) |> Stdlib.List.sort

    // Combine all entities with their types in proper order: modules, types, values, functions
    let allEntities =
      let moduleEntities = submoduleNames |> Stdlib.List.map (fun name -> (name, EntityType.Module)) |> Stdlib.List.sortBy (fun (name, _) -> name)
      let typeEntities = typeNames |> Stdlib.List.map (fun name -> (name, EntityType.Type)) |> Stdlib.List.sortBy (fun (name, _) -> name)
      let valueEntities = valueNames |> Stdlib.List.map (fun name -> (name, EntityType.Value)) |> Stdlib.List.sortBy (fun (name, _) -> name)
      let functionEntities = functionNames |> Stdlib.List.map (fun name -> (name, EntityType.Function)) |> Stdlib.List.sortBy (fun (name, _) -> name)

      moduleEntities
      |> Stdlib.List.append typeEntities
      |> Stdlib.List.append valueEntities
      |> Stdlib.List.append functionEntities

    // Display entities with appropriate icons
    let entitiesCount = Stdlib.List.length allEntities
    allEntities
    |> Stdlib.List.indexedMap (fun index (name, entityType) ->
      let isLast = index == (entitiesCount - 1L)
      let treeBranch = if isLast then "└── " else "├── "
      let fullPrefix = prefix ++ treeBranch

      let icon = Display.getIcon entityType ++ " "

      Stdlib.printLine $"{fullPrefix}{icon}{name}"

      // Recursively display submodules
      if entityType == EntityType.Module && remainingDepth > 1L then
        let newPrefix = prefix ++ (if isLast then "    " else "│   ")
        let newModulePath = Stdlib.List.append modulePath [name]
        let newLocation = PackageLocation.Module newModulePath
        displayTree branchId newLocation (remainingDepth - 1L) (currentDepth + 1L) newPrefix
    )
    |> Stdlib.List.iter (fun _ -> ())


let complete (state: AppState) (args: List<String>) : List<Completion.CompletionItem> =
  // Filter out depth arguments for path completion
  let pathArgs = Stdlib.List.filter args (fun arg -> Stdlib.Bool.not (Stdlib.String.startsWith arg "--"))
  let branchId = Stdlib.Option.Option.Some state.currentBranchId

  match pathArgs with
  | [] ->
    Traversal.completePartialPath branchId state.packageData.currentLocation ""
  | [partialPath] ->
    Traversal.completePartialPath branchId state.packageData.currentLocation partialPath
  | _ -> []


let help (state: AppState): Unit =
  [ "Usage: tree [path] [--depth=N] [--toc]"
    "       packages [path] [--depth=N] [--toc]"
    ""
    "Display package hierarchy in tree format."
    ""
    "Options:"
    "  --depth=N       Set maximum depth (1-10, default: 2)"
    "  --toc           Show table of contents overview"
    ""
    "Examples:"
    "  tree                         - Show tree with icons, depth 2"
    "  tree --toc                   - Show package table of contents"
    "  packages --toc               - Same as tree --toc"
    "  tree /                       - Show tree from root"
    "  tree Darklang                - Show Darklang package tree"
    "  tree --depth=1               - Show only direct children"
    "  tree --depth=5               - Show deeper tree structure"
    "  tree Darklang.Stdlib         - Show Stdlib tree" ]
  |> Stdlib.printLines
