module Darklang.Cli.Run


// Helper: Parse a single argument string into an expression
let parseArgString (branchId: Uuid) (pm: LanguageTools.ProgramTypes.PackageManager) (arg: String) : LanguageTools.ProgramTypes.Expr =
  let onMissing = LanguageTools.NameResolver.OnMissing.Allow
  let parsedFile =
    arg
    |> LanguageTools.Parser.parseToSimplifiedTree
    |> LanguageTools.Parser.parseFromTree
    |> Builtin.unwrap

  let expr =
    match parsedFile with
    | SourceFile source ->
      source.exprsToEval
      |> Stdlib.List.head
      |> Builtin.unwrap

  let (converted, _unresolved) =
    LanguageTools.WrittenTypesToProgramTypes.Expr.toPT
      branchId
      onMissing
      pm
      ""
      []
      LanguageTools.WrittenTypesToProgramTypes.defaultContext
      expr

  converted


// Helper: Complete function names with @ prefix
// Uses the same traversal logic as 'nav' and 'ls' commands
let completeFunctionName (searchText: String) : List<String> =
  if (Stdlib.String.length searchText) < 2L then
    []
  else
    // Start from root and use existing traversal completion
    let rootLocation = Packages.PackageLocation.Module []

    Packages.Traversal.completePartialPath
      Stdlib.Option.Option.None
      rootLocation
      searchText
    |> Stdlib.List.map (fun completion -> $"@{completion}")
    |> Stdlib.List.take 100L


// Run command - execute functions or scripts
let execute (state: AppState) (args: List<String>) : AppState =
  match args with
  | [] ->
    help state
    state
  | thingToRun :: args ->
    if Stdlib.String.startsWith thingToRun "@" then
      executeFunction state (Stdlib.String.dropFirst thingToRun 1L) args
    else
      executeScript state thingToRun args


// Execute a script file
let executeScript (state: AppState) (scriptPath: String) (args: List<String>) : AppState =
  match Builtin.fileRead scriptPath with
  | Error e ->
    Stdlib.printLine $"File error: {e}"
    state
  | Ok script ->
    let scriptSourceCode = Stdlib.String.fromBytesWithReplacement script
    let result =
      Builtin.cliParseAndExecuteScript
        state.currentBranchId
        scriptPath
        scriptSourceCode
        args

    match result with
    | Ok exitCode ->
      Stdlib.printLine
        $"Script executed with exit code: {Stdlib.Int64.toString exitCode}"

      state
    | Error e ->
      let prettyError =
        PrettyPrinter.RuntimeTypes.RuntimeError.toString
          state.currentBranchId
          e

      Stdlib.printLine $"Script error: {prettyError}"
      state


// Execute a function by name with arguments
let executeFunction (state: AppState) (fnName: String) (args: List<String>) : AppState =
  let pm = LanguageTools.PackageManager.pm ()
  let parsedArgs =
    args |> Stdlib.List.map (parseArgString state.currentBranchId pm)

  match Builtin.cliExecuteFunction state.currentBranchId fnName parsedArgs with
  | Ok result ->
    Stdlib.printLine result
    state
  | Error err ->
    Stdlib.printLine $"Error: {ExecutionError.toString err}"
    state


// Provide autocomplete suggestions
let complete (state: AppState) (args: List<String>) : List<String> =
  match args with
  | [] ->
    let files = Stdlib.Cli.FileSystem.getDirectoryContents "."
    let currentDir = Builtin.directoryCurrent ()

    let directories =
      files
      |> Stdlib.List.filter (Stdlib.Cli.FileSystem.isDirectoryAtPath currentDir)

    let darkFiles =
      files |> Stdlib.List.filter (Stdlib.String.endsWith ".dark")

    Stdlib.List.append directories darkFiles

  | [ partialArg ] ->
    if Stdlib.String.startsWith partialArg "@" then
      completeFunctionName (Stdlib.String.dropFirst partialArg 1L)
    else
      Darklang.Cli.Completion.completeFilesystemPath partialArg

  | _ -> []


let help (state: AppState) : Unit =
  [
    "Usage: run @function_name [args...] | run script_path [args...]"
    "Run a function from the package manager or execute a Dark script file."
    ""
    "Function execution:"
    "  run @Stdlib.Int64.add 5L 3L      - Run a function with arguments"
    "  run @Stdlib.Bool.and true false   - Another function example"
    ""
    "Script execution:"
    "  run script.dark                  - Run a script file"
    "  run script.dark arg1 arg2        - Run script with arguments"
  ] |> Stdlib.printLines

