module Darklang.Cli.Run


// Helper: Complete function names with @ prefix
// Uses the same traversal logic as 'nav' and 'ls' commands
let completeFunctionName (searchText: String) : List<Completion.CompletionItem> =
  if (Stdlib.String.length searchText) < 2L then
    []
  else
    // Start from root and use existing traversal completion
    let rootLocation = Packages.PackageLocation.Module []

    (Packages.Traversal.completePartialPath
      Stdlib.Option.Option.None
      Stdlib.Option.Option.None
      rootLocation
      searchText)
    |> Stdlib.List.map (fun item ->
      Completion.CompletionItem
        { display = item.display
          value = $"@{item.value}" })
    |> Stdlib.List.take 100L


// Run command - execute functions or scripts
let execute (state: AppState) (args: List<String>) : AppState =
  match args with
  | [] ->
    help state
    state
  | thingToRun :: args ->
    if Stdlib.String.startsWith thingToRun "@" then
      executeFunction state (Stdlib.String.dropFirst thingToRun 1L) args
    else
      executeScript state thingToRun args


// Execute a script file
let executeScript (state: AppState) (scriptPath: String) (args: List<String>) : AppState =
  match Builtin.fileRead scriptPath with
  | Error e ->
    Stdlib.printLine $"File error: {e}"
    state
  | Ok script ->
    let scriptSourceCode = Stdlib.String.fromBytesWithReplacement script
    let result = Builtin.cliParseAndExecuteScript scriptPath scriptSourceCode args

    match result with
    | Ok exitCode ->
      Stdlib.printLine
        $"Script executed with exit code: {Stdlib.Int64.toString exitCode}"

      state
    | Error e ->
      let prettyError = PrettyPrinter.RuntimeTypes.RuntimeError.toString e

      Stdlib.printLine $"Script error: {prettyError}"
      state


// Execute a function by name with arguments
let executeFunction (state: AppState) (fnName: String) (args: List<String>) : AppState =
  let fullExpr = $"{fnName} {Stdlib.String.join args " "}"

  match Builtin.cliEvaluateExpression fullExpr with
  | Ok result ->
    Stdlib.printLine result
    state
  | Error err ->
    Stdlib.printLine $"Error: {ExecutionError.toString err}"
    state


// Provide autocomplete suggestions
let complete (_state: AppState) (args: List<String>) : List<Completion.CompletionItem> =
  match args with
  | [] ->
    let files = Stdlib.Cli.FileSystem.getDirectoryContents "."
    let currentDir = Builtin.directoryCurrent ()

    let directories =
      files
      |> Stdlib.List.filter (Stdlib.Cli.FileSystem.isDirectoryAtPath currentDir)

    let darkFiles =
      files |> Stdlib.List.filter (Stdlib.String.endsWith ".dark")

    let allFiles = Stdlib.List.append directories darkFiles
    allFiles |> Stdlib.List.map Completion.simple

  | [ partialArg ] ->
    if Stdlib.String.startsWith partialArg "@" then
      completeFunctionName (Stdlib.String.dropFirst partialArg 1L)
    else
      (Darklang.Cli.Completion.completeFilesystemPath partialArg)
      |> Stdlib.List.map Completion.simple

  | _ -> []


let help (state: AppState) : Unit =
  [
    "Usage: run @function_name [args...] | run script_path [args...]"
    "Run a function from the package manager or execute a Dark script file."
    ""
    "Function execution:"
    "  run @Stdlib.Int64.add 5L 3L      - Run a function with arguments"
    "  run @Stdlib.Bool.and true false   - Another function example"
    ""
    "Script execution:"
    "  run script.dark                  - Run a script file"
    "  run script.dark arg1 arg2        - Run script with arguments"
  ] |> Stdlib.printLines

