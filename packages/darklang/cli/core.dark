module Darklang.Cli

type Page =
  | MainPrompt
  | InteractiveNav of Packages.NavInteractive.State
  | CompletionPicker of CompletionPicker.State

type AppState =
  { isExiting: Bool
    prompt: Prompt.State
    needsFullRedraw: Bool
    packageData: Packages.State
    currentPage: Page }

let initState () : AppState =
  AppState
    { isExiting = false
      prompt = Prompt.initState ()
      needsFullRedraw = true
      packageData = Packages.initState ()
      currentPage = Page.MainPrompt }

type Msg =
  | ProcessInput of String
  | KeyPressed of key: Stdlib.Cli.Stdin.Key.Key * modifiers: Stdlib.Cli.Stdin.Modifiers.Modifiers * keyChar: Stdlib.Option.Option<String>
  | Exit


module ExecutionError =
  // TODO migrate this to some ParseAndExecuteScript submodule
  type ExecutionError =
    { msg: String; metadata: Dict<String> }

  let toString (err: ExecutionError) : String =
    let metadataStr =
      err.metadata
      |> Stdlib.Dict.toList
      |> Stdlib.List.map (fun (k, v) -> $"- {k}: {v}")
      |> Stdlib.String.join "\n"
    $"Error: {err.msg}\n{metadataStr}"


module View =
  let formatError (message: String) : String =
    Colors.error ("Error: " ++ message)

  let formatSuccess (message: String) : String =
    Colors.success message

  let formatPromptWithInput (state: AppState) : String =
    let locationStr = Packages.formatLocation state.packageData.currentLocation
    let hint = Registry.getCompletionHint state state.prompt.text
    Prompt.Display.formatPromptWithInput locationStr state.prompt.text hint

  let formatWelcome () : String = Registry.getCompactCommandList ()


module StatusBar =
  /// Initialize the status bar by setting up scroll region to reserve bottom line
  let init () : Unit =
    let terminalHeight = Terminal.getHeight ()
    // Set scroll region to all rows except the last one
    Stdlib.print (Colors.setScrollRegion 1L (terminalHeight - 1L))

  /// Render the status bar at the bottom of the terminal
  let render (state: AppState) : Unit =
    let terminalHeight = Terminal.getHeight ()
    let terminalWidth = Terminal.getWidth ()

    let leftText = " Darklang "

    // Use Darklang brand colors (purple/magenta)
    let leftPart =
      Colors.colorize (Colors.purpleBg ++ Colors.white ++ Colors.bold) leftText

    // Calculate padding
    let leftLen = Stdlib.String.length leftText
    let paddingLen = terminalWidth - leftLen

    let padding =
      if paddingLen > 0L then
        Colors.colorize Colors.grayBg (Stdlib.String.repeat " " paddingLen)
      else
        ""

    let statusLine = leftPart ++ padding

    // Save cursor, move to bottom, render, restore cursor
    Stdlib.print
      (Colors.saveCursor
       ++ Colors.moveCursorTo terminalHeight 1L
       ++ statusLine
       ++ Colors.restoreCursor)

  /// Clear the status bar and reset scroll region
  let clear () : Unit =
    let terminalHeight = Terminal.getHeight ()
    // Reset scroll region and clear the status bar line
    Stdlib.print
      (Colors.resetScrollRegion
       ++ Colors.saveCursor
       ++ Colors.moveCursorTo terminalHeight 1L
       ++ Colors.clearLine
       ++ Colors.restoreCursor)



module Registry =
  type CommandHandler =
    { name: String
      description: String
      aliases: List<String>
      execute: AppState -> List<String> -> AppState
      help: AppState -> AppState // CLEANUP we shouldn't need to return an AppState? Like a string would be fine...
      complete: AppState -> List<String> -> List<Completion.CompletionItem> }

  let allCommands () : List<CommandHandler> =
    [ ("quit", "Exit the CLI", [ "exit"; "q" ], Quit.execute, Quit.help, Quit.complete)
      ("help", "Show help for commands", [ "commands"; "?" ], Help.execute, Help.help, Help.complete)
      ("config", "Manage CLI configuration", [], Config.execute, Config.help, Config.complete)
      ("install", "Install CLI globally", [], Installation.Install.execute, Installation.Install.help, Installation.Install.complete)
      ("update", "Update CLI to latest version", [ "upgrade" ], Installation.Update.execute, Installation.Update.help, Installation.Update.complete)
      ("uninstall", "Remove CLI installation", [], Installation.Uninstall.execute, Installation.Uninstall.help, Installation.Uninstall.complete)
      ("install-status", "Show installation status", [], Installation.Status.execute, Installation.Status.help, Installation.Status.complete)
      ("version", "Display CLI version", [ "--version"; "-v" ], Installation.Version.execute, Installation.Version.help, Installation.Version.complete)
      ("nav", "Navigate between packages, modules, and entities", [ "cd" ], Packages.Nav.execute, Packages.Nav.help, Packages.Nav.complete)
      ("ls", "List package contents", [ "dir" ], Packages.Listing.execute, Packages.Listing.help, Packages.Listing.complete)
      ("back", "Go back to previous location", [], Packages.Back.execute, Packages.Back.help, Packages.Back.complete)
      ("clear", "Clear the screen", [ "cls" ], Cli.Clear.execute, Cli.Clear.help, Cli.Clear.complete)
      ("run", "Run a function or script", [], Cli.Run.execute, Cli.Run.help, Cli.Run.complete)
      ("eval", "Evaluate a Dark expression", [], Cli.Eval.execute, Cli.Eval.help, Cli.Eval.complete)
      ("scripts", "Store, manage, and run Dark scripts", [], Cli.Scripts.execute, Cli.Scripts.help, Cli.Scripts.complete)
      ("view", "View details of a module, type, value, or fns", [], Packages.View.execute, Packages.View.help, Packages.View.complete)
      ("tree", "Display package hierarchy in tree format", [], Packages.Tree.execute, Packages.Tree.help, Packages.Tree.complete)
      ("search", "Search for packages, types, functions, and values", [], Packages.Search.execute, Packages.Search.help, Packages.Search.complete)
      ("deps", "Show dependencies and dependents", [ "dependencies" ], Cli.Deps.execute, Cli.Deps.help, Cli.Deps.complete)
      ("val", "Create a new value", [], Packages.Value.execute, Packages.Value.help, Packages.Value.complete)
      ("let", "Create a new value (alias for val)", [], Packages.Value.execute, Packages.Value.help, Packages.Value.complete)
      ("fn", "Create a new function", [ "function" ], Packages.Fn.execute, Packages.Fn.help, Packages.Fn.complete)
      ("type", "Create a new type", [], Packages.Type.execute, Packages.Type.help, Packages.Type.complete)
      // SCM commands
      ("status", "Show uncommitted changes", [ "wip"; "changes" ], SCM.Status.execute, SCM.Status.help, SCM.Status.complete)
      ("log", "Show commit history", [ "history"; "commits" ], SCM.Log.execute, SCM.Log.help, SCM.Log.complete)
      ("commit", "Commit uncommitted changes", [], SCM.Commit.execute, SCM.Commit.help, SCM.Commit.complete)
      ("discard", "Discard uncommitted changes", [ "reset" ], SCM.Discard.execute, SCM.Discard.help, SCM.Discard.complete)
      ("show", "Show commit details", [], SCM.Show.execute, SCM.Show.help, SCM.Show.complete) ]
    |> Stdlib.List.map(
      // CLEANUP nitpicky: swap help and complete
      fun (name, desc, aliases, execute, help, complete) ->
        CommandHandler
          { name = name
            description = desc
            aliases = aliases
            execute = execute
            help = help
            complete = complete }
      )


  let findCommand (name: String) : CommandHandler =
    let commands = allCommands ()

    let allMatches = // CLEANUP use a Set?
      let nameMatches =
        commands
        |> Stdlib.List.filter  (fun cmd -> cmd.name == name)

      let aliasMatches =
        commands
        |> Stdlib.List.filter (fun cmd ->
          match Stdlib.List.findFirst cmd.aliases (fun alias -> alias == name) with
          | Some _ -> true
          | None -> false)

      Stdlib.List.append nameMatches aliasMatches

    match allMatches with
    | [handler] -> handler
    | handler :: _ -> handler // CLEANUP?
    | [] ->
      CommandHandler
        { name = name
          description = "Unknown command"
          aliases = []
          execute = fun state args ->
            Stdlib.printLine (View.formatError $"Unknown command: {name}")
            Stdlib.printLine "Use 'help' to see available commands."
            state
          help = fun state ->
            Stdlib.printLine $"No help available for command: {name}"
            state
          complete = fun _state _args -> [] }

  let executeCommand (name: String) (state: AppState) (args: List<String>) : AppState =
    let handler = findCommand name
    let ex = handler.execute
    ex state args

  let executeCommandHelp (name: String) (state: AppState) : AppState =
    let handler = findCommand name
    let help = handler.help
    let resultState = help state

    // Automatically append alias information if aliases exist
    match handler.aliases with
    | [] -> resultState
    | aliases ->
      let aliasText = Stdlib.String.join aliases ", "
      Stdlib.printLine ""
      Stdlib.printLine $"Aliases: {aliasText}"
      resultState

  // Command groups organized by category (shared between compact and detailed views)
  let commandGroups () : List<(String * List<String>)> =
    [ ("Packages", [ "nav"; "ls"; "view"; "back"; "search"; "fn"; "type" ])
      ("SCM", [ "status"; "log"; "commit"; "discard"; "show" ])
      ("Execution", [ "run"; "eval"; "scripts" ])
      ("Install", [ "install"; "update"; "uninstall"; "version" ])
      ("Utilities", [ "clear"; "help"; "quit" ]) ]

  // Helper function to format a group of commands with details
  let formatCommandGroup (groupName: String) (commandNames: List<String>) (commands: List<CommandHandler>) : String =
    let formattedCommands =
      commandNames
      |> Stdlib.List.filterMap (fun name ->
        match Stdlib.List.findFirst commands (fun cmd -> cmd.name == name) with
        | Some cmd ->
          match cmd.aliases with
          | [] -> Stdlib.Option.Option.Some $"  {cmd.name} - {cmd.description}"
          | aliases ->
            let aliasText = Stdlib.String.join aliases ", "
            Stdlib.Option.Option.Some $"  {cmd.name} ({aliasText}) - {cmd.description}"
        | None -> Stdlib.Option.Option.None)
    let commandLines = Stdlib.String.join formattedCommands "\n"
    $"{groupName}:\n{commandLines}"

  // Helper function to format a group of commands compactly (just names)
  let formatCompactGroup (groupName: String) (cmdNames: List<String>) : String =
    let namesList = Stdlib.String.join cmdNames ", "
    $"{groupName}: {namesList}"

  // Compact command list for welcome screen (with logo, minimal text)
  let getCompactCommandList () : String =
    let groups = commandGroups ()

    let formattedGroups =
      groups
      |> Stdlib.List.map (fun (groupName, cmdNames) ->
        formatCompactGroup groupName cmdNames)

    let welcome = "Welcome to Darklang!"
    let availableCommands = "Commands:"

    let groupsWithFooter =
      Stdlib.List.append formattedGroups [ ""; "Type 'help' for detailed command info" ]

    let allLines =
      Stdlib.List.append [ welcome; ""; availableCommands; "" ] groupsWithFooter

    Logo.combineLogoAndText Logo.logo allLines Colors.logoColor

  // Detailed command list for help command (no logo, full details)
  let getDetailedCommandList () : String =
    let commands = allCommands ()
    let groups = commandGroups ()

    // Format command groups with details
    let formattedGroups =
      groups
      |> Stdlib.List.map (fun (groupName, cmdNames) ->
        formatCommandGroup groupName cmdNames commands)

    // Find any ungrouped commands
    let allGroupedCommands =
      groups
      |> Stdlib.List.map (fun (_groupName, cmdNames) -> cmdNames)
      |> Stdlib.List.flatten
    let ungroupedCommands =
      commands
      |> Stdlib.List.filter (fun cmd ->
        match Stdlib.List.findFirst allGroupedCommands (fun name -> name == cmd.name) with
        | Some _ -> false
        | None -> true)
      |> Stdlib.List.map (fun cmd ->
        match cmd.aliases with
        | [] -> $"  {cmd.name} - {cmd.description}"
        | aliases ->
          let aliasText = Stdlib.String.join aliases ", "
          $"  {cmd.name} ({aliasText}) - {cmd.description}")

    let finalGroups =
      if Stdlib.List.isEmpty ungroupedCommands then
        formattedGroups
      else
        let ungroupedGroup =
          let ungroupedLines = Stdlib.String.join ungroupedCommands "\n"
          $"Other:\n{ungroupedLines}"
        Stdlib.List.append formattedGroups [ungroupedGroup]

    Stdlib.String.join finalGroups "\n\n"


  let getCompletions (state: AppState) (input: String) : List<Completion.CompletionItem> =
    let parsed = Completion.parseInput input

    if parsed.isCompletingCommand then
      // Completing command name
      let partial = Completion.getPartialCompletion parsed
      let commands = allCommands ()
      let allNames = Stdlib.List.map commands (fun cmd -> cmd.name)
      let allAliases = Stdlib.List.fold commands [] (fun acc cmd -> Stdlib.List.append acc cmd.aliases)
      let allOptions = Stdlib.List.append allNames allAliases

      let filtered =
        if Stdlib.String.isEmpty partial then
          allOptions
        else
          Stdlib.List.filter allOptions (fun name -> Stdlib.String.startsWith name partial)

      filtered |> Stdlib.List.map Completion.simple
    else
      // Completing command arguments
      let handler = findCommand parsed.commandName
      let completeFunc = handler.complete
      completeFunc state parsed.args

  let getCompletionHint (state: AppState) (input: String) : String =
    let parsed = Completion.parseInput input
    let completions = getCompletions state input
    let partial = Completion.getPartialCompletion parsed

    let completionValues = completions |> Stdlib.List.map (fun item -> item.value)
    Completion.getHintFromCompletions partial completionValues


module Commands =
  let parseAndExecute (state: AppState) (input: String) : AppState =
    let trimmed = Stdlib.String.trim input
    let parts =
      (Stdlib.String.split trimmed " ")
      |> Stdlib.List.filter (fun s -> s != "")

    match parts with
    | [] -> state
    | commandName :: args ->
      Registry.executeCommand commandName state args


let handleKeyInput (state: AppState) (key: Stdlib.Cli.Stdin.Key.Key) (modifiers: Stdlib.Cli.Stdin.Modifiers.Modifiers) (keyChar: Stdlib.Option.Option<String>) : AppState =
  match state.currentPage with
  | MainPrompt ->
    // Normal command mode key handling
    match key with
    | Enter ->
      // Execute the current command
      if Stdlib.String.isEmpty (Stdlib.String.trim state.prompt.text) then
        Stdlib.printLine ""
        { state with
            prompt = Prompt.Editing.clear state.prompt
            needsFullRedraw = false }
      else
        Stdlib.printLine ""
        let commandToExecute = Stdlib.String.trim state.prompt.text
        let newState = Commands.parseAndExecute state commandToExecute
        let clearedPrompt = Prompt.Editing.clear newState.prompt
        let promptWithHistory = Prompt.History.addCommand clearedPrompt commandToExecute
        { newState with
            prompt = promptWithHistory
            needsFullRedraw = true }

    | Backspace ->
      { state with
          prompt = Prompt.Editing.deleteBeforeCursor state.prompt
          needsFullRedraw = false }

    | Delete ->
      { state with
          prompt = Prompt.Editing.deleteAtCursor state.prompt
          needsFullRedraw = false }

    | Tab ->
      // Handle tab completion
      let completions = Registry.getCompletions state state.prompt.text

      // CLEANUP: When there are multiple completions with a common prefix (e.g. "filter" and "filterMap"),
      // Tab should complete up to the common part ("filter") rather than just showing options
      match completions with
      | [] -> state  // No completions available
      | [singleCompletion] ->
        // Single completion - auto-complete it
        let parsed = Completion.parseInput state.prompt.text
        let newPromptText = Completion.buildCompletedCommand parsed singleCompletion.value
        { state with prompt = Prompt.Editing.setText state.prompt newPromptText }
      | multiple ->
        // Multiple completions - open interactive picker
        Stdlib.printLine ""
        let pickerState = CompletionPicker.create state.prompt.text multiple
        { state with
            currentPage = Page.CompletionPicker pickerState
            needsFullRedraw = true }

    | UpArrow ->
      { state with
          prompt = Prompt.History.navigatePrevious state.prompt
          needsFullRedraw = false }

    | DownArrow ->
      { state with
          prompt = Prompt.History.navigateNext state.prompt
          needsFullRedraw = false }

    | LeftArrow ->
      { state with
          prompt = Prompt.Editing.moveCursorLeft state.prompt
          needsFullRedraw = false }

    | RightArrow ->
      { state with
          prompt = Prompt.Editing.moveCursorRight state.prompt
          needsFullRedraw = false }

    | Home ->
      { state with
          prompt = Prompt.Editing.moveCursorHome state.prompt
          needsFullRedraw = false }

    | End ->
      { state with
          prompt = Prompt.Editing.moveCursorEnd state.prompt
          needsFullRedraw = false }

    | _ ->
      // Add character to prompt at cursor position
      match keyChar with
      | Some char ->
        { state with
            prompt = Prompt.Editing.insertAtCursor state.prompt char
            needsFullRedraw = false }
      | None -> state

  | InteractiveNav navState ->
    // Interactive navigation key handling
    Packages.NavInteractive.handleKey state key keyChar navState

  | CompletionPicker pickerState ->
    // Completion picker key handling
    match CompletionPicker.handleKey pickerState key with
    | Continue newPickerState ->
      { state with
          currentPage = Page.CompletionPicker newPickerState
          needsFullRedraw = true }
    | SelectItem selection ->
      // User selected an item - update prompt and return to main
      let newPromptText = CompletionPicker.buildCompletedCommand pickerState selection
      { state with
          currentPage = Page.MainPrompt
          prompt = Prompt.Editing.setText state.prompt newPromptText
          needsFullRedraw = true }
    | Cancel ->
      // User cancelled - return to main with original prompt
      { state with
          currentPage = Page.MainPrompt
          needsFullRedraw = true }


module Update =
  let updateAppState (state: AppState) (msg: Msg) : AppState =
    match msg with
    | ProcessInput input ->
      Commands.parseAndExecute state input
    | KeyPressed (key, modifiers, keyChar) ->
      handleKeyInput state key modifiers keyChar
    | Exit ->
      { state with isExiting = true }

  let processInput (state: AppState) (input: String) : AppState =
    let trimmedInput = Stdlib.String.trim input
    if Stdlib.String.isEmpty trimmedInput then
      state
    else
      let msg = Msg.ProcessInput trimmedInput
      updateAppState state msg


let runInteractiveLoop (state: AppState) : Int64 =
  if state.isExiting then
    // Clear status bar before exiting
    StatusBar.clear ()
    0L
  else
    // Display current page
    match state.currentPage with
    | MainPrompt ->
      let locationStr = Packages.formatLocation state.packageData.currentLocation
      let inputStartColumn =
        Prompt.Display.calculateInputStartColumn locationStr

      if state.needsFullRedraw then
        // Redraw entire prompt line (used after commands that change state)
        let promptText = View.formatPromptWithInput state
        Stdlib.print promptText
      else
        // Update only the input portion (used during typing)
        Stdlib.print "\u001b[?25l" // Hide cursor during redraw
        Stdlib.print (Colors.moveCursorToColumn inputStartColumn)
        Stdlib.print Colors.clearLine
        Stdlib.print state.prompt.text
        let hint = Registry.getCompletionHint state state.prompt.text
        if Stdlib.Bool.not (Stdlib.String.isEmpty hint) then
          Stdlib.print (Colors.hint hint)
        Stdlib.print "\u001b[?25h" // Show cursor again

      // Position cursor at correct location within user input
      let cursorColumn = inputStartColumn + state.prompt.cursorPosition
      Stdlib.print (Colors.moveCursorToColumn cursorColumn)
    | InteractiveNav navState ->
      // Always display in interactive nav mode - it manages its own screen clearing
      Packages.NavInteractive.display navState

    | CompletionPicker pickerState ->
      // Display the completion picker
      if state.needsFullRedraw then CompletionPicker.display pickerState

    // Render status bar at bottom of terminal
    StatusBar.render state

    // Read keystroke input
    let keyInput = Stdlib.Cli.Stdin.readKey ()
    let keyPressedMsg = Msg.KeyPressed (keyInput.key, keyInput.modifiers, Stdlib.Option.Option.Some keyInput.keyChar)
    let newState = Update.updateAppState state keyPressedMsg
    runInteractiveLoop newState


let executeCliCommand (args: List<String>) : Int64 =
  let initialState = initState ()

  match args with
  // If someone runs `dark` without args, start the interactive loop
  | [] ->
    // Initialize status bar (sets up scroll region to reserve bottom line)
    StatusBar.init ()

    Stdlib.printLine (View.formatWelcome ())
    runInteractiveLoop initialState
  // Otherwise, just execute command, print result, and exit
  | _ ->
    let command = args |> Stdlib.String.join " "
    let finalState = Update.processInput initialState command
    0L

