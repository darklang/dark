module Darklang =
  module Cli =
    // ================================
    // TYPES - Core type definitions
    // ================================
    
    type Msg =
      | ProcessInput of String
      | KeyPressed of key: Stdlib.Cli.Stdin.Key.Key * modifiers: Stdlib.Cli.Stdin.Modifiers.Modifiers * keyChar: Stdlib.Option.Option<String>
      | Exit


    // CLEANUP ugh the tree stuff has bled into this... why?
    // we should refactor back to some Page situation
    // on most pages, we render the normal Prompt stuff
    // ... but not on all pages.

    // Page system - clean MVU architecture for different UI modes
    type Page =
      | MainPrompt        // Normal command prompt (default)
      | Experiments       // Experiments page for trying WIP features

    // Package path type is defined in Packages.Types module

    type AppState =
      { isExiting: Bool
        lastCommand: String
        output: String
        mainPrompt: String
        cursorPosition: Int64
        needsFullRedraw: Bool
        currentPath: Packages.Types.PackagePath
        pathHistory: List<Packages.Types.PackagePath>
        currentPage: Page
        commandHistory: List<String>
        historyIndex: Int64 }

    let initState () : AppState =
      AppState
        { isExiting = false
          lastCommand = ""
          output = ""
          mainPrompt = ""
          cursorPosition = 0L
          needsFullRedraw = true
          currentPath = []
          pathHistory = []
          currentPage = Page.MainPrompt  // Default to main prompt page
          commandHistory = []
          historyIndex = -1L }

    // Helper to update core state fields while preserving package navigation fields
    let updateCoreFields (state: AppState) (isExiting: Bool) (lastCommand: String) (output: String) (mainPrompt: String) (needsFullRedraw: Bool) : AppState =
      { state with
          isExiting = isExiting
          lastCommand = lastCommand
          output = output
          mainPrompt = mainPrompt
          needsFullRedraw = needsFullRedraw }


    // ================================
    // EXECUTION ERROR - Error handling
    // ================================
    
    module ExecutionError =
      // TODO migrate this to some ParseAndExecuteScript submodule
      type ExecutionError =
        { msg: String; metadata: Dict<String> }

      let toString (err: ExecutionError) : String =
        let metadataStr =
          err.metadata
          |> Stdlib.Dict.toList
          |> Stdlib.List.map (fun (k, v) -> $"- {k}: {v}")
          |> Stdlib.String.join "\n"
        $"Error: {err.msg}\n{metadataStr}"


    // ================================
    // COMPLETION - Tab completion logic
    // ================================
    
    module Completion =
      // Types for structured input parsing
      type ParsedInput =
        { commandName: String
          args: List<String>
          isCompletingCommand: Bool }

      // Parse an input string into structured form
      let parseInput (input: String) : ParsedInput =
        let trimmed = Stdlib.String.trim input

        if Stdlib.String.isEmpty trimmed then
          ParsedInput { commandName = ""; args = []; isCompletingCommand = true }
        else
          let words = Stdlib.String.split trimmed " "
          match words with
          | [] -> ParsedInput { commandName = ""; args = []; isCompletingCommand = true }
          | [command] -> ParsedInput { commandName = command; args = []; isCompletingCommand = true }
          | command :: args -> ParsedInput { commandName = command; args = args; isCompletingCommand = false }

      // Get the partial string being completed
      let getPartialCompletion (parsed: ParsedInput) : String =
        if parsed.isCompletingCommand then
          parsed.commandName
        else
          match Stdlib.List.last parsed.args with
          | Some lastArg -> lastArg
          | None -> ""

      // Build completed command string from parsed input and completion
      let buildCompletedCommand (parsed: ParsedInput) (completion: String) : String =
        if parsed.isCompletingCommand then
          completion
        else
          // Replace last argument with completion
          let argsWithoutLast = Stdlib.List.dropLast parsed.args
          let newArgs = Stdlib.List.append argsWithoutLast [completion]
          let fullCommand = Stdlib.List.append [parsed.commandName] newArgs
          Stdlib.String.join fullCommand " "

      // Generate completion hint from partial and completions
      let getHintFromCompletions (partial: String) (completions: List<String>) : String =
        match completions with
        | [] -> ""
        | [singleCompletion] ->
          if Stdlib.String.startsWith singleCompletion partial then
            Stdlib.String.dropFirst singleCompletion (Stdlib.String.length partial)
          else
            ""
        | multiple ->
          let commonPrefix = findCommonPrefix multiple
          if Stdlib.String.startsWith commonPrefix partial && Stdlib.String.length commonPrefix > Stdlib.String.length partial then
            Stdlib.String.dropFirst commonPrefix (Stdlib.String.length partial)
          else
            ""

      let noArgsCompletion (_state: AppState) (_args: List<String>) : List<String> =
        []

      // Standard completion for commands that complete with other command names
      // (right now, just `help`)
      let commandNamesCompletion (_state: AppState) (args: List<String>) : List<String> =
        match args with
        | [] ->
          // Suggest all command names and aliases
          let commands = Registry.allCommands ()
          let commandNames = Stdlib.List.map commands (fun cmd -> cmd.name)
          let allAliases = Stdlib.List.fold commands [] (fun acc cmd -> Stdlib.List.append acc cmd.aliases)
          Stdlib.List.append commandNames allAliases
        | [partialArg] ->
          // Filter by partial match
          let commands = Registry.allCommands ()
          let commandNames = Stdlib.List.map commands (fun cmd -> cmd.name)
          let allAliases = Stdlib.List.fold commands [] (fun acc cmd -> Stdlib.List.append acc cmd.aliases)
          let allOptions = Stdlib.List.append commandNames allAliases
          Stdlib.List.filter allOptions (fun name -> Stdlib.String.startsWith name partialArg)
        | _ ->
          // Only complete first argument
          []

      // Helper functions for finding common prefixes in completions
      let findCommonLength (str1: String) (str2: String) (index: Int64) (maxLen: Int64) : Int64 =
        if index >= maxLen then
          index
        else
          let char1 = Stdlib.String.slice str1 index (index + 1L)
          let char2 = Stdlib.String.slice str2 index (index + 1L)
          if char1 == char2 then
            findCommonLength str1 str2 (index + 1L) maxLen
          else
            index

      let findCommonPrefix (strings: List<String>) : String =
        match strings with
        | [] -> ""
        | [single] -> single
        | first :: rest ->
          Stdlib.List.fold rest first (fun acc next ->
            let maxLen = Stdlib.Int64.min (Stdlib.String.length acc) (Stdlib.String.length next)
            let commonLen = findCommonLength acc next 0L maxLen
            Stdlib.String.slice acc 0L commonLen)


    // ================================
    // VIEW - Display and formatting functions
    // ================================
    
    module View =
      let formatError (message: String) : String =
        Colors.error ("Error: " ++ message)

      let formatSuccess (message: String) : String =
        Colors.success message

      let formatPrompt () : String =
        "> "

      let formatPromptWithInput (state: AppState) : String =
        let currentPathStr = Colors.info (Packages.Path.formatPath state.currentPath)

        let hint = Registry.getCompletionHint state state.mainPrompt
        if Stdlib.String.isEmpty hint then
          currentPathStr ++ "> " ++ state.mainPrompt
        else
          currentPathStr ++ "> " ++ state.mainPrompt ++ (Colors.hint hint)

      let formatWelcome () : String =
        Registry.getCommandList () ++ "\n\nType 'help <command>' for specific command help."

      let formatGoodbye () : String =
        "Goodbye!"



    // ================================
    // REGISTRY - Command registry and execution
    // ================================
    
    module Registry =
      type CommandHandler =
        { name: String
          description: String
          aliases: List<String>
          execute: AppState -> List<String> -> AppState
          help: AppState -> AppState
          complete: AppState -> List<String> -> List<String> }

      let allCommands () : List<CommandHandler> =
        [ CommandHandler { name = "quit"; description = "Exit the CLI"; aliases = ["exit"]; execute = Quit.execute; help = Quit.help; complete = Quit.complete }
          CommandHandler { name = "help"; description = "Show help for commands"; aliases = ["commands"; "?"]; execute = Help.execute; help = Help.help; complete = Help.complete }
          CommandHandler { name = "install"; description = "Install CLI globally"; aliases = []; execute = Installation.Commands.executeInstall; help = Installation.Commands.installHelp; complete = Installation.Commands.installComplete }
          CommandHandler { name = "update"; description = "Update CLI to latest version"; aliases = ["upgrade"]; execute = Installation.Commands.executeUpdate; help = Installation.Commands.updateHelp; complete = Installation.Commands.updateComplete }
          CommandHandler { name = "uninstall"; description = "Remove CLI installation"; aliases = []; execute = Installation.Commands.executeUninstall; help = Installation.Commands.uninstallHelp; complete = Installation.Commands.uninstallComplete }
          CommandHandler { name = "status"; description = "Show installation status"; aliases = []; execute = Installation.Commands.executeStatus; help = Installation.Commands.statusHelp; complete = Installation.Commands.statusComplete }
          CommandHandler { name = "version"; description = "Display CLI version"; aliases = ["--version"; "-v"]; execute = Installation.Commands.executeVersion; help = Installation.Commands.versionHelp; complete = Installation.Commands.versionComplete }
          CommandHandler { name = "cd"; description = "Navigate to package or module"; aliases = []; execute = Packages.Navigation.executeCD; help = Packages.Navigation.cdHelp; complete = Packages.Navigation.cdComplete }
          CommandHandler { name = "ls"; description = "List package contents"; aliases = ["dir"]; execute = Packages.Listing.executeLS; help = Packages.Listing.lsHelp; complete = Packages.Listing.lsComplete }
          //CommandHandler { name = "pwd"; description = "Show current package path"; aliases = []; execute = Packages.Navigation.executePWD; help = Packages.Navigation.pwdHelp; complete = Packages.Navigation.pwdComplete }
          CommandHandler { name = "back"; description = "Go back to previous location"; aliases = []; execute = Packages.Navigation.executeBACK; help = Packages.Navigation.backHelp; complete = Packages.Navigation.backComplete }
          CommandHandler { name = "clear"; description = "Clear the screen"; aliases = ["cls"]; execute = Cli.Clear.execute; help = Cli.Clear.help; complete = Cli.Clear.complete }
          CommandHandler { name = "run"; description = "Run a function or script"; aliases = []; execute = Cli.Execution.executeRun; help = Cli.Execution.runHelp; complete = Cli.Execution.runComplete }
          CommandHandler { name = "eval"; description = "Evaluate a Dark expression"; aliases = []; execute = Cli.Execution.executeEval; help = Cli.Execution.evalHelp; complete = Cli.Execution.evalComplete }
          CommandHandler { name = "scripts"; description = "Store, manage, and run Dark scripts"; aliases = []; execute = Cli.Scripts.execute; help = Cli.Scripts.help; complete = Cli.Scripts.complete }
          CommandHandler { name = "view"; description = "View details of functions, types, constants, or modules"; aliases = []; execute = Packages.Viewing.executeView; help = Packages.Viewing.viewHelp; complete = Packages.Viewing.viewComplete }
          CommandHandler { name = "tree"; description = "Display package hierarchy in tree format"; aliases = []; execute = Packages.Tree.executeTree; help = Packages.Tree.treeHelp; complete = Packages.Tree.treeComplete }
          CommandHandler { name = "experiments"; description = "Try out various WIP CLI experiments"; aliases = []; execute = Cli.Experiments.execute; help = Cli.Experiments.help; complete = Cli.Experiments.complete } ]

      let findCommand (name: String) : CommandHandler =
        let commands = allCommands ()
        let nameMatches = Stdlib.List.filter commands (fun cmd -> cmd.name == name)
        let aliasMatches = Stdlib.List.filter commands (fun cmd ->
          match Stdlib.List.findFirst cmd.aliases (fun alias -> alias == name) with
          | Some _ -> true
          | None -> false)
        let allMatches = Stdlib.List.append nameMatches aliasMatches
        match allMatches with
        | [handler] -> handler
        | handler :: _ -> handler
        | [] ->
          CommandHandler
            { name = name
              description = "Unknown command"
              aliases = []
              execute = fun state args ->
                Builtin.printLine (View.formatError $"Unknown command: {name}")
                Builtin.printLine "Use 'help' to see available commands."
                { state with lastCommand = name; output = $"unknown command: {name}" }
              help = fun state ->
                Builtin.printLine $"No help available for command: {name}"
                { state with lastCommand = $"help {name}"; output = $"no help for {name}" }
              complete = fun state args -> [] }

      let executeCommand (name: String) (state: AppState) (args: List<String>) : AppState =
        let handler = findCommand name
        let ex = handler.execute
        ex state args

      let executeCommandHelp (name: String) (state: AppState) : AppState =
        let handler = findCommand name
        let help = handler.help
        help state

      // Helper function to format a group of commands
      let formatCommandGroup (groupName: String) (commandNames: List<String>) (commands: List<CommandHandler>) : String =
        let formattedCommands =
          commandNames
          |> Stdlib.List.filterMap (fun name ->
            match Stdlib.List.findFirst commands (fun cmd -> cmd.name == name) with
            | Some cmd ->
              match cmd.aliases with
              | [] -> Stdlib.Option.Option.Some $"  {cmd.name} - {cmd.description}"
              | aliases ->
                let aliasText = Stdlib.String.join aliases ", "
                Stdlib.Option.Option.Some $"  {cmd.name} ({aliasText}) - {cmd.description}"
            | None -> Stdlib.Option.Option.None)
        let commandLines = Stdlib.String.join formattedCommands "\n"
        $"{groupName}:\n{commandLines}"

      let getCommandList () : String =
        let commands = allCommands ()

        // Group commands by category
        let packageCommands = ["cd"; "ls"; "view"; "tree"; "pwd"; "back"]
        let executionCommands = ["run"; "eval"; "scripts"]
        let installCommands = ["install"; "update"; "uninstall"; "status"; "version"]
        let utilityCommands = ["clear"; "help"; "quit"; "experiments"]

        // Format command groups
        let packageGroup = formatCommandGroup "Packages" packageCommands commands
        let executionGroup = formatCommandGroup "Execution" executionCommands commands
        let installGroup = formatCommandGroup "Installation" installCommands commands
        let utilityGroup = formatCommandGroup "Utilities" utilityCommands commands

        // Find any ungrouped commands
        let allGroupedCommands = Stdlib.List.append (Stdlib.List.append (Stdlib.List.append packageCommands executionCommands) installCommands) utilityCommands
        let ungroupedCommands =
          commands
          |> Stdlib.List.filter (fun cmd ->
            match Stdlib.List.findFirst allGroupedCommands (fun name -> name == cmd.name) with
            | Some _ -> false
            | None -> true)
          |> Stdlib.List.map (fun cmd ->
            match cmd.aliases with
            | [] -> $"  {cmd.name} - {cmd.description}"
            | aliases ->
              let aliasText = Stdlib.String.join aliases ", "
              $"  {cmd.name} ({aliasText}) - {cmd.description}")

        let allGroups = [packageGroup; executionGroup; installGroup; utilityGroup]
        let finalGroups =
          if Stdlib.List.isEmpty ungroupedCommands then
            allGroups
          else
            let ungroupedGroup =
              let ungroupedLines = Stdlib.String.join ungroupedCommands "\n"
              $"Other:\n{ungroupedLines}"
            Stdlib.List.append allGroups [ungroupedGroup]

        let groupsText = Stdlib.String.join finalGroups "\n\n"
        let helpLines = Stdlib.String.split groupsText "\n"
        Logo.combineLogoAndText Logo.logo helpLines Colors.logoColor


      let getCompletions (state: AppState) (input: String) : List<String> =
        let parsed = Completion.parseInput input

        if parsed.isCompletingCommand then
          // Completing command name
          let partial = Completion.getPartialCompletion parsed
          let commands = allCommands ()
          let allNames = Stdlib.List.map commands (fun cmd -> cmd.name)
          let allAliases = Stdlib.List.fold commands [] (fun acc cmd -> Stdlib.List.append acc cmd.aliases)
          let allOptions = Stdlib.List.append allNames allAliases
          if Stdlib.String.isEmpty partial then
            allOptions
          else
            Stdlib.List.filter allOptions (fun name -> Stdlib.String.startsWith name partial)
        else
          // Completing command arguments
          let handler = findCommand parsed.commandName
          let completeFunc = handler.complete
          completeFunc state parsed.args

      let getCompletionHint (state: AppState) (input: String) : String =
        let parsed = Completion.parseInput input
        let completions = getCompletions state input
        let partial = Completion.getPartialCompletion parsed
        Completion.getHintFromCompletions partial completions


    // ================================
    // COMMANDS - Command parsing and execution
    // ================================
    
    module Commands =
      let parseAndExecute (state: AppState) (input: String) : AppState =
        let trimmed = Stdlib.String.trim input
        let parts = Stdlib.String.split trimmed " "
        match parts with
        | [] -> state
        | commandName :: args ->
          Registry.executeCommand commandName state args


    // ================================
    // UPDATE - State update and event handling
    // ================================
    
    let handleKeyInput (state: AppState) (key: Stdlib.Cli.Stdin.Key.Key) (modifiers: Stdlib.Cli.Stdin.Modifiers.Modifiers) (keyChar: Stdlib.Option.Option<String>) : AppState =
        match state.currentPage with
        | MainPrompt ->
          // Normal command mode key handling
          match key with
          | Enter ->
            // Execute the current command
            if Stdlib.String.isEmpty (Stdlib.String.trim state.mainPrompt) then
              Builtin.printLine ""
              { state with 
                  mainPrompt = ""
                  cursorPosition = 0L
                  needsFullRedraw = false
                  historyIndex = -1L }
            else
              Builtin.printLine ""
              let commandToExecute = Stdlib.String.trim state.mainPrompt
              let newState = Commands.parseAndExecute state commandToExecute
              // Add command to history (avoiding duplicates)
              let updatedHistory =
                if Stdlib.List.isEmpty state.commandHistory || Stdlib.List.head state.commandHistory != Stdlib.Option.Option.Some commandToExecute then
                  Stdlib.List.append [commandToExecute] state.commandHistory
                else
                  state.commandHistory
              { newState with 
                  mainPrompt = ""
                  cursorPosition = 0L
                  needsFullRedraw = false
                  commandHistory = updatedHistory
                  historyIndex = -1L }
          | Backspace ->
            // Remove character before cursor
            if state.cursorPosition > 0L then
              let beforeCursor = Stdlib.String.slice state.mainPrompt 0L (state.cursorPosition - 1L)
              let afterCursor = Stdlib.String.dropFirst state.mainPrompt state.cursorPosition
              let newPrompt = beforeCursor ++ afterCursor
              { state with 
                  mainPrompt = newPrompt
                  cursorPosition = state.cursorPosition - 1L
                  historyIndex = -1L
                  needsFullRedraw = false }
            else
              state
          | Tab ->
            // Handle tab completion
            let completions = Registry.getCompletions state state.mainPrompt

            match completions with
            | [] ->
              // No completions available
              state
            | [singleCompletion] ->
              // Single completion - auto-complete it
              let parsed = Completion.parseInput state.mainPrompt
              let newPrompt = Completion.buildCompletedCommand parsed singleCompletion
              let newPromptLength = Stdlib.String.length newPrompt
              { state with 
                  mainPrompt = newPrompt
                  cursorPosition = newPromptLength }
            | multiple ->
              // Multiple completions - show them
              Builtin.printLine ""
              Builtin.printLine (Stdlib.String.join multiple " ")
              { state with needsFullRedraw = true }
          | UpArrow ->
            // Navigate to previous command in history
            if Stdlib.Bool.not (Stdlib.List.isEmpty state.commandHistory) then
              let historyLength = Stdlib.List.length state.commandHistory
              let newIndex =
                if state.historyIndex == -1L then
                  0L  // Start from the most recent command
                else
                  if state.historyIndex < (historyLength - 1L) then
                    state.historyIndex + 1L
                  else
                    state.historyIndex  // Stay at oldest command
              match Stdlib.List.getAt state.commandHistory newIndex with
              | Some command ->
                let commandLength = Stdlib.String.length command
                { state with 
                    mainPrompt = command
                    cursorPosition = commandLength
                    historyIndex = newIndex
                    needsFullRedraw = false }
              | None ->
                state
            else
              state
          | DownArrow ->
            // Navigate to next command in history
            if Stdlib.Bool.not (Stdlib.List.isEmpty state.commandHistory) && state.historyIndex >= 0L then
              let newIndex =
                if state.historyIndex > 0L then
                  state.historyIndex - 1L
                else
                  -1L  // Go back to empty prompt
              if newIndex == -1L then
                { state with 
                    mainPrompt = ""
                    cursorPosition = 0L
                    historyIndex = newIndex
                    needsFullRedraw = false }
              else
                match Stdlib.List.getAt state.commandHistory newIndex with
                | Some command ->
                  let commandLength = Stdlib.String.length command
                  { state with 
                      mainPrompt = command
                      cursorPosition = commandLength
                      historyIndex = newIndex
                      needsFullRedraw = false }
                | None ->
                  state
            else
              state
          | LeftArrow ->
            // Move cursor left (cursor-only movement, no content change)
            let newCursorPos = Stdlib.Int64.max 0L (state.cursorPosition - 1L)
            { state with cursorPosition = newCursorPos; needsFullRedraw = false }
          | RightArrow ->
            // Move cursor right
            let promptLength = Stdlib.String.length state.mainPrompt
            let newCursorPos = Stdlib.Int64.min promptLength (state.cursorPosition + 1L)
            { state with cursorPosition = newCursorPos; needsFullRedraw = false }
          | Home ->
            // Move cursor to start of line
            { state with cursorPosition = 0L; needsFullRedraw = false }
          | End ->
            // Move cursor to end of line
            let promptLength = Stdlib.String.length state.mainPrompt
            { state with cursorPosition = promptLength; needsFullRedraw = false }
          | _ ->
            // Add character to prompt at cursor position
            match keyChar with
            | Some char ->
              let beforeCursor = Stdlib.String.slice state.mainPrompt 0L state.cursorPosition
              let afterCursor = Stdlib.String.dropFirst state.mainPrompt state.cursorPosition
              let newPrompt = beforeCursor ++ char ++ afterCursor
              { state with 
                  mainPrompt = newPrompt
                  cursorPosition = state.cursorPosition + (Stdlib.String.length char)
                  historyIndex = -1L
                  needsFullRedraw = false }
            | None ->
              state
        | Experiments ->
          // Experiments page key handling
          match key with
          | Escape ->
            // Exit experiments page back to main prompt
            { state with currentPage = Page.MainPrompt; needsFullRedraw = true }
          | _ ->
            // Ignore other keys in experiments mode
            state

    module Update =
      let updateAppState (state: AppState) (msg: Msg) : AppState =
        match msg with
        | ProcessInput input ->
          Commands.parseAndExecute state input
        | KeyPressed (key, modifiers, keyChar) ->
          handleKeyInput state key modifiers keyChar
        | Exit ->
          { state with isExiting = true; lastCommand = "exit"; output = "exiting" }

      let processInput (state: AppState) (input: String) : AppState =
        let trimmedInput = Stdlib.String.trim input
        if Stdlib.String.isEmpty trimmedInput then
          state
        else
          let msg = Msg.ProcessInput trimmedInput
          updateAppState state msg


    // ================================
    // CLI - Main CLI loop and command execution
    // ================================
    
    let runInteractiveLoop (state: AppState) : Int64 =
      if state.isExiting then
        0L
      else
        // Display current page
        match state.currentPage with
        | MainPrompt ->
          if state.needsFullRedraw then
            Builtin.printLine (View.formatPrompt ())
          else
            // For all interactive editing: clear line and reprint to avoid artifacts
            Builtin.print (Colors.carriageReturn ++ Colors.clearLine)
          
          Builtin.print (View.formatPromptWithInput state)
        | Experiments ->
          if state.needsFullRedraw then
            Builtin.printLine "ðŸ§ª Experiments Mode"
            Builtin.printLine ""
            Builtin.printLine "Try out various WIP CLI experiments here"
            Builtin.printLine ""
            Builtin.printLine "Press ESC to return to main prompt"

        // Read keystroke input
        let keyInput = Stdlib.Cli.Stdin.readKey ()
        let keyPressedMsg = Msg.KeyPressed (keyInput.key, keyInput.modifiers, Stdlib.Option.Option.Some keyInput.keyChar)
        let newState = Update.updateAppState state keyPressedMsg
        runInteractiveLoop newState


    let executeCliCommand (args: List<String>) : Int64 =
      let initialState = initState ()

      match args with
      // If someone runs `dark` without args, start the interactive loop
      | [] ->
        Builtin.printLine (View.formatWelcome ())
        runInteractiveLoop initialState
      // Otherwise, just execute command, print result, and exit
      | _ ->
        let command = args |> Stdlib.String.join " "
        let finalState = Update.processInput initialState command
        0L

