module Darklang.Cli.Scripts

type Script = {
  id: String
  name: String
  text: String
}

// Scripts command - manage and run stored Dark scripts
// TODO rename to just execute
let execute (state: AppState) (args: List<String>) : AppState =
  match args with
  | [] ->
    // CLEANUP defer to 'help' stuff -- consolidate
    [
      "Scripts commands:"
      "  scripts list               - List all scripts"
      "  scripts view <name>        - View script content"
      "  scripts add <name> <text>  - Add a new script"
      "  scripts edit <name>        - Show script content"
      "  scripts edit <name> <text> - Update script with new content"
      "  scripts delete <name>      - Delete a script"
      "  scripts run <name>         - Run a script"
    ] |> Stdlib.printLines
    state

  | ["list"] ->
    let scripts = Builtin.pmScriptsList ()
    if Stdlib.List.isEmpty scripts then
      Stdlib.printLine "No scripts found"
      state
    else
      let output =
        scripts
        |> Stdlib.List.map (fun s -> $"  {s.name}")
        |> Stdlib.String.join "\n"
      Stdlib.printLine $"Scripts:\n{output}"
      state

  | ["view"; name] ->
    match Builtin.pmScriptsGet name with
    | Some script ->
      let output = $"Script: {script.name}\n\n{script.text}"
      Stdlib.printLine output
      state
    | None ->
      let error = $"Script '{name}' not found"
      Stdlib.printLine $"Error: {error}"
      state

  | ["add"] ->
    [
      "Error: Missing arguments for scripts add"
      "Usage: scripts add <name> <text>"
      "Example: scripts add hello 'Stdlib.printLine \"Hello World\"'"
    ] |> Stdlib.printLines
    state

  | ["add"; _] ->
    [
      "Error: Missing script text"
      "Usage: scripts add <name> <text>"
      "Example: scripts add hello 'Stdlib.printLine \"Hello World\"'"
    ] |> Stdlib.printLines
    state

  | "add" :: name :: textParts when Stdlib.Bool.not (Stdlib.List.isEmpty textParts) ->
    let text = Stdlib.String.join textParts " "
    match Builtin.pmScriptsAdd name text with
    | Ok script ->
      let message = $"Script '{script.name}' added successfully"
      Stdlib.printLine message
      state
    | Error err ->
      Stdlib.printLine $"Error: {err}"
      state

  | ["edit"; name] ->
    match Builtin.pmScriptsGet name with
    | Some script ->
      [
        $"Current content of script '{name}':\n{script.text}"
        ""
        "Use 'scripts edit <name> <new_content>' to update the script"
      ] |> Stdlib.printLines
      state
    | None ->
      let error = $"Script '{name}' not found"
      Stdlib.printLine $"Error: {error}"
      state

  | "edit" :: name :: textParts when Stdlib.Bool.not (Stdlib.List.isEmpty textParts) ->
    let text = Stdlib.String.join textParts " "
    match Builtin.pmScriptsUpdate name text with
    | Ok () ->
      let message = $"Script '{name}' updated successfully"
      Stdlib.printLine message
      state
    | Error err ->
      Stdlib.printLine $"Error: {err}"
      state

  | ["delete"; name] ->
    match Builtin.pmScriptsDelete name with
    | Ok () ->
      let message = $"Script '{name}' deleted successfully"
      Stdlib.printLine message
      state
    | Error err ->
      Stdlib.printLine $"Error: {err}"
      state

  | ["run"; name] ->
    match Builtin.pmScriptsGet name with
    | Some script ->
      let result = Builtin.cliParseAndExecuteScript $"script:{name}" script.text []
      match result with
      | Ok exitCode ->
        let message = $"Script '{name}' executed with exit code: {Stdlib.Int64.toString exitCode}"
        Stdlib.printLine message
        state
      | Error runtimeError ->
        let prettyError = PrettyPrinter.RuntimeTypes.RuntimeError.toString runtimeError
        Stdlib.printLine $"Script error: {prettyError}"
        state
    | None ->
      let error = $"Script '{name}' not found"
      Stdlib.printLine $"Error: {error}"
      state

  | _ ->
    Stdlib.printLine "Error: Invalid scripts command. Use 'scripts' to see available commands"
    state



let complete (_state: AppState) (args: List<String>) : List<Completion.CompletionItem> =
  match args with
  // if hitting `tab` right after typing `scripts`, recommend subcommands
  | [] ->
    ["list"; "view"; "add"; "edit"; "delete"; "run"]
    |> Stdlib.List.map Completion.simple

  // no completions here
  | ["list"] | ["add"] -> []

  // we're referencing some specific script - recommend names
  | ["view"] | ["edit"] | ["delete"] | ["run"] ->
    // Complete script names
    let scripts = Builtin.pmScriptsList ()
    scripts
    |> Stdlib.List.map (fun s -> s.name)
    |> Stdlib.List.map Completion.simple

  | [subcommand] ->
    // Partial subcommand completion
    ["list"; "view"; "add"; "edit"; "delete"; "run"]
    |> Stdlib.List.filter (fun cmd -> Stdlib.String.startsWith cmd subcommand)
    |> Stdlib.List.map Completion.simple

  | ["view"; _] | ["delete"; _] | ["run"; _] ->
    // CLEANUP why are we ignoring them?
    // We should be recommending based on the names available
    []

  | ["edit"; _scriptName] ->
    // For edit with script name, could show current content hint but keep simple
    []

  | "add" :: _ | "edit" :: _ :: _ ->
    // For add or edit with content, no completion needed
    []

  | _ -> []


let help (state: AppState) : Unit =
  [
    "Usage: scripts <command> [args...]"
    "Store, manage, and run Dark scripts."
    ""
    "Commands:"
    "  scripts list               - List all scripts"
    "  scripts view <name>        - View script content"
    "  scripts add <name> <text>  - Add a new script"
    "  scripts edit <name>        - Show script content"
    "  scripts edit <name> <text> - Update script with new content"
    "  scripts delete <name>      - Delete a script"
    "  scripts run <name>         - Run a script"
    ""
    "Examples:"
    "  scripts add hello 'Stdlib.printLine \"Hello World\"'"
    "  scripts run hello"
    "  scripts edit hello 'Stdlib.printLine \"Updated Hello\"'"
  ] |> Stdlib.printLines