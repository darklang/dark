module Darklang.Cli.Docs.ForAI

let content () : String =
  """# Darklang AI Quick Reference

## IMPORTANT: Darklang is Different
Darklang is a LIVE PROGRAMMING ENVIRONMENT (like Smalltalk).
You don't write scripts - you build a persistent package tree.
- Use `fn` to CREATE functions in the tree (not eval)
- Use `run` to TEST those functions
- Use `commit` to SAVE your work
- CLI state doesn't persist between calls - the PACKAGE TREE does

## Workflow
  1. fn myFn        # create function (stored in package tree)
  2. run myFn       # test it
  3. status         # see changes
  4. commit "msg"   # save to SCM

## First Commands
  tree              # see package structure
  builtins          # list builtins
  search <term>     # find anything
  view <name>       # inspect entity

## Creating Code (use these, not eval!)
  fn <name>         # create function - MAIN WAY TO WRITE CODE
  type <name>       # create type
  val <name>        # create value

Names need full paths (owner.module.name), e.g.:
  fn "Darklang.Testing.fib (n: Int64): Int64 = ..."
Inside the body, use short names (e.g., `fib` for recursion).

## Running/Testing
  run <fn> [args]   # run a function you created
  eval <expr>       # quick test expressions (not for creating code)

## Navigation
  nav <path>        # go to module (cd)
  ls / back         # list / go back

## SCM (version control)
  status            # see current branch + uncommitted changes
  commit <msg>      # commit changes
  log               # history
  discard           # undo uncommitted changes

## Branches (use --branch flag!)
Branch context does NOT persist between CLI invocations.
Always pass --branch when working on non-main branches:

  dark branch create feature
  dark --branch feature fn "Darklang.Math.fib ..."
  dark --branch feature status
  dark --branch feature commit "done"
  dark --branch feature rebase
  dark --branch feature merge

Without --branch, commands run on main.
  (see: docs scm)

## Name Resolution
Names resolve relative to the current module, searching from
most-specific to least-specific.

In `module Darklang.Stdlib.List`, writing `Option.Option` tries:
  1. Darklang.Stdlib.List.Option.Option
  2. Darklang.Stdlib.Option.Option   <-- found here
  3. Darklang.Option.Option
  4. Option.Option

Rules:
  - Same module: no qualifier needed
    (in Darklang.Stdlib.List, `map` finds Darklang.Stdlib.List.map)
  - Parent/sibling modules: use relative name
    (in Darklang.Stdlib.List, `Option.Option` finds
     Darklang.Stdlib.Option.Option)
  - `Stdlib.X` shortcut: always expands to `Darklang.Stdlib.X`
    (works from any module, even outside Darklang)
  - `Builtin.X`: resolves to F# builtins (fns/values only, not types)
  - Cross-owner: must use full path
    (from Tests.*, write `Darklang.SCM.Branch.mainBranchId`)

## Critical Syntax
- Whitespace-sensitive (like Python)
- NO nested function definitions
- Pipe needs parens: (complex expr) |> fn
- Lists: [1L; 2L; 3L] (semicolons)
- String concat: ++ (not @)
- Int division: Stdlib.Int64.divide (not /)

## Records
  MyRecord { a = 1L; b = 2L }
  # { must not be left of type name

## Enums
  Option.Some 5L      # construct: TypeName.Case
  | Some x -> ...     # match: just Case

## Troubleshooting
If commands hang or fail silently, check logs:
  rundir/logs/cli.log    # main CLI log
  rundir/logs/           # other logs

## More: docs syntax|types|operators|stdlib|errors|cli|scm"""
