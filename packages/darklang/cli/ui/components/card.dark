module Darklang.CLI.UI.Components.Card

// Border characters type
type BorderChars =
  { top: String
    bottom: String
    left: String
    right: String
    topRight: String
    bottomRight: String
    horizontal: String }

// Card Component
type CardModel =
  { title: String
    subtitle: String
    content: List<String>
    footer: List<String>
    headerColor: Core.Types.Color
    borderColor: Core.Types.Color
    width: Int64
    height: Int64
    hasShadow: Bool
    isRounded: Bool }

let createCard (title: String) (content: List<String>) (width: Int64) (height: Int64) : Core.Types.Component<CardModel> =
  let model = CardModel { title = title; subtitle = ""; content = content; footer = []; headerColor = Core.Types.Color.Default; borderColor = Core.Types.Color.Default; width = width; height = height; hasShadow = false; isRounded = false }
  let bounds = Core.Types.Bounds { position = Core.Types.Position { x = 0L; y = 0L }; dimensions = Core.Types.Dimensions { width = width; height = height } }
  Core.Types.Component
    { id = "card-" ++ title
      model = model
      state = Core.Types.ComponentState.Normal
      bounds = bounds
      visible = true
      focusable = false }

let renderCard (component: Core.Types.Component<CardModel>) (context: Core.Types.RenderContext) : List<String> =
  let model = component.model
  let hasFocus = context.hasFocus && component.state == Core.Types.ComponentState.Focused

  let top = if model.isRounded then "â•­" else "â”Œ"
  let bottom = if model.isRounded then "â•°" else "â””"
  let left = "â”‚"
  let right = "â”‚"
  let topRight = if model.isRounded then "â•®" else "â”"
  let bottomRight = if model.isRounded then "â•¯" else "â”˜"
  let horizontal = "â”€"

  // Create header section
  let headerLines =
    if Stdlib.String.isEmpty model.title && Stdlib.String.isEmpty model.subtitle then
      []
    else
      let innerWidth = model.width - 4L

      let titleLine =
        if Stdlib.String.isEmpty model.title then
          ""
        else
          // Calculate padding based on raw text, then apply styling
          let titleLen = Stdlib.String.length model.title
          let rightPad = if innerWidth > titleLen then Stdlib.String.repeat " " (innerWidth - titleLen) else ""
          let styledTitle = Core.Rendering.colorize model.headerColor (Core.Rendering.bold model.title)
          left ++ " " ++ styledTitle ++ rightPad ++ " " ++ right

      let subtitleLine =
        if Stdlib.String.isEmpty model.subtitle then
          ""
        else
          let paddedSubtitle = Core.Rendering.padText model.subtitle innerWidth Core.Types.Alignment.Left
          left ++ " " ++ paddedSubtitle ++ " " ++ right

      let headerSeparator = left ++ Stdlib.String.repeat horizontal (model.width - 2L) ++ right

      [titleLine; subtitleLine; headerSeparator]
      |> Stdlib.List.filter (fun line -> Stdlib.Bool.not (Stdlib.String.isEmpty line))

  // Create content section
  let contentLines =
    let maxContentHeight = model.height - 2L - Stdlib.List.length headerLines - Stdlib.List.length model.footer
    let paddedContent =
      model.content
      |> Stdlib.List.take maxContentHeight
      |> Stdlib.List.map (fun line ->
          let truncatedLine = Core.Rendering.truncateText line (model.width - 4L)
          let paddedLine = Core.Rendering.padText truncatedLine (model.width - 4L) Core.Types.Alignment.Left
          left ++ " " ++ paddedLine ++ " " ++ right)

    let remainingHeight = maxContentHeight - Stdlib.List.length paddedContent
    let emptyLines =
      if remainingHeight > 0L then
        let emptyLine = left ++ Stdlib.String.repeat " " (model.width - 2L) ++ right
        match Stdlib.List.repeat remainingHeight emptyLine with
        | Ok lines -> lines
        | Error _ -> []
      else
        []

    paddedContent
    |> Stdlib.List.append emptyLines

  // Create footer section
  let footerLines =
    if Stdlib.List.isEmpty model.footer then
      []
    else
      let footerSeparator = left ++ (Stdlib.String.repeat horizontal (model.width - 2L)) ++ right
      let footerContent =
        model.footer
        |> Stdlib.List.map (fun line ->
            let paddedLine = Core.Rendering.padText line (model.width - 4L) Core.Types.Alignment.Left
            left ++ " " ++ paddedLine ++ " " ++ right)

      [footerSeparator]
      |> Stdlib.List.append footerContent

  // Create borders
  let topBorder =
    if Stdlib.List.isEmpty headerLines then
      top ++ (Stdlib.String.repeat horizontal (model.width - 2L)) ++ topRight
    else
      top ++ (Stdlib.String.repeat horizontal (model.width - 2L)) ++ topRight

  let bottomBorder = bottom ++ (Stdlib.String.repeat horizontal (model.width - 2L)) ++ bottomRight

  // Combine all sections
  let cardContent =
    [topBorder]
    |> Stdlib.List.append headerLines
    |> Stdlib.List.append contentLines
    |> Stdlib.List.append footerLines
    |> Stdlib.List.append [bottomBorder]

  // Apply shadow effect if enabled
  if model.hasShadow then
    let shadowedContent =
      cardContent
      |> Stdlib.List.indexedMap (fun i line ->
          if i == Stdlib.List.length cardContent - 1L then
            line ++ " " ++ (Core.Rendering.dim (Stdlib.String.repeat "â–„" (model.width - 1L)))
          else
            line ++ Core.Rendering.dim "â–Œ")

    let shadowBottom = " " ++ (Core.Rendering.dim (Stdlib.String.repeat "â–€" model.width))
    shadowedContent
    |> Stdlib.List.append [shadowBottom]
  else
    cardContent

let setCardTitle (component: Core.Types.Component<CardModel>) (title: String) : Core.Types.Component<CardModel> =
  let model = component.model
  { component with model = { model with title = title } }

let setCardSubtitle (component: Core.Types.Component<CardModel>) (subtitle: String) : Core.Types.Component<CardModel> =
  let model = component.model
  { component with model = { model with subtitle = subtitle } }

let setCardContent (component: Core.Types.Component<CardModel>) (content: List<String>) : Core.Types.Component<CardModel> =
  let model = component.model
  { component with model = { model with content = content } }

let setCardFooter (component: Core.Types.Component<CardModel>) (footer: List<String>) : Core.Types.Component<CardModel> =
  let model = component.model
  { component with model = { model with footer = footer } }

let setCardColors (component: Core.Types.Component<CardModel>) (headerColor: Core.Types.Color) (borderColor: Core.Types.Color) : Core.Types.Component<CardModel> =
  let model = component.model
  { component with model = { model with headerColor = headerColor; borderColor = borderColor } }

let enableCardShadow (component: Core.Types.Component<CardModel>) : Core.Types.Component<CardModel> =
  let model = component.model
  { component with model = { model with hasShadow = true } }

let enableCardRounding (component: Core.Types.Component<CardModel>) : Core.Types.Component<CardModel> =
  let model = component.model
  { component with model = { model with isRounded = true } }

// Media Card Component (for cards with image/media content)
type MediaCardModel =
  { title: String
    description: String
    mediaPlaceholder: String
    mediaWidth: Int64
    mediaHeight: Int64
    actions: List<String>
    width: Int64
    height: Int64 }

let createMediaCard (title: String) (description: String) (mediaWidth: Int64) (mediaHeight: Int64) : Core.Types.Component<MediaCardModel> =
  let totalWidth = mediaWidth + 4L
  let totalHeight = mediaHeight + 6L
  let model = MediaCardModel { title = title; description = description; mediaPlaceholder = "ðŸ“·"; mediaWidth = mediaWidth; mediaHeight = mediaHeight; actions = []; width = totalWidth; height = totalHeight }
  let bounds = Core.Types.Bounds { position = Core.Types.Position { x = 0L; y = 0L }; dimensions = Core.Types.Dimensions { width = totalWidth; height = totalHeight } }
  Core.Types.Component
    { id = "mediacard-" ++ title
      model = model
      state = Core.Types.ComponentState.Normal
      bounds = bounds
      visible = true
      focusable = false }

let renderMediaCard (component: Core.Types.Component<MediaCardModel>) (context: Core.Types.RenderContext) : List<String> =
  let model = component.model

  let topBorder = "â”Œ" ++ (Stdlib.String.repeat "â”€" (model.width - 2L)) ++ "â”"
  let bottomBorder = "â””" ++ (Stdlib.String.repeat "â”€" (model.width - 2L)) ++ "â”˜"

  // Create media placeholder
  let mediaLines =
    let centerY = Stdlib.Int64.divide model.mediaHeight 2L
    (Stdlib.List.range 0L model.mediaHeight)
    |> Stdlib.List.map (fun i ->
        if i == centerY then
          let centeredPlaceholder = Core.Rendering.padText model.mediaPlaceholder model.mediaWidth Core.Types.Alignment.Center
          let borderedLine = Core.Rendering.padText centeredPlaceholder (model.width - 4L) Core.Types.Alignment.Center
          "â”‚ " ++ borderedLine ++ " â”‚"
        else
          let emptyLine = Stdlib.String.repeat " " (model.width - 4L)
          "â”‚ " ++ emptyLine ++ " â”‚")

  // Create title and description
  let titleLine =
    let styledTitle = Core.Rendering.bold model.title
    let paddedTitle = Core.Rendering.padText styledTitle (model.width - 4L) Core.Types.Alignment.Left
    "â”‚ " ++ paddedTitle ++ " â”‚"

  let descLine =
    let paddedDesc = Core.Rendering.padText model.description (model.width - 4L) Core.Types.Alignment.Left
    "â”‚ " ++ paddedDesc ++ " â”‚"

  let separatorLine = "â”œ" ++ (Stdlib.String.repeat "â”€" (model.width - 2L)) ++ "â”¤"

  // Create actions if any
  let actionLines =
    if Stdlib.List.isEmpty model.actions then
      []
    else
      let actionText = Stdlib.String.join " | " model.actions
      let paddedActions = Core.Rendering.padText actionText (model.width - 4L) Core.Types.Alignment.Center
      ["â”‚ " ++ paddedActions ++ " â”‚"]

  [topBorder]
  |> Stdlib.List.append mediaLines
  |> Stdlib.List.append [separatorLine; titleLine; descLine]
  |> Stdlib.List.append actionLines
  |> Stdlib.List.append [bottomBorder]

let setMediaCardActions (component: Core.Types.Component<MediaCardModel>) (actions: List<String>) : Core.Types.Component<MediaCardModel> =
  let model = component.model
  { component with model = { model with actions = actions } }