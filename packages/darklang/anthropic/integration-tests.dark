/// Anthropic API Integration Tests
/// These tests make REAL API calls and require ANTHROPIC_API_KEY to be set.
///
/// After setting the env var, run with:
///   ./scripts/run-cli eval "Darklang.Anthropic.IntegrationTests.runAllTests ()"

/// Note: The batch results test polls for up to 60 seconds, so the full suite may take a few minutes.
module Darklang.Anthropic.IntegrationTests

type Json = Stdlib.AltJson.Json


type TestResult =
  | Pass
  | Fail of message: String
  | Skipped of reason: String

type TestFunction = Unit -> TestResult


// =============================================================================
// HELPER: Get API Key
// =============================================================================

let getApiKey () : Stdlib.Option.Option<String> =
  Stdlib.Env.get "ANTHROPIC_API_KEY"


// =============================================================================
// DIRECT API TESTS
// =============================================================================

module DirectApiTests =

  /// Test direct Chat.Request.send
  let testDirectChatSend () : TestResult =
    match getApiKey () with
    | None -> TestResult.Skipped "ANTHROPIC_API_KEY not set"
    | Some apiKey ->
      let req =
        (Darklang.Anthropic.Chat.Request.create ())
        |> Darklang.Anthropic.Chat.Request.withModel Darklang.Anthropic.Models.Model.Haiku35
        |> Darklang.Anthropic.Chat.Request.withMaxTokens 50L
        |> Darklang.Anthropic.Chat.Request.withUserMessage "Say 'test passed'"

      match Darklang.Anthropic.Chat.Request.send apiKey req with
      | Ok response ->
        let text = Darklang.Anthropic.Response.getText response
        if Stdlib.String.length text > 0L then
          TestResult.Pass
        else
          TestResult.Fail "Empty response text"
      | Error e ->
        TestResult.Fail $"API error: {Darklang.Anthropic.Response.ApiError.toString e}"

  /// Test response parsing
  let testResponseParsing () : TestResult =
    match getApiKey () with
    | None -> TestResult.Skipped "ANTHROPIC_API_KEY not set"
    | Some apiKey ->
      let req =
        (Darklang.Anthropic.Chat.Request.create ())
        |> Darklang.Anthropic.Chat.Request.withModel Darklang.Anthropic.Models.Model.Haiku35
        |> Darklang.Anthropic.Chat.Request.withMaxTokens 50L
        |> Darklang.Anthropic.Chat.Request.withUserMessage "Reply with: hello"

      match Darklang.Anthropic.Chat.Request.send apiKey req with
      | Ok response ->
        let hasStopReason =
          match Darklang.Anthropic.Response.getStopReason response with
          | Some _ -> true
          | None -> false
        let hasUsage = response.usage.input_tokens > 0L
        let isComplete = Darklang.Anthropic.Response.isComplete response

        if hasStopReason && hasUsage && isComplete then
          TestResult.Pass
        else
          TestResult.Fail $"Missing expected response fields. StopReason: {hasStopReason}, Usage: {hasUsage}, Complete: {isComplete}"
      | Error e ->
        TestResult.Fail $"API error: {Darklang.Anthropic.Response.ApiError.toString e}"

  let allTests () : List<String * TestFunction> =
    [ ("Direct API: Chat.Request.send", fun () -> testDirectChatSend ())
      ("Direct API: response parsing", fun () -> testResponseParsing ()) ]


// =============================================================================
// TOKEN COUNTING TESTS
// =============================================================================

module TokenCountingTests =

  /// Test basic token counting
  let testCountTokens () : TestResult =
    match getApiKey () with
    | None -> TestResult.Skipped "ANTHROPIC_API_KEY not set"
    | Some apiKey ->
      let req =
        (Darklang.Anthropic.Chat.Request.create ())
        |> Darklang.Anthropic.Chat.Request.withUserMessage "Hello, how are you today?"

      match Darklang.Anthropic.Chat.countTokens apiKey req with
      | Ok result ->
        if result.input_tokens > 0L then
          TestResult.Pass
        else
          TestResult.Fail $"Expected positive token count, got {result.input_tokens}"
      | Error e ->
        TestResult.Fail $"Token count error: {Darklang.Anthropic.Response.ApiError.toString e}"

  /// Test token counting for prompt convenience function
  let testCountTokensForPrompt () : TestResult =
    match getApiKey () with
    | None -> TestResult.Skipped "ANTHROPIC_API_KEY not set"
    | Some apiKey ->
      match Darklang.Anthropic.Chat.countTokensForPrompt apiKey "What is 2+2?" with
      | Ok result ->
        if result.input_tokens > 0L then
          TestResult.Pass
        else
          TestResult.Fail "Expected positive token count"
      | Error e ->
        TestResult.Fail $"Token count error: {Darklang.Anthropic.Response.ApiError.toString e}"

  /// Test that longer prompts have more tokens
  let testTokenCountScaling () : TestResult =
    match getApiKey () with
    | None -> TestResult.Skipped "ANTHROPIC_API_KEY not set"
    | Some apiKey ->
      let shortPrompt = "Hi"
      let longPrompt = "This is a much longer prompt that should have significantly more tokens than the short one above."

      match Darklang.Anthropic.Chat.countTokensForPrompt apiKey shortPrompt with
      | Ok shortResult ->
        match Darklang.Anthropic.Chat.countTokensForPrompt apiKey longPrompt with
        | Ok longResult ->
          if longResult.input_tokens > shortResult.input_tokens then
            TestResult.Pass
          else
            TestResult.Fail $"Expected long prompt ({longResult.input_tokens}) > short prompt ({shortResult.input_tokens})"
        | Error e -> TestResult.Fail $"Long prompt error: {Darklang.Anthropic.Response.ApiError.toString e}"
      | Error e -> TestResult.Fail $"Short prompt error: {Darklang.Anthropic.Response.ApiError.toString e}"

  let allTests () : List<String * TestFunction> =
    [ ("TokenCounting: basic count", fun () -> testCountTokens ())
      ("TokenCounting: countTokensForPrompt", fun () -> testCountTokensForPrompt ())
      ("TokenCounting: scaling", fun () -> testTokenCountScaling ()) ]


// =============================================================================
// JSON SCHEMA OUTPUT TESTS
// =============================================================================

module JsonSchemaTests =

  /// Test JSON schema structured output
  let testJsonSchemaOutput () : TestResult =
    match getApiKey () with
    | None -> TestResult.Skipped "ANTHROPIC_API_KEY not set"
    | Some apiKey ->
      // Define a simple schema for a person (must have additionalProperties: false)
      let schema =
        Json.Object
          [ ("type", Json.String "object")
            ("properties",
             Json.Object
               [ ("name", Json.Object [ ("type", Json.String "string") ])
                 ("age", Json.Object [ ("type", Json.String "integer") ]) ])
            ("required", Json.Array [ Json.String "name"; Json.String "age" ])
            ("additionalProperties", Json.Bool false) ]

      let req =
        (Darklang.Anthropic.Chat.Request.create ())
        |> Darklang.Anthropic.Chat.Request.withModel Darklang.Anthropic.Models.Model.Sonnet45
        |> Darklang.Anthropic.Chat.Request.withMaxTokens 200L
        |> Darklang.Anthropic.Chat.Request.withJsonSchema schema
        |> Darklang.Anthropic.Chat.Request.withUserMessage "Generate a JSON object for a person named Alice who is 30 years old."

      match Darklang.Anthropic.Chat.Request.send apiKey req with
      | Ok response ->
        let text = Darklang.Anthropic.Response.getText response
        // Check that response contains expected JSON structure indicators
        if Stdlib.String.contains text "Alice" && Stdlib.String.contains text "30" then
          TestResult.Pass
        else
          TestResult.Fail $"Expected JSON with Alice and 30: {text}"
      | Error e ->
        TestResult.Fail $"API error: {Darklang.Anthropic.Response.ApiError.toString e}"

  let allTests () : List<String * TestFunction> =
    [ ("JsonSchema: structured output", fun () -> testJsonSchemaOutput ()) ]


// =============================================================================
// STOP SEQUENCES TESTS
// =============================================================================

module StopSequenceTests =

  /// Test that generation stops at specified sequence
  let testStopSequence () : TestResult =
    match getApiKey () with
    | None -> TestResult.Skipped "ANTHROPIC_API_KEY not set"
    | Some apiKey ->
      let req =
        (Darklang.Anthropic.Chat.Request.create ())
        |> Darklang.Anthropic.Chat.Request.withModel Darklang.Anthropic.Models.Model.Haiku35
        |> Darklang.Anthropic.Chat.Request.withMaxTokens 100L
        |> Darklang.Anthropic.Chat.Request.withStopSequences [ "STOP" ]
        |> Darklang.Anthropic.Chat.Request.withUserMessage "Count from 1 to 10, then write STOP, then continue to 20."

      match Darklang.Anthropic.Chat.Request.send apiKey req with
      | Ok response ->
        // Check stop reason is stop_sequence
        match Darklang.Anthropic.Response.getStopReason response with
        | Some reason ->
          if reason == Darklang.Anthropic.Response.StopReason.StopSequence then
            TestResult.Pass
          else
            // Model might not always trigger stop sequence, but response should not contain numbers after STOP
            let text = Darklang.Anthropic.Response.getText response
            if Stdlib.String.contains text "11" || Stdlib.String.contains text "12" then
              TestResult.Fail $"Expected to stop before 11/12: {text}"
            else
              TestResult.Pass
        | None ->
          TestResult.Fail "No stop reason returned"
      | Error e ->
        TestResult.Fail $"API error: {Darklang.Anthropic.Response.ApiError.toString e}"

  let allTests () : List<String * TestFunction> =
    [ ("StopSequence: stops at sequence", fun () -> testStopSequence ()) ]


// =============================================================================
// SERVER TOOLS TESTS (Code Execution, Bash, Text Editor)
// =============================================================================

module ServerToolTests =

  /// Test code execution server tool
  let testCodeExecution () : TestResult =
    match getApiKey () with
    | None -> TestResult.Skipped "ANTHROPIC_API_KEY not set"
    | Some apiKey ->
      let codeExecTool = Darklang.Anthropic.Tools.codeExecutionTool ()
      let toolJson = Darklang.Anthropic.Tools.codeExecutionToJson codeExecTool

      let req =
        (Darklang.Anthropic.Chat.Request.create ())
        |> Darklang.Anthropic.Chat.Request.withModel Darklang.Anthropic.Models.Model.Sonnet45
        |> Darklang.Anthropic.Chat.Request.withMaxTokens 1000L
        |> Darklang.Anthropic.Chat.Request.withToolsJson [ toolJson ]
        |> Darklang.Anthropic.Chat.Request.withUserMessage "Use code execution to calculate 15 * 23 and tell me the result."

      match Darklang.Anthropic.Chat.Request.send apiKey req with
      | Ok response ->
        // Check if tool was used or we got a response
        let hasToolUse = Darklang.Anthropic.Response.hasToolUse response
        let text = Darklang.Anthropic.Response.getText response
        if hasToolUse || Stdlib.String.contains text "345" then
          TestResult.Pass
        else
          // Code execution might not always be triggered
          if Stdlib.String.length text > 0L then
            TestResult.Pass
          else
            TestResult.Fail "No tool use and no response"
      | Error e ->
        TestResult.Fail $"API error: {Darklang.Anthropic.Response.ApiError.toString e}"

  /// Test bash server tool
  let testBashTool () : TestResult =
    match getApiKey () with
    | None -> TestResult.Skipped "ANTHROPIC_API_KEY not set"
    | Some apiKey ->
      let bashTool = Darklang.Anthropic.Tools.bashTool ()
      let toolJson = Darklang.Anthropic.Tools.bashToJson bashTool

      let req =
        (Darklang.Anthropic.Chat.Request.create ())
        |> Darklang.Anthropic.Chat.Request.withModel Darklang.Anthropic.Models.Model.Sonnet45
        |> Darklang.Anthropic.Chat.Request.withMaxTokens 1000L
        |> Darklang.Anthropic.Chat.Request.withToolsJson [ toolJson ]
        |> Darklang.Anthropic.Chat.Request.withUserMessage "Use the bash tool to run 'echo hello' and tell me the output."

      match Darklang.Anthropic.Chat.Request.send apiKey req with
      | Ok response ->
        let hasToolUse = Darklang.Anthropic.Response.hasToolUse response
        let text = Darklang.Anthropic.Response.getText response
        if hasToolUse || Stdlib.String.length text > 0L then
          TestResult.Pass
        else
          TestResult.Fail "No tool use and no response"
      | Error e ->
        // Bash tool might require specific beta access
        let errStr = Darklang.Anthropic.Response.ApiError.toString e
        if Stdlib.String.contains errStr "beta" || Stdlib.String.contains errStr "access" then
          TestResult.Skipped "Bash tool not available"
        else
          TestResult.Fail $"API error: {errStr}"

  /// Test text editor server tool
  let testTextEditorTool () : TestResult =
    match getApiKey () with
    | None -> TestResult.Skipped "ANTHROPIC_API_KEY not set"
    | Some apiKey ->
      let textEditorTool = Darklang.Anthropic.Tools.textEditorTool ()
      let toolJson = Darklang.Anthropic.Tools.textEditorToJson textEditorTool

      let req =
        (Darklang.Anthropic.Chat.Request.create ())
        |> Darklang.Anthropic.Chat.Request.withModel Darklang.Anthropic.Models.Model.Sonnet45
        |> Darklang.Anthropic.Chat.Request.withMaxTokens 1000L
        |> Darklang.Anthropic.Chat.Request.withToolsJson [ toolJson ]
        |> Darklang.Anthropic.Chat.Request.withUserMessage "Use the text editor to view the contents of /etc/hostname"

      match Darklang.Anthropic.Chat.Request.send apiKey req with
      | Ok response ->
        let hasToolUse = Darklang.Anthropic.Response.hasToolUse response
        let text = Darklang.Anthropic.Response.getText response
        if hasToolUse || Stdlib.String.length text > 0L then
          TestResult.Pass
        else
          TestResult.Fail "No tool use and no response"
      | Error e ->
        // Text editor tool might require specific beta access
        let errStr = Darklang.Anthropic.Response.ApiError.toString e
        if Stdlib.String.contains errStr "beta" || Stdlib.String.contains errStr "access" then
          TestResult.Skipped "Text editor tool not available"
        else
          TestResult.Fail $"API error: {errStr}"

  let allTests () : List<String * TestFunction> =
    [ ("ServerTools: code execution", fun () -> testCodeExecution ())
      ("ServerTools: bash", fun () -> testBashTool ())
      ("ServerTools: text editor", fun () -> testTextEditorTool ()) ]


// =============================================================================
// WEB FETCH TESTS
// =============================================================================

module WebFetchTests =

  /// Test web fetch server tool
  let testWebFetch () : TestResult =
    match getApiKey () with
    | None -> TestResult.Skipped "ANTHROPIC_API_KEY not set"
    | Some apiKey ->
      let webFetchTool = Darklang.Anthropic.Tools.webFetchTool ()
      let toolJson = Darklang.Anthropic.Tools.webFetchToJson webFetchTool

      let req =
        (Darklang.Anthropic.Chat.Request.create ())
        |> Darklang.Anthropic.Chat.Request.withModel Darklang.Anthropic.Models.Model.Sonnet45
        |> Darklang.Anthropic.Chat.Request.withMaxTokens 1000L
        |> Darklang.Anthropic.Chat.Request.withToolsJson [ toolJson ]
        |> Darklang.Anthropic.Chat.Request.withUserMessage "Fetch the content from https://example.com and summarize it."

      match Darklang.Anthropic.Chat.Request.send apiKey req with
      | Ok response ->
        let hasToolUse = Darklang.Anthropic.Response.hasToolUse response
        let text = Darklang.Anthropic.Response.getText response
        // Either tool was called or we got a text response
        if hasToolUse || Stdlib.String.length text > 0L then
          TestResult.Pass
        else
          TestResult.Fail "No tool use and no response"
      | Error e ->
        TestResult.Fail $"API error: {Darklang.Anthropic.Response.ApiError.toString e}"

  /// Test web fetch with citations - verify typed citations are returned
  let testWebFetchWithCitations () : TestResult =
    match getApiKey () with
    | None -> TestResult.Skipped "ANTHROPIC_API_KEY not set"
    | Some apiKey ->
      let webFetchTool = Darklang.Anthropic.Tools.webFetchToolWithCitations ()
      let toolJson = Darklang.Anthropic.Tools.webFetchToJson webFetchTool

      let req =
        (Darklang.Anthropic.Chat.Request.create ())
        |> Darklang.Anthropic.Chat.Request.withModel Darklang.Anthropic.Models.Model.Sonnet45
        |> Darklang.Anthropic.Chat.Request.withMaxTokens 1000L
        |> Darklang.Anthropic.Chat.Request.withToolsJson [ toolJson ]
        |> Darklang.Anthropic.Chat.Request.withUserMessage "Fetch https://example.com and tell me the title. Include a citation."

      match Darklang.Anthropic.Chat.Request.send apiKey req with
      | Ok response ->
        // Verify we get a response
        let hasContent =
          Stdlib.String.length (Darklang.Anthropic.Response.getText response) > 0L ||
          Darklang.Anthropic.Response.hasToolUse response
        if hasContent then
          // If citations are present, verify they're typed correctly
          let citations = Darklang.Anthropic.Response.extractCitations response
          if Stdlib.List.isEmpty citations then
            // Citations may not always be returned, that's OK
            TestResult.Pass
          else
            // Verify citations are properly typed (not raw JSON)
            let firstCitation = Stdlib.List.head citations
            match firstCitation with
            | Some c ->
              // Check that cited_text field exists (proves it's a typed Citation)
              if Stdlib.String.length c.cited_text >= 0L then
                TestResult.Pass
              else
                TestResult.Fail "Citation missing cited_text"
            | None -> TestResult.Pass
        else
          TestResult.Fail "No response"
      | Error e ->
        TestResult.Fail $"API error: {Darklang.Anthropic.Response.ApiError.toString e}"

  let allTests () : List<String * TestFunction> =
    [ ("WebFetch: basic fetch", fun () -> testWebFetch ())
      ("WebFetch: with citations", fun () -> testWebFetchWithCitations ()) ]


// =============================================================================
// VISION / IMAGE INPUT TESTS
// =============================================================================

module VisionTests =

  /// Test image input with a small base64 image (1x1 red pixel PNG)
  let testImageInput () : TestResult =
    match getApiKey () with
    | None -> TestResult.Skipped "ANTHROPIC_API_KEY not set"
    | Some apiKey ->
      // 1x1 red pixel PNG in base64
      let redPixelPng = "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8DwHwAFBQIAX8jx0gAAAABJRU5ErkJggg=="

      let imageBlock = Darklang.Anthropic.Content.imageBlockBase64 "image/png" redPixelPng
      let textBlock = Darklang.Anthropic.Content.textBlock "What color is this image? Reply with just the color name."

      let userMessage =
        Darklang.Anthropic.Content.userBlockMessage [ imageBlock; textBlock ]

      let req =
        (Darklang.Anthropic.Chat.Request.create ())
        |> Darklang.Anthropic.Chat.Request.withModel Darklang.Anthropic.Models.Model.Sonnet45
        |> Darklang.Anthropic.Chat.Request.withMaxTokens 50L
        |> Darklang.Anthropic.Chat.Request.withBlockMessages [ userMessage ]

      match Darklang.Anthropic.Chat.Request.send apiKey req with
      | Ok response ->
        let text = Stdlib.String.toLowercase (Darklang.Anthropic.Response.getText response)
        // Should recognize red color
        if Stdlib.String.contains text "red" ||
           Stdlib.String.contains text "pink" ||
           Stdlib.String.contains text "magenta" then
          TestResult.Pass
        else
          // Any response is acceptable for vision test
          if Stdlib.String.length text > 0L then
            TestResult.Pass
          else
            TestResult.Fail $"Unexpected response: {text}"
      | Error e ->
        TestResult.Fail $"API error: {Darklang.Anthropic.Response.ApiError.toString e}"

  /// Test image from URL
  let testImageUrl () : TestResult =
    match getApiKey () with
    | None -> TestResult.Skipped "ANTHROPIC_API_KEY not set"
    | Some apiKey ->
      // Use a well-known public image
      let imageBlock = Darklang.Anthropic.Content.imageBlockUrl "https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png"
      let textBlock = Darklang.Anthropic.Content.textBlock "What company logo is this? Reply with just the company name."

      let userMessage =
        Darklang.Anthropic.Content.userBlockMessage [ imageBlock; textBlock ]

      let req =
        (Darklang.Anthropic.Chat.Request.create ())
        |> Darklang.Anthropic.Chat.Request.withModel Darklang.Anthropic.Models.Model.Sonnet45
        |> Darklang.Anthropic.Chat.Request.withMaxTokens 50L
        |> Darklang.Anthropic.Chat.Request.withBlockMessages [ userMessage ]

      match Darklang.Anthropic.Chat.Request.send apiKey req with
      | Ok response ->
        let text = Stdlib.String.toLowercase (Darklang.Anthropic.Response.getText response)
        if Stdlib.String.contains text "google" then
          TestResult.Pass
        else
          // URL might not be accessible, any response is ok
          if Stdlib.String.length text > 0L then
            TestResult.Pass
          else
            TestResult.Fail $"No response: {text}"
      | Error e ->
        TestResult.Fail $"API error: {Darklang.Anthropic.Response.ApiError.toString e}"

  /// Test PDF document input
  let testPdfInput () : TestResult =
    match getApiKey () with
    | None -> TestResult.Skipped "ANTHROPIC_API_KEY not set"
    | Some apiKey ->
      // Minimal valid PDF with text "Hello"
      // This is a tiny valid PDF file
      let minimalPdf = "JVBERi0xLjEKMSAwIG9iago8PCAvVHlwZSAvQ2F0YWxvZyAvUGFnZXMgMiAwIFIgPj4KZW5kb2JqCjIgMCBvYmoKPDwgL1R5cGUgL1BhZ2VzIC9LaWRzIFszIDAgUl0gL0NvdW50IDEgPj4KZW5kb2JqCjMgMCBvYmoKPDwgL1R5cGUgL1BhZ2UgL1BhcmVudCAyIDAgUiAvTWVkaWFCb3ggWzAgMCA2MTIgNzkyXQovQ29udGVudHMgNCAwIFIgL1Jlc291cmNlcyA8PCAvRm9udCA8PCAvRjEgNSAwIFIgPj4gPj4gPj4KZW5kb2JqCjQgMCBvYmoKPDwgL0xlbmd0aCA0NCA+PgpzdHJlYW0KQlQKL0YxIDI0IFRmCjEwMCA3MDAgVGQKKEhlbGxvKSBUagpFVAplbmRzdHJlYW0KZW5kb2JqCjUgMCBvYmoKPDwgL1R5cGUgL0ZvbnQgL1N1YnR5cGUgL1R5cGUxIC9CYXNlRm9udCAvSGVsdmV0aWNhID4+CmVuZG9iagp4cmVmCjAgNgowMDAwMDAwMDAwIDY1NTM1IGYgCjAwMDAwMDAwMDkgMDAwMDAgbiAKMDAwMDAwMDA1OCAwMDAwMCBuIAowMDAwMDAwMTE1IDAwMDAwIG4gCjAwMDAwMDAyNzAgMDAwMDAgbiAKMDAwMDAwMDM2MyAwMDAwMCBuIAp0cmFpbGVyCjw8IC9TaXplIDYgL1Jvb3QgMSAwIFIgPj4Kc3RhcnR4cmVmCjQ0MwolJUVPRgo="

      let pdfBlock = Darklang.Anthropic.Content.documentBlockPdf minimalPdf
      let textBlock = Darklang.Anthropic.Content.textBlock "What text is in this PDF document?"

      let userMessage =
        Darklang.Anthropic.Content.userBlockMessage [ pdfBlock; textBlock ]

      let req =
        (Darklang.Anthropic.Chat.Request.create ())
        |> Darklang.Anthropic.Chat.Request.withModel Darklang.Anthropic.Models.Model.Sonnet45
        |> Darklang.Anthropic.Chat.Request.withMaxTokens 100L
        |> Darklang.Anthropic.Chat.Request.withBlockMessages [ userMessage ]

      match Darklang.Anthropic.Chat.Request.send apiKey req with
      | Ok response ->
        let text = Stdlib.String.toLowercase (Darklang.Anthropic.Response.getText response)
        // Should recognize "Hello" from the PDF
        if Stdlib.String.contains text "hello" then
          TestResult.Pass
        else
          // Any response is acceptable for PDF test
          if Stdlib.String.length text > 0L then
            TestResult.Pass
          else
            TestResult.Fail $"Empty response: {text}"
      | Error e ->
        TestResult.Fail $"API error: {Darklang.Anthropic.Response.ApiError.toString e}"

  /// Test PDF document input via URL
  let testPdfUrl () : TestResult =
    match getApiKey () with
    | None -> TestResult.Skipped "ANTHROPIC_API_KEY not set"
    | Some apiKey ->
      // Use arxiv paper - "Attention Is All You Need"
      let pdfUrl = "https://arxiv.org/pdf/1706.03762.pdf"

      let pdfBlock = Darklang.Anthropic.Content.documentBlockPdfUrl pdfUrl
      let textBlock = Darklang.Anthropic.Content.textBlock "Briefly describe what this PDF contains."

      let userMessage =
        Darklang.Anthropic.Content.userBlockMessage [ pdfBlock; textBlock ]

      let req =
        (Darklang.Anthropic.Chat.Request.create ())
        |> Darklang.Anthropic.Chat.Request.withModel Darklang.Anthropic.Models.Model.Sonnet45
        |> Darklang.Anthropic.Chat.Request.withMaxTokens 200L
        |> Darklang.Anthropic.Chat.Request.withBlockMessages [ userMessage ]

      match Darklang.Anthropic.Chat.Request.send apiKey req with
      | Ok response ->
        let text = Darklang.Anthropic.Response.getText response
        if Stdlib.String.length text > 0L then
          TestResult.Pass
        else
          TestResult.Fail "Empty response for PDF URL"
      | Error e ->
        // PDF URL might not be accessible from Anthropic's servers, treat as skip
        let errStr = Darklang.Anthropic.Response.ApiError.toString e
        let errLower = Stdlib.String.toLowercase errStr
        if Stdlib.String.contains errLower "url" ||
           Stdlib.String.contains errLower "download" ||
           Stdlib.String.contains errLower "fetch" ||
           Stdlib.String.contains errLower "accessible" then
          TestResult.Skipped $"PDF URL not accessible: {errStr}"
        else
          TestResult.Fail $"API error: {errStr}"

  /// Test PDF URL with title and context
  let testPdfUrlWithTitle () : TestResult =
    match getApiKey () with
    | None -> TestResult.Skipped "ANTHROPIC_API_KEY not set"
    | Some apiKey ->
      // Use arxiv paper - "Attention Is All You Need"
      let pdfUrl = "https://arxiv.org/pdf/1706.03762.pdf"

      let pdfBlock = Darklang.Anthropic.Content.documentBlockPdfUrlWithTitle pdfUrl "Transformer Paper"
      let textBlock = Darklang.Anthropic.Content.textBlock "What is the title of this paper?"

      let userMessage =
        Darklang.Anthropic.Content.userBlockMessage [ pdfBlock; textBlock ]

      let req =
        (Darklang.Anthropic.Chat.Request.create ())
        |> Darklang.Anthropic.Chat.Request.withModel Darklang.Anthropic.Models.Model.Sonnet45
        |> Darklang.Anthropic.Chat.Request.withMaxTokens 100L
        |> Darklang.Anthropic.Chat.Request.withBlockMessages [ userMessage ]

      match Darklang.Anthropic.Chat.Request.send apiKey req with
      | Ok response ->
        let text = Darklang.Anthropic.Response.getText response
        if Stdlib.String.length text > 0L then
          TestResult.Pass
        else
          TestResult.Fail "Empty response"
      | Error e ->
        let errStr = Darklang.Anthropic.Response.ApiError.toString e
        let errLower = Stdlib.String.toLowercase errStr
        if Stdlib.String.contains errLower "url" ||
           Stdlib.String.contains errLower "download" ||
           Stdlib.String.contains errLower "fetch" ||
           Stdlib.String.contains errLower "accessible" then
          TestResult.Skipped $"PDF URL not accessible: {errStr}"
        else if Stdlib.String.contains errLower "rate" then
          TestResult.Skipped $"Rate limited: {errStr}"
        else
          TestResult.Fail $"API error: {errStr}"

  let allTests () : List<String * TestFunction> =
    [ ("Vision: base64 image input", fun () -> testImageInput ())
      ("Vision: image URL input", fun () -> testImageUrl ())
      ("Vision: PDF document input", fun () -> testPdfInput ())
      ("Vision: PDF URL input", fun () -> testPdfUrl ())
      ("Vision: PDF URL with title", fun () -> testPdfUrlWithTitle ()) ]


// =============================================================================
// ADAPTIVE THINKING TESTS (Opus 4.6)
// =============================================================================

module AdaptiveThinkingTests =

  /// Test adaptive thinking mode
  let testAdaptiveThinking () : TestResult =
    match getApiKey () with
    | None -> TestResult.Skipped "ANTHROPIC_API_KEY not set"
    | Some apiKey ->
      let req =
        (Darklang.Anthropic.Chat.Request.create ())
        |> Darklang.Anthropic.Chat.Request.withModel Darklang.Anthropic.Models.Model.Opus46
        |> Darklang.Anthropic.Chat.Request.withMaxTokens 2000L
        |> Darklang.Anthropic.Chat.Request.withAdaptiveThinking
        |> Darklang.Anthropic.Chat.Request.withUserMessage "What is the square root of 144? Think through this carefully."

      match Darklang.Anthropic.Chat.Request.send apiKey req with
      | Ok response ->
        let text = Darklang.Anthropic.Response.getText response
        // Should get correct answer
        if Stdlib.String.contains text "12" then
          TestResult.Pass
        else
          // Any non-empty response is acceptable
          if Stdlib.String.length text > 0L then
            TestResult.Pass
          else
            TestResult.Fail $"Unexpected response: {text}"
      | Error e ->
        // Opus might not be available - skip rather than fail
        let errStr = Darklang.Anthropic.Response.ApiError.toString e
        if Stdlib.String.contains errStr "model" || Stdlib.String.contains errStr "access" then
          TestResult.Skipped "Opus 4.6 not available"
        else
          TestResult.Fail $"API error: {errStr}"

  let allTests () : List<String * TestFunction> =
    [ ("AdaptiveThinking: Opus 4.6", fun () -> testAdaptiveThinking ()) ]


// =============================================================================
// SERVICE TIER TESTS
// =============================================================================

module ServiceTierTests =

  /// Test standard service tier
  let testStandardTier () : TestResult =
    match getApiKey () with
    | None -> TestResult.Skipped "ANTHROPIC_API_KEY not set"
    | Some apiKey ->
      let req =
        (Darklang.Anthropic.Chat.Request.create ())
        |> Darklang.Anthropic.Chat.Request.withModel Darklang.Anthropic.Models.Model.Haiku35
        |> Darklang.Anthropic.Chat.Request.withMaxTokens 50L
        |> Darklang.Anthropic.Chat.Request.withServiceTier Darklang.Anthropic.Chat.ServiceTier.StandardOnly
        |> Darklang.Anthropic.Chat.Request.withUserMessage "Say OK"

      match Darklang.Anthropic.Chat.Request.send apiKey req with
      | Ok response ->
        if Stdlib.String.length (Darklang.Anthropic.Response.getText response) > 0L then
          TestResult.Pass
        else
          TestResult.Fail "Empty response"
      | Error e ->
        TestResult.Fail $"API error: {Darklang.Anthropic.Response.ApiError.toString e}"

  /// Test auto service tier
  let testAutoTier () : TestResult =
    match getApiKey () with
    | None -> TestResult.Skipped "ANTHROPIC_API_KEY not set"
    | Some apiKey ->
      let req =
        (Darklang.Anthropic.Chat.Request.create ())
        |> Darklang.Anthropic.Chat.Request.withModel Darklang.Anthropic.Models.Model.Haiku35
        |> Darklang.Anthropic.Chat.Request.withMaxTokens 50L
        |> Darklang.Anthropic.Chat.Request.withServiceTier Darklang.Anthropic.Chat.ServiceTier.Auto
        |> Darklang.Anthropic.Chat.Request.withUserMessage "Say OK"

      match Darklang.Anthropic.Chat.Request.send apiKey req with
      | Ok response ->
        if Stdlib.String.length (Darklang.Anthropic.Response.getText response) > 0L then
          TestResult.Pass
        else
          TestResult.Fail "Empty response"
      | Error e ->
        TestResult.Fail $"API error: {Darklang.Anthropic.Response.ApiError.toString e}"

  let allTests () : List<String * TestFunction> =
    [ ("ServiceTier: standard only", fun () -> testStandardTier ())
      ("ServiceTier: auto", fun () -> testAutoTier ()) ]


// =============================================================================
// SAMPLING PARAMETERS TESTS (Top-p, Top-k)
// =============================================================================

module SamplingParameterTests =

  /// Test top_p parameter
  let testTopP () : TestResult =
    match getApiKey () with
    | None -> TestResult.Skipped "ANTHROPIC_API_KEY not set"
    | Some apiKey ->
      let req =
        (Darklang.Anthropic.Chat.Request.create ())
        |> Darklang.Anthropic.Chat.Request.withModel Darklang.Anthropic.Models.Model.Haiku35
        |> Darklang.Anthropic.Chat.Request.withMaxTokens 50L
        |> Darklang.Anthropic.Chat.Request.withTopP 0.9
        |> Darklang.Anthropic.Chat.Request.withUserMessage "Say OK"

      match Darklang.Anthropic.Chat.Request.send apiKey req with
      | Ok response ->
        if Stdlib.String.length (Darklang.Anthropic.Response.getText response) > 0L then
          TestResult.Pass
        else
          TestResult.Fail "Empty response"
      | Error e ->
        TestResult.Fail $"API error: {Darklang.Anthropic.Response.ApiError.toString e}"

  /// Test top_k parameter
  let testTopK () : TestResult =
    match getApiKey () with
    | None -> TestResult.Skipped "ANTHROPIC_API_KEY not set"
    | Some apiKey ->
      let req =
        (Darklang.Anthropic.Chat.Request.create ())
        |> Darklang.Anthropic.Chat.Request.withModel Darklang.Anthropic.Models.Model.Haiku35
        |> Darklang.Anthropic.Chat.Request.withMaxTokens 50L
        |> Darklang.Anthropic.Chat.Request.withTopK 40L
        |> Darklang.Anthropic.Chat.Request.withUserMessage "Say OK"

      match Darklang.Anthropic.Chat.Request.send apiKey req with
      | Ok response ->
        if Stdlib.String.length (Darklang.Anthropic.Response.getText response) > 0L then
          TestResult.Pass
        else
          TestResult.Fail "Empty response"
      | Error e ->
        TestResult.Fail $"API error: {Darklang.Anthropic.Response.ApiError.toString e}"

  /// Test combined top_p and top_k
  let testTopPAndTopK () : TestResult =
    match getApiKey () with
    | None -> TestResult.Skipped "ANTHROPIC_API_KEY not set"
    | Some apiKey ->
      let req =
        (Darklang.Anthropic.Chat.Request.create ())
        |> Darklang.Anthropic.Chat.Request.withModel Darklang.Anthropic.Models.Model.Haiku35
        |> Darklang.Anthropic.Chat.Request.withMaxTokens 50L
        |> Darklang.Anthropic.Chat.Request.withTopP 0.95
        |> Darklang.Anthropic.Chat.Request.withTopK 50L
        |> Darklang.Anthropic.Chat.Request.withUserMessage "Say OK"

      match Darklang.Anthropic.Chat.Request.send apiKey req with
      | Ok response ->
        if Stdlib.String.length (Darklang.Anthropic.Response.getText response) > 0L then
          TestResult.Pass
        else
          TestResult.Fail "Empty response"
      | Error e ->
        TestResult.Fail $"API error: {Darklang.Anthropic.Response.ApiError.toString e}"

  let allTests () : List<String * TestFunction> =
    [ ("Sampling: top_p", fun () -> testTopP ())
      ("Sampling: top_k", fun () -> testTopK ())
      ("Sampling: top_p and top_k combined", fun () -> testTopPAndTopK ()) ]


// =============================================================================
// METADATA TESTS
// =============================================================================

module MetadataTests =

  /// Test user_id metadata
  let testUserId () : TestResult =
    match getApiKey () with
    | None -> TestResult.Skipped "ANTHROPIC_API_KEY not set"
    | Some apiKey ->
      let req =
        (Darklang.Anthropic.Chat.Request.create ())
        |> Darklang.Anthropic.Chat.Request.withModel Darklang.Anthropic.Models.Model.Haiku35
        |> Darklang.Anthropic.Chat.Request.withMaxTokens 50L
        |> Darklang.Anthropic.Chat.Request.withUserId "test-user-12345"
        |> Darklang.Anthropic.Chat.Request.withUserMessage "Say OK"

      match Darklang.Anthropic.Chat.Request.send apiKey req with
      | Ok response ->
        if Stdlib.String.length (Darklang.Anthropic.Response.getText response) > 0L then
          TestResult.Pass
        else
          TestResult.Fail "Empty response"
      | Error e ->
        TestResult.Fail $"API error: {Darklang.Anthropic.Response.ApiError.toString e}"

  let allTests () : List<String * TestFunction> =
    [ ("Metadata: user_id", fun () -> testUserId ()) ]


// =============================================================================
// BATCH PROCESSING TESTS
// =============================================================================

module BatchTests =

  /// Test creating a batch with simple requests
  let testCreateBatch () : TestResult =
    match getApiKey () with
    | None -> TestResult.Skipped "ANTHROPIC_API_KEY not set"
    | Some apiKey ->
      let req1 =
        (Darklang.Anthropic.Chat.Request.create ())
        |> Darklang.Anthropic.Chat.Request.withModel Darklang.Anthropic.Models.Model.Haiku35
        |> Darklang.Anthropic.Chat.Request.withMaxTokens 50L
        |> Darklang.Anthropic.Chat.Request.withUserMessage "Say hello"

      let req2 =
        (Darklang.Anthropic.Chat.Request.create ())
        |> Darklang.Anthropic.Chat.Request.withModel Darklang.Anthropic.Models.Model.Haiku35
        |> Darklang.Anthropic.Chat.Request.withMaxTokens 50L
        |> Darklang.Anthropic.Chat.Request.withUserMessage "Say goodbye"

      let batchRequests =
        [ Darklang.Anthropic.Batch.batchRequest "test-1" req1
          Darklang.Anthropic.Batch.batchRequest "test-2" req2 ]

      match Darklang.Anthropic.Batch.createBatch apiKey batchRequests with
      | Ok batch ->
        if Stdlib.String.startsWith batch.id "msgbatch_" then
          TestResult.Pass
        else
          TestResult.Fail $"Unexpected batch ID format: {batch.id}"
      | Error e ->
        TestResult.Fail $"Batch creation error: {Darklang.Anthropic.Response.ApiError.toString e}"

  /// Test listing batches
  let testListBatches () : TestResult =
    match getApiKey () with
    | None -> TestResult.Skipped "ANTHROPIC_API_KEY not set"
    | Some apiKey ->
      match Darklang.Anthropic.Batch.listBatches apiKey (Stdlib.Option.Option.Some 5L) Stdlib.Option.Option.None with
      | Ok response ->
        // Just verify we got a valid response (list could be empty)
        TestResult.Pass
      | Error e ->
        TestResult.Fail $"List batches error: {Darklang.Anthropic.Response.ApiError.toString e}"

  /// Test retrieving a batch (uses a batch created in testCreateBatch)
  let testRetrieveBatch () : TestResult =
    match getApiKey () with
    | None -> TestResult.Skipped "ANTHROPIC_API_KEY not set"
    | Some apiKey ->
      // First create a batch to retrieve
      let req =
        (Darklang.Anthropic.Chat.Request.create ())
        |> Darklang.Anthropic.Chat.Request.withModel Darklang.Anthropic.Models.Model.Haiku35
        |> Darklang.Anthropic.Chat.Request.withMaxTokens 50L
        |> Darklang.Anthropic.Chat.Request.withUserMessage "Say test"

      let batchRequests = [ Darklang.Anthropic.Batch.batchRequest "retrieve-test" req ]

      match Darklang.Anthropic.Batch.createBatch apiKey batchRequests with
      | Ok createdBatch ->
        // Now retrieve it
        match Darklang.Anthropic.Batch.retrieveBatch apiKey createdBatch.id with
        | Ok retrievedBatch ->
          if retrievedBatch.id == createdBatch.id then
            TestResult.Pass
          else
            TestResult.Fail $"Batch ID mismatch: expected {createdBatch.id}, got {retrievedBatch.id}"
        | Error e ->
          TestResult.Fail $"Retrieve batch error: {Darklang.Anthropic.Response.ApiError.toString e}"
      | Error e ->
        TestResult.Fail $"Create batch error: {Darklang.Anthropic.Response.ApiError.toString e}"

  /// Test batch status helpers
  let testBatchStatusHelpers () : TestResult =
    match getApiKey () with
    | None -> TestResult.Skipped "ANTHROPIC_API_KEY not set"
    | Some apiKey ->
      let req =
        (Darklang.Anthropic.Chat.Request.create ())
        |> Darklang.Anthropic.Chat.Request.withModel Darklang.Anthropic.Models.Model.Haiku35
        |> Darklang.Anthropic.Chat.Request.withMaxTokens 50L
        |> Darklang.Anthropic.Chat.Request.withUserMessage "Test"

      let batchRequests = [ Darklang.Anthropic.Batch.batchRequest "helper-test" req ]

      match Darklang.Anthropic.Batch.createBatch apiKey batchRequests with
      | Ok batch ->
        // New batch should be in_progress or ended (if very fast)
        let isProcessing = Darklang.Anthropic.Batch.isProcessing batch
        let isComplete = Darklang.Anthropic.Batch.isComplete batch
        let total = Darklang.Anthropic.Batch.totalRequests batch

        if (isProcessing || isComplete) && total >= 1L then
          TestResult.Pass
        else
          TestResult.Fail $"Unexpected batch state: processing={isProcessing}, complete={isComplete}, total={total}"
      | Error e ->
        TestResult.Fail $"Create batch error: {Darklang.Anthropic.Response.ApiError.toString e}"

  /// Helper to poll batch status until complete
  /// Polls up to maxAttempts times with 2 second delays between attempts
  let pollBatchUntilComplete
    (apiKey: String)
    (batchId: String)
    (maxAttempts: Int64)
    : Stdlib.Result.Result<Darklang.Anthropic.Batch.MessageBatch, String> =
    let attempts = Stdlib.List.range 1L maxAttempts

    Stdlib.List.fold
      attempts
      (Stdlib.Result.Result.Error "Not started")
      (fun acc _ ->
        match acc with
        | Ok batch -> Stdlib.Result.Result.Ok batch  // Already complete, short circuit
        | Error _ ->
          match Darklang.Anthropic.Batch.retrieveBatch apiKey batchId with
          | Ok currentBatch ->
            if Darklang.Anthropic.Batch.isComplete currentBatch then
              Stdlib.Result.Result.Ok currentBatch
            else
              // Wait 2 seconds before next poll
              let _ = Builtin.timeSleep 2000.0
              Stdlib.Result.Result.Error "Still processing"
          | Error e ->
            Stdlib.Result.Result.Error (Darklang.Anthropic.Response.ApiError.toString e))

  /// Test getting batch results (polls with 2s delays, up to 60s total)
  let testGetBatchResults () : TestResult =
    match getApiKey () with
    | None -> TestResult.Skipped "ANTHROPIC_API_KEY not set"
    | Some apiKey ->
      let req =
        (Darklang.Anthropic.Chat.Request.create ())
        |> Darklang.Anthropic.Chat.Request.withModel Darklang.Anthropic.Models.Model.Haiku35
        |> Darklang.Anthropic.Chat.Request.withMaxTokens 50L
        |> Darklang.Anthropic.Chat.Request.withUserMessage "Reply with just: OK"

      let batchRequests = [ Darklang.Anthropic.Batch.batchRequest "results-test" req ]

      match Darklang.Anthropic.Batch.createBatch apiKey batchRequests with
      | Ok batch ->
        match pollBatchUntilComplete apiKey batch.id 30L with
        | Ok completedBatch ->
          match Darklang.Anthropic.Batch.getBatchResults apiKey completedBatch.id with
          | Ok results ->
            let successfulResults = Darklang.Anthropic.Batch.getSuccessfulResults results
            if Stdlib.List.length successfulResults >= 1L then
              TestResult.Pass
            else
              TestResult.Fail "No successful results found"
          | Error e ->
            TestResult.Fail $"Get results error: {Darklang.Anthropic.Response.ApiError.toString e}"
        | Error msg ->
          // Batch might take too long, skip instead of fail
          TestResult.Skipped $"Batch did not complete in time: {msg}"
      | Error e ->
        TestResult.Fail $"Create batch error: {Darklang.Anthropic.Response.ApiError.toString e}"

  let allTests () : List<String * TestFunction> =
    [ ("Batch: create batch", fun () -> testCreateBatch ())
      ("Batch: list batches", fun () -> testListBatches ())
      ("Batch: retrieve batch", fun () -> testRetrieveBatch ())
      ("Batch: status helpers", fun () -> testBatchStatusHelpers ())
      // takes too long waiting for batch completion
      // ("Batch: get results", fun () -> testGetBatchResults ())
      ]


// =============================================================================
// PROMPT CACHING TESTS
// =============================================================================

module PromptCachingTests =

  /// Test that prompt caching works by sending same content twice
  let testPromptCaching () : TestResult =
    match getApiKey () with
    | None -> TestResult.Skipped "ANTHROPIC_API_KEY not set"
    | Some apiKey ->
      // Create a large system prompt that will be cached (must be > 1024 tokens for caching)
      let largeSystemPrompt =
        "You are a helpful assistant. " ++
        (Stdlib.String.repeat "This is filler text to make the prompt large enough for caching. " 200L)

      let cachedBlock =
        Darklang.Anthropic.Content.systemBlockCached
          largeSystemPrompt
          (Darklang.Anthropic.Models.cache5min ())

      // First request - should create cache
      let req1 =
        (Darklang.Anthropic.Chat.Request.create ())
        |> Darklang.Anthropic.Chat.Request.withModel Darklang.Anthropic.Models.Model.Sonnet45
        |> Darklang.Anthropic.Chat.Request.withMaxTokens 50L
        |> Darklang.Anthropic.Chat.Request.withSystemBlocks [ cachedBlock ]
        |> Darklang.Anthropic.Chat.Request.withUserMessage "Say hello"

      match Darklang.Anthropic.Chat.Request.send apiKey req1 with
      | Ok response1 ->
        // Check cache_creation_input_tokens
        let cacheCreated =
          match response1.usage.cache_creation_input_tokens with
          | Some tokens -> tokens > 0L
          | None -> false

        // Second request - should read from cache
        let req2 =
          (Darklang.Anthropic.Chat.Request.create ())
          |> Darklang.Anthropic.Chat.Request.withModel Darklang.Anthropic.Models.Model.Sonnet45
          |> Darklang.Anthropic.Chat.Request.withMaxTokens 50L
          |> Darklang.Anthropic.Chat.Request.withSystemBlocks [ cachedBlock ]
          |> Darklang.Anthropic.Chat.Request.withUserMessage "Say goodbye"

        match Darklang.Anthropic.Chat.Request.send apiKey req2 with
        | Ok response2 ->
          let cacheRead =
            match response2.usage.cache_read_input_tokens with
            | Some tokens -> tokens > 0L
            | None -> false

          // Either cache was created on first call OR read on second call
          if cacheCreated || cacheRead then
            TestResult.Pass
          else
            // Caching might not always work (depends on API), pass if we got responses
            if Stdlib.String.length (Darklang.Anthropic.Response.getText response1) > 0L &&
               Stdlib.String.length (Darklang.Anthropic.Response.getText response2) > 0L then
              TestResult.Pass
            else
              TestResult.Fail "No cache activity detected and empty responses"
        | Error e ->
          TestResult.Fail $"Second request error: {Darklang.Anthropic.Response.ApiError.toString e}"
      | Error e ->
        TestResult.Fail $"First request error: {Darklang.Anthropic.Response.ApiError.toString e}"

  let allTests () : List<String * TestFunction> =
    [ ("Caching: prompt caching", fun () -> testPromptCaching ()) ]


// =============================================================================
// TEST RUNNER
// =============================================================================

type TestSummary =
  { totalTests: Int64
    passedTests: Int64
    failedTests: Int64
    skippedTests: Int64
    failedTestNames: List<String> }

type TestList = List<(String * TestFunction)>

let runTestGroup (groupName: String) (tests: TestList) : TestSummary =
  let initialSummary =
    TestSummary
      { totalTests = 0L
        passedTests = 0L
        failedTests = 0L
        skippedTests = 0L
        failedTestNames = [] }

  tests
  |> Stdlib.List.fold initialSummary (fun summary nameFnPair ->
    let name = Stdlib.Tuple2.first nameFnPair
    let testFn = Stdlib.Tuple2.second nameFnPair
    let newSummary = { summary with totalTests = summary.totalTests + 1L }

    let result = testFn ()

    match result with
    | Pass ->
      Stdlib.printLine $"  [PASS] {name}"
      { newSummary with passedTests = newSummary.passedTests + 1L }
    | Skipped reason ->
      Stdlib.printLine $"  [SKIP] {name}: {reason}"
      { newSummary with skippedTests = newSummary.skippedTests + 1L }
    | Fail message ->
      Stdlib.printLine $"  [FAIL] {name}: {message}"
      { newSummary with
          failedTests = newSummary.failedTests + 1L
          failedTestNames = Stdlib.List.push newSummary.failedTestNames $"{name}: {message}" })

let combineSummaries (a: TestSummary) (b: TestSummary) : TestSummary =
  TestSummary
    { totalTests = a.totalTests + b.totalTests
      passedTests = a.passedTests + b.passedTests
      failedTests = a.failedTests + b.failedTests
      skippedTests = a.skippedTests + b.skippedTests
      failedTestNames = Stdlib.List.append a.failedTestNames b.failedTestNames }

let runAllTests () : String =
  let groups =
    [ ("DirectApi", DirectApiTests.allTests ())
      ("TokenCounting", TokenCountingTests.allTests ())
      ("JsonSchema", JsonSchemaTests.allTests ())
      ("StopSequence", StopSequenceTests.allTests ())
      ("ServerTools", ServerToolTests.allTests ())
      ("WebFetch", WebFetchTests.allTests ())
      ("Vision", VisionTests.allTests ())
      ("AdaptiveThinking", AdaptiveThinkingTests.allTests ())
      ("ServiceTier", ServiceTierTests.allTests ())
      ("Sampling", SamplingParameterTests.allTests ())
      ("Metadata", MetadataTests.allTests ())
      ("Batch", BatchTests.allTests ())
      ("Caching", PromptCachingTests.allTests ()) ]

  let emptySummary =
    TestSummary
      { totalTests = 0L
        passedTests = 0L
        failedTests = 0L
        skippedTests = 0L
        failedTestNames = [] }

  let _ = Stdlib.printLine "Anthropic API Integration Tests"
  let _ = Stdlib.printLine "================================"

  let finalSummary =
    groups
    |> Stdlib.List.fold emptySummary (fun acc groupPair ->
      let groupName = Stdlib.Tuple2.first groupPair
      let tests = Stdlib.Tuple2.second groupPair
      let _ = Stdlib.printLine $"\n[{groupName}]"
      let groupSummary = runTestGroup groupName tests
      combineSummaries acc groupSummary)

  let resultLine =
    if finalSummary.failedTests == 0L then
      if finalSummary.skippedTests > 0L then
        $"All run tests passed! ({Stdlib.Int64.toString finalSummary.skippedTests} skipped)"
      else
        "All tests passed!"
    else
      let failedNames = Stdlib.String.join finalSummary.failedTestNames "\n  - "
      $"Failed tests:\n  - {failedNames}"

  $"Anthropic API Integration Tests\nTotal: {Stdlib.Int64.toString finalSummary.totalTests}, Passed: {Stdlib.Int64.toString finalSummary.passedTests}, Failed: {Stdlib.Int64.toString finalSummary.failedTests}, Skipped: {Stdlib.Int64.toString finalSummary.skippedTests}\n{resultLine}"
