module Darklang.Stdlib.Cli.Fish


/// Read the content of config.fish file
let readFishConfig () : Result.Result<String, String> =
  (Builtin.fileRead "$HOME/.config/fish/config.fish")
  |> Result.map (fun content -> String.fromBytesWithReplacement content)

/// Overwrite what's in the config.fish file
let overwriteFishConfig (content: String) : Result.Result<Unit, String> =
  (Builtin.fileWrite (String.toBytes content) "$HOME/.config/fish/config.fish")
  |> Result.map (fun _ -> ())


/// Delete an alias from config.fish
let deleteAlias (alias: String) : Result.Result<Unit, String> =
  (readFishConfig ())
  |> Result.andThen (fun content ->
    let updatedContent =
      content
      |> String.split "\n"
      |> List.filter (fun line ->
        Bool.not (String.contains line $"alias {alias} "))
      |> String.join "\n"

    overwriteFishConfig updatedContent)


/// Add an alias to config.fish
let addAlias
  (alias: String)
  (command: String)
  : Result.Result<Unit, String> =
  let aliasDefinition = $"alias {alias} '{command}'"

  (readFishConfig ())
  |> Result.map (fun content ->
    let updatedContent = content ++ "\n" ++ aliasDefinition
    overwriteFishConfig updatedContent)


/// Add a directory to PATH in config.fish
let addToPath (dir: String) : Result.Result<Unit, String> =
  let exportLine = $"fish_add_path {dir}"

  match readFishConfig () with
  | Ok content ->
    // Check if PATH addition for this dir already exists (not just any reference to the dir)
    if String.contains content exportLine then
      Result.Result.Ok()
    else
      let updatedContent = content ++ "\n" ++ exportLine
      overwriteFishConfig updatedContent
  | Error e -> Result.Result.Error e
