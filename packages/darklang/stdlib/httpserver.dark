module Darklang.Stdlib.HttpServer

// HTTP Server functionality for Darklang

/// An HTTP handler definition
type Handler =
  { route: String
    method: String
    handler: Http.Request -> Http.Response }


/// Result of matching a route pattern against a request path
type RouteMatch =
  { matched: Bool
    vars: List<String * String> }


/// Segment type for route parsing
type RouteSegment =
  | Literal of String
  | Variable of String
  | Wildcard of String


/// Parse a route pattern into segments
let parseRouteSegments (route: String) : List<RouteSegment> =
  let segments = String.split route "/"

  segments
  |> List.filterMap (fun seg ->
    if String.isEmpty seg then
      Option.Option.None
    else if String.startsWith seg ":" then
      Option.Option.Some(RouteSegment.Variable (String.dropFirst seg 1L))
    else if String.startsWith seg "*" then
      Option.Option.Some(RouteSegment.Wildcard (String.dropFirst seg 1L))
    else
      Option.Option.Some(RouteSegment.Literal seg))


/// Match a single route segment against a path segment
let matchSegment
  (routeSeg: RouteSegment)
  (pathSeg: String)
  (remainingPath: List<String>)
  : Option.Option<List<String * String>> =
  match routeSeg with
  | Literal expected ->
    if expected == pathSeg then
      Option.Option.Some []
    else
      Option.Option.None
  | Variable name -> Option.Option.Some [ (name, pathSeg) ]
  | Wildcard name ->
    let fullPath = String.join (List.append [ pathSeg ] remainingPath) "/"
    Option.Option.Some [ (name, fullPath) ]


/// Match a request path against a route pattern
let matchRoute (routePattern: String) (requestPath: String) : RouteMatch =
  let routeSegs = parseRouteSegments routePattern
  let pathSegs =
    (String.split requestPath "/")
    |> List.filter (fun s -> Bool.not (String.isEmpty s))

  let routeLen = List.length routeSegs
  let pathLen = List.length pathSegs

  if (routeLen == 0L) && (pathLen == 0L) then
    RouteMatch { matched = true; vars = [] }
  else if routeLen != pathLen then
    RouteMatch { matched = false; vars = [] }
  else
    // Use zipShortest since we already checked lengths are equal
    let zipped = List.zipShortest routeSegs pathSegs

    let result =
      zipped
      |> List.fold
        (Option.Option.Some [])
        (fun acc pair ->
          match acc with
          | None -> Option.Option.None
          | Some vars ->
            let (routeSeg, pathSeg) = pair
            match matchSegment routeSeg pathSeg [] with
            | Some newVars ->
              Option.Option.Some (List.append vars newVars)
            | None -> Option.Option.None)

    match result with
    | Some vars -> RouteMatch { matched = true; vars = vars }
    | None -> RouteMatch { matched = false; vars = [] }


/// Find the first handler that matches the request
let findHandler
  (handlers: List<Handler>)
  (method: String)
  (path: String)
  : Option.Option<Handler * RouteMatch> =
  // First find a matching handler
  let matchingHandler =
    handlers
    |> List.findFirst (fun h ->
      let methodMatches = (h.method == method) || (h.method == "*")
      let routeMatch = matchRoute h.route path
      methodMatches && routeMatch.matched)

  // If found, compute the route match again to return it
  match matchingHandler with
  | Some h ->
    let routeMatch = matchRoute h.route path
    Option.Option.Some ((h, routeMatch))
  | None -> Option.Option.None


/// Get the HTTP method from a request (from x-http-method header)
let getMethod (req: Http.Request) : String =
  let found =
    req.headers
    |> List.findFirst (fun pair ->
      let (key, _) = pair
      String.toLowercase key == "x-http-method")

  match found with
  | Some ((_, value)) -> value
  | None -> "GET"


/// Get the path from a request URL
let getPath (req: Http.Request) : String =
  let parts = String.split req.url "://"

  let urlWithoutProtocol =
    match parts with
    | [ _; rest ] -> rest
    | _ -> req.url

  let pathParts = String.split urlWithoutProtocol "/"

  match pathParts with
  | [] -> "/"
  | [ _ ] -> "/"
  | _ :: rest ->
    let pathWithQuery = String.join rest "/"
    let pathOnlyParts = String.split pathWithQuery "?"

    match List.head pathOnlyParts with
    | Some p -> "/" ++ p
    | None -> "/"


/// Route a request through a list of handlers
/// Returns the response from the first matching handler, or 404
let routeRequest
  (handlers: List<Handler>)
  (req: Http.Request)
  : Http.Response =
  let method = getMethod req
  let path = getPath req

  match findHandler handlers method path with
  | Some ((handler, _routeMatch)) -> handler.handler req
  | None -> Http.notFound ()


/// Extract a path parameter from a request given a route pattern
/// Example: getPathParam req "/user/:id" "id" returns Some "123" for path "/user/123"
let getPathParam (req: Http.Request) (routePattern: String) (paramName: String) : Option.Option<String> =
  let path = getPath req
  let routeSegs = parseRouteSegments routePattern
  let pathSegs =
    (String.split path "/")
    |> List.filter (fun s -> Bool.not (String.isEmpty s))

  // Zip and find the matching variable
  let zipped = List.zipShortest routeSegs pathSegs
  zipped
  |> List.findFirst (fun pair ->
    let (routeSeg, _) = pair
    match routeSeg with
    | Variable name -> name == paramName
    | _ -> false)
  |> fun result ->
    match result with
    | Some ((_, pathValue)) -> Option.Option.Some pathValue
    | None -> Option.Option.None


/// Start an HTTP server with a handler function
/// The handler receives each request and returns a response
/// This function blocks forever
let serve (port: Int64) (handler: Http.Request -> Http.Response) : Unit =
  Builtin.httpServerServe port handler
