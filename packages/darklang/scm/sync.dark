module Darklang.SCM.Sync

/// Synchronize package ops with a remote Darklang instance
/// Returns a result with success message or error
let sync
  (instanceID: Uuid)
  (remoteURL: String)
  : Stdlib.Result.Result<String, String> =
  // Get last sync date with this instance
  let lastSyncOpt = Builtin.scmGetLastSyncDate instanceID

  let sinceDate =
    match lastSyncOpt with
    | Some dt -> dt
    // If never synced, use Unix epoch (will sync everything)
    | None -> Stdlib.DateTime.fromSeconds 0L

  // Get ops to push from ALL branches (created since last sync), already grouped by branch
  // Exclude ops from the target instance to avoid sending ops back to their source
  let batches =
    Builtin.scmGetOpsSince (Stdlib.Option.Option.Some instanceID) sinceDate

  let batchCount = Stdlib.List.length batches

  // Count total ops across all batches
  let opsPushedCount =
    Stdlib.List.fold batches 0L (fun acc batch -> acc + Stdlib.List.length batch.ops)

  // Push ops to remote
  let pushResult =
    if batchCount == 0L then
      Stdlib.Result.Result.Ok 0L
    else
      let pushUrl = $"{remoteURL}/ops"

      // Push all batches in one request
      let opsJson =
        Builtin.jsonSerialize<List<LanguageTools.ProgramTypes.PackageOpBatch>>
          batches

      let pushRequest =
        Stdlib.HttpClient.post
          pushUrl
          [ ("Content-Type", "application/json") ]
          (Stdlib.String.toBytes opsJson)

      match pushRequest with
      | Ok response ->
        if response.statusCode >= 200L && response.statusCode < 300L then
          Stdlib.Result.Result.Ok opsPushedCount
        else
          let errorBody = Stdlib.String.fromBytesWithReplacement response.body

          let statusCode = Stdlib.Int64.toString response.statusCode

          Stdlib.Result.Result.Error
            $"Push request failed with status {statusCode}: {errorBody}"

      | Error err ->
        let errorMsg = Stdlib.HttpClient.toString err

        Stdlib.Result.Result.Error $"Push request failed: {errorMsg}"

  // If push succeeded, pull ops from remote
  match pushResult with
  | Error msg -> Stdlib.Result.Result.Error msg
  | Ok pushedCount ->
    // Pull ops from remote
    let pullRequest =
      let sinceDateStr = Stdlib.DateTime.toString sinceDate
      Stdlib.HttpClient.get $"{remoteURL}/ops?since={sinceDateStr}" []

    match pullRequest with
    | Error err ->
      let errorMsg = Stdlib.HttpClient.toString err

      Stdlib.Result.Result.Error $"Pull request failed: {errorMsg}"
    | Ok response ->
      if response.statusCode >= 200L && response.statusCode < 300L then
        let responseBody = Stdlib.String.fromBytesWithReplacement response.body

        match
          (Builtin.jsonParse<List<LanguageTools.ProgramTypes.PackageOpBatch>>
             responseBody)
        with
        | Error _err ->
          Stdlib.Result.Result.Error "Failed to parse pulled ops JSON"

        | Ok pulledBatches ->
          let batchCount = Stdlib.List.length pulledBatches

          // Process each batch
          let applyResult =
            if batchCount > 0L then
              Stdlib.List.fold
                pulledBatches
                (Stdlib.Result.Result.Ok 0L)
                (fun resultSoFar batch ->
                  match resultSoFar with
                  | Error msg -> Stdlib.Result.Result.Error msg
                  | Ok appliedSoFar ->
                    // Insert this batch's ops directly
                    // Preserve the batch's instanceID to maintain provenance
                    let addResult =
                      Builtin.scmAddOps batch.instanceID batch.branchID batch.ops

                    match addResult with
                    | Ok batchApplied ->
                      Stdlib.Result.Result.Ok(appliedSoFar + batchApplied)

                    | Error errMsg ->
                      let branchName =
                        match batch.branchID with
                        | Some id -> Stdlib.Uuid.toString id
                        | None -> "main"

                      Stdlib.Result.Result.Error
                        $"Failed to apply ops for branch {branchName}: {errMsg}")
            else
              Stdlib.Result.Result.Ok 0L

          match applyResult with
          | Error msg -> Stdlib.Result.Result.Error msg
          | Ok appliedCount ->
            // Record the sync with the count of ops actually inserted (not just fetched)
            Builtin.scmRecordSync instanceID pushedCount appliedCount

            let pushedStr = Stdlib.Int64.toString pushedCount
            let appliedStr = Stdlib.Int64.toString appliedCount

            Stdlib.Result.Result.Ok
              $"Sync complete: pushed {pushedStr} ops, pulled {appliedStr} ops"

      else
        let errorBody = Stdlib.String.fromBytesWithReplacement response.body
        let statusCode = Stdlib.Int64.toString response.statusCode

        Stdlib.Result.Result.Error
          $"Pull failed with status {statusCode}: {errorBody}"
