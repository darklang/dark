module Darklang =
  module Cli =
    module Tests =
      type TestResult =
        | Pass
        | Fail of message: String


      let runWithCommand (args: List<String>): String =
        let escapedArgs =
          args
          |> Stdlib.List.map (fun arg ->
            if Stdlib.String.contains arg " " ||
               Stdlib.String.contains arg "|" ||
               Stdlib.String.contains arg "\""
            then
              let escapedArg = Stdlib.String.replaceAll arg "\"" "\\\""
              $"'{escapedArg}'"
            else arg)

        let argsString = Stdlib.String.join escapedArgs " "
        let command = $"./scripts/run-cli {argsString}"
        let result = Stdlib.Cli.Unix.executeInDirectoryWithOutput "." command

        if result.exitCode == 0L then
          Stdlib.String.trim result.stdout
        else
          $"ERROR: {result.stderr}"


      let testHelpCommand (): TestResult =
        let output = runWithCommand ["help"]

        if Stdlib.String.contains output "Available commands:" &&
           Stdlib.String.contains output "help" &&
           Stdlib.String.contains output "version" &&
           Stdlib.String.contains output "status" then
            TestResult.Pass
        else
          TestResult.Fail "Expected help text with available commands"


      let testVersionCommand (): TestResult =
        let output = runWithCommand ["version"]
        if Stdlib.String.contains output "Darklang CLI" &&
           Stdlib.String.contains output "alpha-" then
           TestResult.Pass
        else
          TestResult.Fail "Expected version string with 'Darklang CLI alpha-'"


      let testStatusCommand (): TestResult =
        let output = runWithCommand ["status"]
        if Stdlib.String.contains output "Darklang CLI" &&
           Stdlib.String.contains output "Location:" &&
           Stdlib.String.contains output "Mode:" then
          TestResult.Pass
        else
          TestResult.Fail "Expected status output with CLI info, Location, and Mode"


      let testRunBoolAnd (): TestResult =
        let output = runWithCommand ["run"; "@Stdlib.Bool.and true false"]
        if output == "false" then
          TestResult.Pass
        else
          TestResult.Fail $"Expected 'false', got '{output}'"


      let testRunInt64Add (): TestResult =
        let output = runWithCommand ["run"; "@Stdlib.Int64.add 5L 3L"]
        if output == "8" then
          TestResult.Pass
        else
          TestResult.Fail $"Expected '8', got '{output}'"


      let testEvalStringLength (): TestResult =
        let output = runWithCommand ["eval"; "Stdlib.String.length \"hello\""]
        if output == "5" then
          TestResult.Pass
        else
          TestResult.Fail $"Expected '5', got '{output}'"


      let testEvalListLength (): TestResult =
        let output = runWithCommand ["eval"; "[1L; 2L; 3L] |> Stdlib.List.length"]
        if output == "3" then
          TestResult.Pass
        else
          TestResult.Fail $"Expected '3', got '{output}'"


      let testListFunctions (): TestResult =
        let output = runWithCommand ["ls"; "Stdlib.List"]
        if Stdlib.String.contains output "Items in current directory:" &&
           Stdlib.String.contains output "functions" then
            TestResult.Pass
        else
          TestResult.Fail "Expected directory listing with functions"


      let testViewFunction (): TestResult =
        let output = runWithCommand ["view"; "Stdlib.List.head"]
        if Stdlib.String.contains output "List.head" &&
           (Stdlib.String.contains output "Option" || Stdlib.String.contains output "->") then
            TestResult.Pass
        else
          TestResult.Fail "Expected function signature for List.head"


      let testListTypes (): TestResult =
        let output = runWithCommand ["ls"; "Stdlib.Option"]
        if Stdlib.String.contains output "Items in current directory:" &&
           Stdlib.String.contains output "types" then
            TestResult.Pass
        else
          TestResult.Fail "Expected directory listing with types"


      let testHelpForRun (): TestResult =
        let output = runWithCommand ["help"; "run"]
        if Stdlib.String.contains output "run" &&
           (Stdlib.String.contains output "function" || Stdlib.String.contains output "execute") then
            TestResult.Pass
        else
          TestResult.Fail "Expected help text for 'run' command"


      let testHelpForLs (): TestResult =
        let output = runWithCommand ["help"; "ls"]
        if Stdlib.String.contains output "ls" &&
           (Stdlib.String.contains output "list" || Stdlib.String.contains output "List") then
            TestResult.Pass
        else
          TestResult.Fail "Expected help text for 'ls' command"


      let testEvalSimpleExpression (): TestResult =
        let output = runWithCommand ["eval"; "2L + 3L"]
        if output == "5" then
          TestResult.Pass
        else
          TestResult.Fail $"Expected '5', got '{output}'"


      let testEvalStringExpression (): TestResult =
        let output = runWithCommand ["eval"; "\"hello\" ++ \"world\""]
        if output == "helloworld" then
          TestResult.Pass
        else
          TestResult.Fail $"Expected 'helloworld', got '{output}'"


      // 'interactive' tests don't workr - see comments at end of file.
      // let testInteractiveVersionCommand (): TestResult =
      //   // spawn interactive session
      //   let p = Stdlib.Cli.Process.spawn "./scripts/run-cli"

      //   // submit "version" command and check response
      //   let versionOutput = Stdlib.Cli.Process.communicate p "version"

      //   if Stdlib.String.contains versionOutput.stdout "Darklang"
      //      || Stdlib.String.contains versionOutput.stdout "alpha"
      //      || Stdlib.String.contains versionOutput.stdout "CLI" then
      //     let _ = Stdlib.Cli.Process.communicate p "quit"
      //     let finalResult = Stdlib.Cli.Process.terminate p
      //     TestResult.Pass
      //   else
      //     let termResult = Stdlib.Cli.Process.terminate p
      //     TestResult.Fail $"Got unexpected (or no) output: stdout: '{versionOutput.stdout}', stderr: '{versionOutput.stderr}'\nExit code: {Stdlib.Int64.toString termResult.exitCode}"


      // let testInteractiveNavigation (): TestResult =
      //   let p = Stdlib.Cli.Process.spawn "./scripts/run-cli"

      //   let cdOutput = Stdlib.Cli.Process.communicate p "cd Darklang.JsonRPC"

      //   if Stdlib.String.contains cdOutput.stdout "Changed directory to /Darklang.JsonRPC" then
      //     let lsOutput = Stdlib.Cli.Process.communicate p "ls"

      //     if Stdlib.String.contains lsOutput.stdout "IncomingMessage" then
      //       // Success case - send quit and clean exit
      //       let _ = Stdlib.Cli.Process.communicate p "quit"
      //       let _finalResult = Stdlib.Cli.Process.terminate p
      //       TestResult.Pass
      //     else
      //       let termResult = Stdlib.Cli.Process.terminate p
      //       TestResult.Fail $"For 'ls', got unexpected output: stdout: '{lsOutput.stdout}', stderr: '{lsOutput.stderr}'\nExit code: {Stdlib.Int64.toString termResult.exitCode}"

      //   else
      //     let termResult = Stdlib.Cli.Process.terminate p
      //     TestResult.Fail $"For 'cd', got unexpected output: stdout: '{cdOutput.stdout}', stderr: '{cdOutput.stderr}'\nExit code: {Stdlib.Int64.toString termResult.exitCode}"



      type TestFunction = Unit -> TestResult

      let allTests (): List<String * TestFunction> =
        [ ("Help", fun () -> testHelpCommand ())
          ("Version", fun () -> testVersionCommand ())
          ("Status", fun () -> testStatusCommand ())

          ("Run Bool.and", fun () -> testRunBoolAnd ())
          ("Run Int64.add", fun () -> testRunInt64Add ())

          ("Eval String Length", fun () -> testEvalStringLength ())
          ("Eval List Length", fun () -> testEvalListLength ())

          ("List Functions", fun () -> testListFunctions ())
          ("View Function", fun () -> testViewFunction ())
          ("List Types", fun () -> testListTypes ())

          ("Help for Run", fun () -> testHelpForRun ())
          ("Help for Ls", fun () -> testHelpForLs ())

          ("Eval Simple Expression", fun () -> testEvalSimpleExpression ())
          ("Eval String Expression", fun () -> testEvalStringExpression ())

          // ("Interactive: Version", fun () -> testInteractiveVersionCommand ())
          // ("Interactive: cd, ls", fun () -> testInteractiveNavigation())
        ]

      type TestSummary =
        { totalTests: Int64
          passedTests: Int64
          failedTests: Int64
          failedTestNames: List<String> }

      // Sequential test execution - proven to be ~30-50% faster than parallel for CLI tests
      // due to process startup overhead and resource contention
      let runAllTests (): Int64 =
        let tests = allTests ()

        Builtin.printLine ""
        Builtin.printLine "Darklang CLI Tests"
        Builtin.printLine "=================="

        let initialSummary =
          TestSummary
            { totalTests = 0L
              passedTests = 0L
              failedTests = 0L
              failedTestNames = [] }

        let finalSummary =
          tests
          |> Stdlib.List.fold initialSummary (fun summary (name, testFn) ->
            Builtin.printLine ""
            Builtin.printLine $"Running: {name} ..."

            let newSummary =
              { summary with totalTests = summary.totalTests + 1L }

            match testFn () with
            | Pass ->
              Builtin.printLine $"âœ“ PASS - {name}"
              { newSummary with passedTests = newSummary.passedTests + 1L }
            | Fail message ->
              Builtin.printLine $"âœ— FAIL - {name}"
              Builtin.printLine $"  Reason: {message}"
              { newSummary with
                  failedTests = newSummary.failedTests + 1L
                  failedTestNames = Stdlib.List.push newSummary.failedTestNames name })

        Builtin.printLine ""
        Builtin.printLine "ðŸ“Š Test Results Summary"
        Builtin.printLine "======================"
        Builtin.printLine $"Total tests:  {Stdlib.Int64.toString finalSummary.totalTests}"
        Builtin.printLine $"Passed:       {Stdlib.Int64.toString finalSummary.passedTests}"
        Builtin.printLine $"Failed:       {Stdlib.Int64.toString finalSummary.failedTests}"

        if finalSummary.failedTests == 0L then
          Builtin.printLine "ðŸŽ‰ All tests passed!"
          0L
        else
          Builtin.printLine "ðŸš¨ Some tests failed!"
          if Stdlib.Bool.not (Stdlib.List.isEmpty finalSummary.failedTestNames) then
            Builtin.printLine "Failed tests:"
            finalSummary.failedTestNames
            |> Stdlib.List.iter (fun testName ->
              Builtin.printLine $"  âœ— {testName}")
          1L


// Dev note: we've tried to support 'interactive' tests a few times,
// wherein a run-cli process is spawned, and then we issue commands to it over time
// , but various technical things have gotten in the way
//
// That said,
// - we don't need _many_ tests of that sort -- just a few 'integration'
//   tests that go through a full flow
// - most of the tests can/should be regarding these one-off commands
// so, we're dropping this for now, and maybe we'll figure it out later.

// # Plans for Interactive CLI Testing Support

// ## Current Limitation
// We can test CLI commands that take input and immediately return output, but we cannot test the interactive CLI mode where the CLI shows a prompt, waits for user input, processes it, shows results, and waits for more input.

// For example, we cannot currently test:
// 1. Starting the CLI in interactive mode
// 2. Typing "help" and seeing the help output
// 3. Typing "version" and seeing version info
// 4. Typing "quit" to exit

// This requires process spawning and bidirectional communication with a running process.

// ## Proposed API Design Options

// ### Option 1: High-level interaction API
// ```dark
// // Simple step-by-step interaction
// type InteractionStep =
//   | Send of input: String                    // Send input to process
//   | ExpectContains of text: String           // Expect output to contain text
//   | ExpectExact of text: String              // Expect exact output match
//   | ExpectPrompt                             // Wait for CLI prompt ("> ")
//   | ExpectExit of exitCode: Int64            // Expect process to exit
//   | Sleep of milliseconds: Int64             // Wait before next step

// let runInteractiveTest (command: List<String>) (steps: List<InteractionStep>): TestResult =
//   // Implementation would spawn process and execute steps sequentially
//   // Returns Pass or Fail based on whether all steps succeeded

// // Example usage:
// let testInteractiveHelp (): TestResult =
//   runInteractiveTest
//     ["./scripts/run-cli"]
//     [ ExpectPrompt
//       Send "help\n"
//       ExpectContains "Available commands:"
//       ExpectPrompt
//       Send "quit\n"
//       ExpectExit 0L ]
// ```

// ### Option 2: Process handle API
// ```dark
// type ProcessHandle = // Opaque type representing running process

// module Process =
//   let spawn (command: List<String>): ProcessHandle
//   let sendInput (process: ProcessHandle) (input: String): Unit
//   let readOutput (process: ProcessHandle): String            // Non-blocking read
//   let readOutputUntil (process: ProcessHandle) (delimiter: String): String  // Block until delimiter
//   let isRunning (process: ProcessHandle): Bool
//   let waitForExit (process: ProcessHandle): Int64
//   let kill (process: ProcessHandle): Unit

// // Example usage:
// let testInteractiveFlow (): TestResult =
//   let process = Process.spawn ["./scripts/run-cli"]
//   let initialOutput = Process.readOutputUntil process "> "
//   let _ = Process.sendInput process "help\n"
//   let helpOutput = Process.readOutputUntil process "> "
//   let _ = Process.sendInput process "quit\n"
//   let exitCode = Process.waitForExit process

//   if Stdlib.String.contains helpOutput "Available commands:" && exitCode == 0L
//   then Pass
//   else Fail "Interactive test failed"
// ```

// ### Option 3: Callback-based API
// ```dark
// let withInteractiveProcess
//   (command: List<String>)
//   (fn: ProcessHandle -> TestResult): TestResult =
//   // Spawn process, call fn with handle, ensure cleanup

// // Example usage:
// let testInteractiveSession (): TestResult =
//   withInteractiveProcess ["./scripts/run-cli"] (fun process ->
//     let _ = Process.readOutputUntil process "> "
//     let _ = Process.sendInput process "version\n"
//     let output = Process.readOutputUntil process "> "
//     let _ = Process.sendInput process "quit\n"

//     if Stdlib.String.contains output "Darklang CLI"
//     then Pass
//     else Fail "Version command failed"
//   )
// ```

// ## Implementation Considerations

// 1. **Buffering and Timing**
//    - How do we handle partial output that arrives in chunks?
//    - Do we need timeouts for readOutputUntil operations?
//    - How do we detect when the CLI is ready for input vs still processing?

// 2. **Platform Compatibility**
//    - Need to work on Linux, macOS, Windows
//    - Different process spawning mechanisms (fork/exec, CreateProcess, etc.)
//    - Different signal handling and process termination

// 3. **Error Handling**
//    - What if the process crashes unexpectedly?
//    - What if the process hangs and never produces expected output?
//    - How do we clean up zombie processes?

// 4. **Resource Management**
//    - Ensure processes are always terminated even if tests fail
//    - Handle stdin/stdout/stderr file descriptors properly
//    - Prevent file descriptor leaks

// 5. **Testing Robustness**
//    - Tests should be deterministic and not flaky
//    - Need to handle timing variations between different machines
//    - Consider CI environment differences

// ## Next Steps

// 1. **Prototype with existing tools**: Before implementing process spawning in Darklang, we could prototype interactive tests using external tools like `expect` or `pexpect` called via executeInDirectoryWithOutput

// 2. **Design the Darklang API**: Based on prototyping results, design the cleanest API for process interaction that fits Darklang's style

// 3. **Implement minimal process spawning**: Start with basic spawn/read/write/wait functionality and expand as needed

// 4. **Add interactive test cases**: Once the API exists, add tests for:
//    - Interactive help navigation
//    - Multi-command sessions
//    - Error handling in interactive mode
//    - Tab completion (if supported)
//    - History navigation (if supported)

// ## Recommendation

// For now, we'll stick with the simple non-interactive tests. When ready to tackle interactive testing, we should start with **Option 2 (Process handle API)** as it provides the most flexibility while still being reasonably simple to use.