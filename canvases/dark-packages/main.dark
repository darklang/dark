// CLEANUP branchId tidyings

[<HttpHandler("GET", "/ping")>]
let _handler _req =
  Stdlib.Http.response (Stdlib.String.toBytes "pong") 200L


// Client/server or P2P setup?

// data.db -> client.db, server.db
// or leave data.db and just add server.db

// does the 'server' need a diff. schema at all?
// is anything stoed in a user db?


[<HttpHandler("POST", "/ops")>]
let _handler _req =
  let bodyBytes = request.body
  let bodyStr = Stdlib.String.fromBytesWithReplacement bodyBytes

  let branchId =
    (Stdlib.Http.Request.queryParams request)
    |> Stdlib.List.findFirst (fun pair ->
      match pair with
      | (key, _value) -> key == "branchId"
      | _ -> false)
    |> fun result ->
      match result with
      | Some((_key, value)) ->
        match Stdlib.Uuid.parse value with
        | Ok uuid -> Stdlib.Option.Option.Some uuid
        | Error _err -> Stdlib.Option.Option.None
      | None -> Stdlib.Option.Option.None

  match Builtin.jsonParse<List<LanguageTools.ProgramTypes.PackageOp>> bodyStr with
  | Ok ops ->
    // Add ops to database
    Builtin.scmAddOps branchId ops

    let opsCount = Builtin.int64ToString (Stdlib.List.length ops)

    let responseMsg = $"Successfully received and applied {opsCount} ops"

    Stdlib.Http.response (Stdlib.String.toBytes responseMsg) 200L

  | Error _err ->
    let errorMsg = "Invalid request body. Expected JSON list of PackageOps."

    Stdlib.Http.response (Stdlib.String.toBytes errorMsg) 400L


[<HttpHandler("GET", "/ops")>]
let _handler _req =
  let branchId =
    (Stdlib.Http.Request.queryParams request)
    |> Stdlib.List.findFirst (fun pair ->
      match pair with
      | (key, _value) -> key == "branchId"
      | _ -> false)
    |> fun result ->
      match result with
      | Some((_key, value)) ->
        match Stdlib.Uuid.parse value with
        | Ok uuid -> Stdlib.Option.Option.Some uuid
        | Error _err -> Stdlib.Option.Option.None
      | None -> Stdlib.Option.Option.None

  let sinceParam =
    // CLEANUP use a helper here, this should be a one-liner
    (Stdlib.Http.Request.queryParams request)
    |> Stdlib.List.findFirst (fun pair ->
      match pair with
      | (key, _value) -> key == "since")

  match sinceParam with
  | Some((_key, sinceStr)) ->
    match Stdlib.DateTime.parse sinceStr with
    | Ok sinceDate ->
      // Get ops since that date
      let ops =
        Darklang.SCM.PackageOps.getSince branchId sinceDate

      let json =
        Builtin.jsonSerialize<List<LanguageTools.ProgramTypes.PackageOp>> ops

      Stdlib.Http.response (Stdlib.String.toBytes json) 200L

    | Error _err ->
      let errorMsg = "Invalid 'since' parameter. Expected ISO 8601 datetime."

      Stdlib.Http.response (Stdlib.String.toBytes errorMsg) 400L

  | None ->
    let errorMsg = "Missing required query parameter: 'since'"

    Stdlib.Http.response (Stdlib.String.toBytes errorMsg) 400L



(*
if ocean and I have diverged at all, we could face weird sync issues
specifically due to .dark files not yet making it into ops, or something?

Maybe the start of a sync could be negotiated by reviewing what op IDs are in both places?
A: I have ops {1b6, 2b7, e43}
B: I have ops {1b6, e43}

OK to ignore for now, since we _can_ enforce that we start at the same point,
when the 'servers' are started up.
*)


(*backend thinking:

 what if someone is connecting for the first time?
 maybe the .db that we ship with the CLI has some 'since' date?
 Like when was that dump created?


LibPackageManager changes
- Sync.fs
  - checks sync DB to determine when we last synced
    `let lastSynced = ...`
  - push
    - gathers all Ops created since that sync
    - serialize the blobs for transport (binary?)
    - make HTTP request to `POST /ops` -- 200 OK
  - pull
    - make HTTP request to `POST /ops`
    - deserialize the blobs
    - insert op records into DB
  - record the sync results in the sync table
  - (future: push notification to CLI / VSCode, via dev server, "new stuff!")

  (callable from CLI or VS Code)
  (what order do we do these in? or maybe in parallel?)


right now this is written as if we must push+pull at the same time
should we chnage things so we only pull or only push?
if so, we likely need to record those dates separately


Builtins:
- Builtin.scmSync() -- no args, just calls that sync fn in the PM

VS Code changes:
- some 'sync' command
- maybe a button to trigger it
- maybe a view of the syncs (just list when we've synched and how many ops were pushed/pulled)


*)





// expose some metadata to quickly check if things seem to be working and populated
[<HttpHandler("GET", "/stats")>]
let _handler _req =
  let stats = Builtin.pmGetStats ()

  let body =
    $"Package stats:
- types: {stats.types |> Builtin.int64ToString}
- fns: {stats.fns |> Builtin.int64ToString}
- values: {stats.values |> Builtin.int64ToString}"
    |> Stdlib.String.toBytes

  Stdlib.Http.response body 200L


[<HttpHandler("GET", "/:location")>]
let _handler _req =
  let branchId =
    (Stdlib.Http.Request.queryParams request)
    |> Stdlib.List.findFirst (fun pair ->
      match pair with
      | (key, _value) -> key == "branchId"
      | _ -> false)
    |> fun result ->
      match result with
      | Some((_key, value)) ->
        match Stdlib.Uuid.parse value with
        | Ok uuid -> Stdlib.Option.Option.Some uuid
        | Error _err -> Stdlib.Option.Option.None
      | None -> Stdlib.Option.Option.None

  let parts = Stdlib.String.split location "."
  let partsLength = Stdlib.List.length parts

  if partsLength < 1L then
    let errorMsg = "Invalid location format. Expected 'Owner', 'Owner.Module', or 'Owner.Module.Name'"

    Stdlib.Http.response (Stdlib.String.toBytes errorMsg) 400L
  else if partsLength == 1L then
    let owner = (Stdlib.List.head parts) |> Builtin.unwrap

    let searchQuery =
      LanguageTools.ProgramTypes.Search.SearchQuery
        { currentModule = [ owner ]
          text = ""
          searchDepth =
            LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
          entityTypes =
            [ LanguageTools.ProgramTypes.Search.EntityType.Fn
              LanguageTools.ProgramTypes.Search.EntityType.Type
              LanguageTools.ProgramTypes.Search.EntityType.Value
              LanguageTools.ProgramTypes.Search.EntityType.Module ]
          exactMatch = false }

    let results = Builtin.pmSearch branchId searchQuery

    let json =
      Builtin.jsonSerialize<LanguageTools.ProgramTypes.Search.SearchResults>
        results

    Stdlib.Http.response (Stdlib.String.toBytes json) 200L
  else
    let owner = (Stdlib.List.head parts) |> Builtin.unwrap
    let entityName = (Stdlib.List.last parts) |> Builtin.unwrap
    let middleParts = (Stdlib.List.tail parts) |> Builtin.unwrap
    let modules = Stdlib.List.take middleParts (partsLength - 2L)

    let packageLocation =
      LanguageTools.ProgramTypes.PackageLocation
        { owner = owner; modules = modules; name = entityName }

    // Try to find as function first
    match Builtin.pmFindFn branchId packageLocation with
    | Some fnId ->
      match Builtin.pmGetFn fnId with
      | Some fn ->
        let json =
          Builtin.jsonSerialize<LanguageTools.ProgramTypes.PackageFn.PackageFn>
            fn

        Stdlib.Http.response (Stdlib.String.toBytes json) 200L
      | None -> Stdlib.Http.response (Stdlib.String.toBytes "not found") 404L

    | None ->
      // Try to find as type
      match Builtin.pmFindType branchId packageLocation with
      | Some typeId ->
        match Builtin.pmGetType typeId with
        | Some typeDefinition ->
          let json =
            Builtin.jsonSerialize<LanguageTools.ProgramTypes.PackageType.PackageType>
              typeDefinition

          Stdlib.Http.response (Stdlib.String.toBytes json) 200L
        | None ->
          Stdlib.Http.response (Stdlib.String.toBytes "not found") 404L

      | None ->
        // Try to find as value
        match Builtin.pmFindValue branchId packageLocation with
        | Some valueId ->
          match Builtin.pmGetValue valueId with
          | Some value ->
            let json =
              Builtin.jsonSerialize<LanguageTools.ProgramTypes.PackageValue.PackageValue>
                value

            Stdlib.Http.response (Stdlib.String.toBytes json) 200L
          | None ->
            Stdlib.Http.response (Stdlib.String.toBytes "not found") 404L

        | None ->
          // Not found as function, type, or value - treat as module query
          let modulePathParts = Stdlib.List.append modules [ entityName ]

          let searchQuery =
            LanguageTools.ProgramTypes.Search.SearchQuery
              { currentModule = Stdlib.List.append [ owner ] modulePathParts
                text = ""
                searchDepth =
                  LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                entityTypes =
                  [ LanguageTools.ProgramTypes.Search.EntityType.Fn
                    LanguageTools.ProgramTypes.Search.EntityType.Type
                    LanguageTools.ProgramTypes.Search.EntityType.Value
                    LanguageTools.ProgramTypes.Search.EntityType.Module ]
                exactMatch = false }

          let results = Builtin.pmSearch branchId searchQuery

          let json =
            Builtin.jsonSerialize<LanguageTools.ProgramTypes.Search.SearchResults>
              results

          Stdlib.Http.response (Stdlib.String.toBytes json) 200L


// // up for discussion:
//   // can 2 things of different classes have the same owner+modules+name?

//   // let List.empty()
//   // val List.empty

//   // if so, what should show when you go to:
//   // dark://package/Dark.Stdlib.List.empty
//   // ?
//   // or do we change URLs to
//   // dark://package/Dark.Stdlib.List.empty
//   // ?

//   // `List.empty` -- which thing am I referring to?




[<HttpHandler("GET", "/type/find/:name")>]
let _handler _req =
  let branchId =
    (Stdlib.Http.Request.queryParams request)
    |> Stdlib.List.findFirst (fun pair ->
      match pair with
      | (key, _value) -> key == "branchId"
      | _ -> false)
    |> fun result ->
      match result with
      | Some((_key, value)) ->
        match Stdlib.Uuid.parse value with
        | Ok uuid -> Stdlib.Option.Option.Some uuid
        | Error _err -> Stdlib.Option.Option.None
      | None -> Stdlib.Option.Option.None

  let parts = Stdlib.String.split name "."
  let partsLength = Stdlib.List.length parts

  if partsLength < 2L then
    let errorMsg = "Invalid name format. Expected 'Owner.Module.Name' or 'Owner.Name'"
    Stdlib.Http.response (Stdlib.String.toBytes errorMsg) 400L
  else
    let owner = (Stdlib.List.head parts) |> Builtin.unwrap
    let typeName = (Stdlib.List.last parts) |> Builtin.unwrap
    let middleParts = (Stdlib.List.tail parts) |> Builtin.unwrap
    let modules = Stdlib.List.take middleParts (partsLength - 2L)

    let location =
      LanguageTools.ProgramTypes.PackageLocation
        { owner = owner; modules = modules; name = typeName }

    match Builtin.pmFindType branchId location with
    | Some foundID ->
      let json = $"\"{Stdlib.Uuid.toString foundID}\""
      Stdlib.Http.response (Stdlib.String.toBytes json) 200L
    | None -> Stdlib.Http.response (Stdlib.String.toBytes "not found") 404L

[<HttpHandler("GET", "/type/get/:id")>]
let _handler _req =
  match Stdlib.Uuid.parse id with
  | Error _err ->
    let errorMsg = "Invalid UUID format for parameter 'id'"
    Stdlib.Http.response (Stdlib.String.toBytes errorMsg) 400L

  | Ok parsedId ->
    match Builtin.pmGetType parsedId with
    | Some f ->
      let json =
        Builtin.jsonSerialize<LanguageTools.ProgramTypes.PackageType.PackageType>
          f

      Stdlib.Http.response (Stdlib.String.toBytes json) 200L

    | None -> Stdlib.Http.response (Stdlib.String.toBytes "not found") 404L


[<HttpHandler("GET", "/value/find/:name")>]
let _handler _req =
  let branchId =
    (Stdlib.Http.Request.queryParams request)
    |> Stdlib.List.findFirst (fun pair ->
      match pair with
      | (key, _value) -> key == "branchId"
      | _ -> false)
    |> fun result ->
      match result with
      | Some((_key, value)) ->
        match Stdlib.Uuid.parse value with
        | Ok uuid -> Stdlib.Option.Option.Some uuid
        | Error _err -> Stdlib.Option.Option.None
      | None -> Stdlib.Option.Option.None

  let parts = Stdlib.String.split name "."
  let partsLength = Stdlib.List.length parts

  if partsLength < 2L then
    let errorMsg = "Invalid name format. Expected 'Owner.Module.Name' or 'Owner.Name'"
    Stdlib.Http.response (Stdlib.String.toBytes errorMsg) 400L
  else
    let owner = (Stdlib.List.head parts) |> Builtin.unwrap
    let valueName = (Stdlib.List.last parts) |> Builtin.unwrap
    let middleParts = (Stdlib.List.tail parts) |> Builtin.unwrap
    let modules = Stdlib.List.take middleParts (partsLength - 2L)

    let location =
      LanguageTools.ProgramTypes.PackageLocation
        { owner = owner; modules = modules; name = valueName }

    match Builtin.pmFindValue branchId location with
    | Some foundID ->
      let json = $"\"{Stdlib.Uuid.toString foundID}\""
      Stdlib.Http.response (Stdlib.String.toBytes json) 200L
    | None -> Stdlib.Http.response (Stdlib.String.toBytes "not found") 404L

[<HttpHandler("GET", "/value/get/:id")>]
let _handler _req =
  match Stdlib.Uuid.parse id with
  | Error _err ->
    let errorMsg = "Invalid UUID format for parameter 'id'"
    Stdlib.Http.response (Stdlib.String.toBytes errorMsg) 400L

  | Ok parsedId ->
    match Builtin.pmGetValue parsedId with
    | Some f ->
      let json =
        Builtin.jsonSerialize<LanguageTools.ProgramTypes.PackageValue.PackageValue>
          f

      Stdlib.Http.response (Stdlib.String.toBytes json) 200L

    | None -> Stdlib.Http.response (Stdlib.String.toBytes "not found") 404L


[<HttpHandler("GET", "/function/find/:name")>]
let _handler _req =
  let branchId =
    (Stdlib.Http.Request.queryParams request)
    |> Stdlib.List.findFirst (fun pair ->
      match pair with
      | (key, _value) -> key == "branchId"
      | _ -> false)
    |> fun result ->
      match result with
      | Some((_key, value)) ->
        match Stdlib.Uuid.parse value with
        | Ok uuid -> Stdlib.Option.Option.Some uuid
        | Error _err -> Stdlib.Option.Option.None
      | None -> Stdlib.Option.Option.None

  let parts = Stdlib.String.split name "."
  let partsLength = Stdlib.List.length parts

  if partsLength < 2L then
    let errorMsg = "Invalid name format. Expected 'Owner.Module.Name' or 'Owner.Name'"
    Stdlib.Http.response (Stdlib.String.toBytes errorMsg) 400L
  else
    let owner = (Stdlib.List.head parts) |> Builtin.unwrap
    let fnName = (Stdlib.List.last parts) |> Builtin.unwrap
    let middleParts = (Stdlib.List.tail parts) |> Builtin.unwrap
    let modules = Stdlib.List.take middleParts (partsLength - 2L)

    let location =
      LanguageTools.ProgramTypes.PackageLocation
        { owner = owner; modules = modules; name = fnName }

    match Builtin.pmFindFn branchId location with
    | Some foundID ->
      let json = $"\"{Stdlib.Uuid.toString foundID}\""
      Stdlib.Http.response (Stdlib.String.toBytes json) 200L
    | None -> Stdlib.Http.response (Stdlib.String.toBytes "not found") 404L

[<HttpHandler("GET", "/function/get/:id")>]
let _handler _req =
  match Stdlib.Uuid.parse id with
  | Error _err ->
    let errorMsg = "Invalid UUID format for parameter 'id'"
    Stdlib.Http.response (Stdlib.String.toBytes errorMsg) 400L

  | Ok parsedId ->
    match Builtin.pmGetFn parsedId with
    | Some f ->
      let json =
        Builtin.jsonSerialize<LanguageTools.ProgramTypes.PackageFn.PackageFn> f

      Stdlib.Http.response (Stdlib.String.toBytes json) 200L

    | None -> Stdlib.Http.response (Stdlib.String.toBytes "not found") 404L


[<HttpHandler("GET", "/search")>]
let _handler _req =
  let branchId =
    (Stdlib.Http.Request.queryParams request)
    |> Stdlib.List.findFirst (fun pair ->
      match pair with
      | (key, _value) -> key == "branchId"
      | _ -> false)
    |> fun result ->
      match result with
      | Some((_key, value)) ->
        match Stdlib.Uuid.parse value with
        | Ok uuid -> Stdlib.Option.Option.Some uuid
        | Error _err -> Stdlib.Option.Option.None
      | None -> Stdlib.Option.Option.None

  let modulesParam =
    (Stdlib.Http.Request.queryParams request)
    |> Stdlib.List.findFirst (fun pair ->
      match pair with
      | (key, _value) -> key == "modules"
      | _ -> false)

  match modulesParam with
  | None ->
    let errorMsg = "Missing required query parameter: 'modules'"
    Stdlib.Http.response (Stdlib.String.toBytes errorMsg) 400L

  | Some((_key, modulesStr)) ->
    let currentModule = Stdlib.String.split modulesStr "."

    let text =
      (Stdlib.Http.Request.queryParams request)
      |> Stdlib.List.filterMap (fun pair ->
        match pair with
        | (k, v) ->
          if k == "text" then
            Stdlib.Option.Option.Some v
          else
            Stdlib.Option.Option.None
        | _ -> Stdlib.Option.Option.None)
      |> fun text ->
        match text with
        | [] -> ""
        | _ ->
          (Stdlib.List.head text)
          |> Builtin.unwrap

    let searchDepthParam =
      (Stdlib.Http.Request.queryParams request)
      |> Stdlib.List.findFirst (fun pair ->
        match pair with
        | (key, _value) -> key == "searchDepth"
        | _ -> false)

    match searchDepthParam with
    | None ->
      let errorMsg = "Missing required query parameter: 'searchDepth'"
      Stdlib.Http.response (Stdlib.String.toBytes errorMsg) 400L

    | Some((_key, depthStr)) ->
      let searchDepth =
        match depthStr with
        | "direct" ->
          LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
        | _ ->
          LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants

      let entityTypesParam =
        (Stdlib.Http.Request.queryParams request)
        |> Stdlib.List.findFirst (fun pair ->
          match pair with
          | (key, _value) -> key == "entityTypes"
          | _ -> false)

      match entityTypesParam with
      | None ->
        let errorMsg = "Missing required query parameter: 'entityTypes'"
        Stdlib.Http.response (Stdlib.String.toBytes errorMsg) 400L

      | Some((_key, entityTypesStr)) ->
        let entityTypes =
          (Stdlib.String.split entityTypesStr ",")
          |> Stdlib.List.map (fun entityType ->
            match entityType with
            | "type" -> LanguageTools.ProgramTypes.Search.EntityType.Type
            | "value" -> LanguageTools.ProgramTypes.Search.EntityType.Value
            | "function" -> LanguageTools.ProgramTypes.Search.EntityType.Fn
            | "module" -> LanguageTools.ProgramTypes.Search.EntityType.Module)
          |> Stdlib.List.unique

        let exactMatch =
          (Stdlib.Http.Request.queryParams request)
          |> Stdlib.List.filterMap (fun pair ->
            match pair with
            | (k, v) ->
              if k == "exactMatch" then
                Stdlib.Option.Option.Some v
              else
                Stdlib.Option.Option.None
            | _ -> Stdlib.Option.Option.None)
          |> Stdlib.List.head
          |> fun em ->
            match em with
            | None -> false
            | Some em ->
              match em with
              | "true" -> true
              | "false" -> false
              | _ -> false


        let query =
          LanguageTools.ProgramTypes.Search.SearchQuery
            { currentModule = currentModule
              text = text
              searchDepth = searchDepth
              entityTypes = entityTypes
              exactMatch = exactMatch }

        let results = Builtin.pmSearch branchId query

        let json =
          Builtin.jsonSerialize<LanguageTools.ProgramTypes.Search.SearchResults>
            results

        Stdlib.Http.response (Stdlib.String.toBytes json) 200L



// FUTURE:
// type HttpHandler =
//   { verb: String
//     route: String
//     body: HttpRequest -> HttpResponse }

// let handler =
//   HttpHandler
//     { verb = "GET"
//       route = "/ops"
//       body =
//         fun req ->
//         }
