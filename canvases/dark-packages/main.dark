[<HttpHandler("GET", "/ping")>]
let _handler _req =
  Stdlib.Http.response (Stdlib.String.toBytes "pong") 200L


let getQueryParam (req: Stdlib.Http.Request) (key: String) : Stdlib.Option.Option<String> =
  (Stdlib.Http.Request.queryParams req)
  |> Stdlib.List.findFirst (fun pair ->
    match pair with
    | (k, _value) -> k == key
    | _ -> false)
  |> fun result ->
    match result with
    | Some((_k, value)) -> Stdlib.Option.Option.Some value
    | None -> Stdlib.Option.Option.None


let parseNameToLocation (name: String) : Stdlib.Result.Result<LanguageTools.ProgramTypes.PackageLocation, String> =
  let parts = Stdlib.String.split name "."
  let partsLength = Stdlib.List.length parts

  if partsLength < 2L then
    Stdlib.Result.Result.Error "Invalid name format. Expected 'Owner.Module.Name' or 'Owner.Name'"
  else
    let owner = (Stdlib.List.head parts) |> Builtin.unwrap
    let entityName = (Stdlib.List.last parts) |> Builtin.unwrap
    let middleParts = (Stdlib.List.tail parts) |> Builtin.unwrap
    let modules = Stdlib.List.take middleParts (partsLength - 2L)

    (LanguageTools.ProgramTypes.PackageLocation
      { owner = owner; modules = modules; name = entityName })
    |> Stdlib.Result.Result.Ok


let parseUuidParam (value: String) : Stdlib.Result.Result<Uuid, Stdlib.Http.Response> =
  match Stdlib.Uuid.parse value with
  | Ok parsedId -> Stdlib.Result.Result.Ok parsedId
  | Error _err ->
    let errorMsg = "Invalid UUID format for parameter 'id'"
    let response = Stdlib.Http.response (Stdlib.String.toBytes errorMsg) 400L
    Stdlib.Result.Result.Error response


[<HttpHandler("POST", "/ops")>]
let _handler _req =
  let bodyStr = Stdlib.String.fromBytesWithReplacement request.body

  match Builtin.jsonParse<List<LanguageTools.ProgramTypes.PackageOp>> bodyStr with
  | Ok ops ->
    // Add ops as WIP - TODO: sync endpoint should handle commits differently
    match SCM.PackageOps.add ops with
    | Ok insertedCount ->
      let countStr = Builtin.int64ToString insertedCount
      let responseMsg = $"Successfully received and applied {countStr} ops"
      Stdlib.Http.response (Stdlib.String.toBytes responseMsg) 200L

    | Error errorMsg ->
      Stdlib.Http.response (Stdlib.String.toBytes errorMsg) 500L

  | Error _err ->
    let errorMsg = "Invalid request body. Expected JSON list of PackageOp."
    Stdlib.Http.response (Stdlib.String.toBytes errorMsg) 400L


[<HttpHandler("GET", "/ops")>]
let _handler _req =
  match getQueryParam request "limit" with
  | None ->
    let errorMsg = "Missing required query parameter: 'limit'"
    Stdlib.Http.response (Stdlib.String.toBytes errorMsg) 400L

  | Some limitStr ->
    match Stdlib.Int64.parse limitStr with
    | Ok limit ->
      let ops = SCM.PackageOps.getRecent limit
      let json = ops |> Builtin.jsonSerialize<List<LanguageTools.ProgramTypes.PackageOp>>
      Stdlib.Http.response (Stdlib.String.toBytes json) 200L

    | Error _err ->
      let errorMsg = "Invalid 'limit' parameter. Expected integer."
      Stdlib.Http.response (Stdlib.String.toBytes errorMsg) 400L



// expose some metadata to quickly check if things seem to be working and populated
[<HttpHandler("GET", "/stats")>]
let _handler _req =
  let stats = Builtin.pmGetStats ()

  let body =
    $"Package stats:
- types: {stats.types |> Builtin.int64ToString}
- fns: {stats.fns |> Builtin.int64ToString}
- values: {stats.values |> Builtin.int64ToString}"
    |> Stdlib.String.toBytes

  Stdlib.Http.response body 200L


[<HttpHandler("GET", "/:location")>]
let _handler _req =
  let parts = Stdlib.String.split location "."
  let partsLength = Stdlib.List.length parts

  if partsLength < 1L then
    let errorMsg = "Invalid location format. Expected 'Owner', 'Owner.Module', or 'Owner.Module.Name'"
    Stdlib.Http.response (Stdlib.String.toBytes errorMsg) 400L
  else if partsLength == 1L then
    let owner = (Stdlib.List.head parts) |> Builtin.unwrap

    let searchQuery =
      LanguageTools.ProgramTypes.Search.SearchQuery
        { currentModule = [ owner ]
          text = ""
          searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
          entityTypes = []
          exactMatch = false }

    let results = Builtin.pmSearch searchQuery
    let json = results |> Builtin.jsonSerialize<LanguageTools.ProgramTypes.Search.SearchResults>
    Stdlib.Http.response (Stdlib.String.toBytes json) 200L
  else
    let owner = (Stdlib.List.head parts) |> Builtin.unwrap
    let entityName = (Stdlib.List.last parts) |> Builtin.unwrap
    let middleParts = (Stdlib.List.tail parts) |> Builtin.unwrap
    let modules = Stdlib.List.take middleParts (partsLength - 2L)

    let packageLocation =
      LanguageTools.ProgramTypes.PackageLocation
        { owner = owner; modules = modules; name = entityName }

    // Try to find as function first
    match Builtin.pmFindFn packageLocation with
    | Some fnId ->
      match Builtin.pmGetFn fnId with
      | Some fn ->
        let json = fn |> Builtin.jsonSerialize<LanguageTools.ProgramTypes.PackageFn.PackageFn>

        Stdlib.Http.response (Stdlib.String.toBytes json) 200L
      | None -> Stdlib.Http.response (Stdlib.String.toBytes "not found") 404L

    | None ->
      // Try to find as type
      match Builtin.pmFindType packageLocation with
      | Some typeId ->
        match Builtin.pmGetType typeId with
        | Some typeDefinition ->
          let json = typeDefinition |> Builtin.jsonSerialize<LanguageTools.ProgramTypes.PackageType.PackageType>
          Stdlib.Http.response (Stdlib.String.toBytes json) 200L
        | None ->
          Stdlib.Http.response (Stdlib.String.toBytes "not found") 404L

      | None ->
        // Try to find as value
        match Builtin.pmFindValue packageLocation with
        | Some valueId ->
          match Builtin.pmGetValue valueId with
          | Some value ->
            let json = value |> Builtin.jsonSerialize<LanguageTools.ProgramTypes.PackageValue.PackageValue>
            Stdlib.Http.response (Stdlib.String.toBytes json) 200L
          | None ->
            Stdlib.Http.response (Stdlib.String.toBytes "not found") 404L

        | None ->
          // Not found as function, type, or value - treat as module query
          let modulePathParts = Stdlib.List.append modules [ entityName ]

          let searchQuery =
            LanguageTools.ProgramTypes.Search.SearchQuery
              { currentModule = Stdlib.List.append [ owner ] modulePathParts
                text = ""
                searchDepth = LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
                entityTypes = [ ]
                exactMatch = false }

          let results = Builtin.pmSearch searchQuery
          let json = results |> Builtin.jsonSerialize<LanguageTools.ProgramTypes.Search.SearchResults>
          Stdlib.Http.response (Stdlib.String.toBytes json) 200L


[<HttpHandler("GET", "/type/find/:name")>]
let _handler _req =
  match parseNameToLocation name with
  | Error errorMsg -> Stdlib.Http.response (Stdlib.String.toBytes errorMsg) 400L
  | Ok location ->
    match Builtin.pmFindType location with
    | Some foundID ->
      let json = $"\"{Stdlib.Uuid.toString foundID}\""
      Stdlib.Http.response (Stdlib.String.toBytes json) 200L
    | None -> Stdlib.Http.response (Stdlib.String.toBytes "not found") 404L

[<HttpHandler("GET", "/type/get/:id")>]
let _handler _req =
  match parseUuidParam id with
  | Error response -> response
  | Ok parsedId ->
    match Builtin.pmGetType parsedId with
    | Some t ->
      let json = t |> Builtin.jsonSerialize<LanguageTools.ProgramTypes.PackageType.PackageType>
      Stdlib.Http.response (Stdlib.String.toBytes json) 200L
    | None -> Stdlib.Http.response (Stdlib.String.toBytes "not found") 404L


[<HttpHandler("GET", "/type/get/with-location/:id")>]
let _handler _req =
  match parseUuidParam id with
  | Error response -> response
  | Ok parsedId ->
    match LanguageTools.PackageManager.Type.getWithLocation parsedId with
    | Some locatedItem ->
      let json =
        locatedItem
        |> Builtin.jsonSerialize<LanguageTools.ProgramTypes.LocatedItem<LanguageTools.ProgramTypes.PackageType.PackageType>>
      Stdlib.Http.response (Stdlib.String.toBytes json) 200L
    | None -> Stdlib.Http.response (Stdlib.String.toBytes "not found") 404L


[<HttpHandler("GET", "/value/find/:name")>]
let _handler _req =
  match parseNameToLocation name with
  | Ok location ->
    match Builtin.pmFindValue location with
    | Some foundID ->
      let json = $"\"{Stdlib.Uuid.toString foundID}\""
      Stdlib.Http.response (Stdlib.String.toBytes json) 200L
    | None -> Stdlib.Http.response (Stdlib.String.toBytes "not found") 404L
  | Error errorMsg -> Stdlib.Http.response (Stdlib.String.toBytes errorMsg) 400L

[<HttpHandler("GET", "/value/get/:id")>]
let _handler _req =
  match parseUuidParam id with
  | Error response -> response
  | Ok parsedId ->
    match Builtin.pmGetValue parsedId with
    | Some v ->
      let json = v |> Builtin.jsonSerialize<LanguageTools.ProgramTypes.PackageValue.PackageValue>
      Stdlib.Http.response (Stdlib.String.toBytes json) 200L
    | None -> Stdlib.Http.response (Stdlib.String.toBytes "not found") 404L


[<HttpHandler("GET", "/value/get/with-location/:id")>]
let _handler _req =
  match parseUuidParam id with
  | Error response -> response
  | Ok parsedId ->
    match LanguageTools.PackageManager.Value.getWithLocation parsedId with
    | Some locatedItem ->
      let json = locatedItem |> Builtin.jsonSerialize<LanguageTools.ProgramTypes.LocatedItem<LanguageTools.ProgramTypes.PackageValue.PackageValue>>
      Stdlib.Http.response (Stdlib.String.toBytes json) 200L
    | None -> Stdlib.Http.response (Stdlib.String.toBytes "not found") 404L


[<HttpHandler("GET", "/function/find/:name")>]
let _handler _req =
  match parseNameToLocation name with
  | Error errorMsg -> Stdlib.Http.response (Stdlib.String.toBytes errorMsg) 400L
  | Ok location ->
    match Builtin.pmFindFn location with
    | Some foundID ->
      let json = $"\"{Stdlib.Uuid.toString foundID}\""
      Stdlib.Http.response (Stdlib.String.toBytes json) 200L
    | None -> Stdlib.Http.response (Stdlib.String.toBytes "not found") 404L

[<HttpHandler("GET", "/function/get/:id")>]
let _handler _req =
  match parseUuidParam id with
  | Error response -> response
  | Ok parsedId ->
    match Builtin.pmGetFn parsedId with
    | Some f ->
      let json = f |> Builtin.jsonSerialize<LanguageTools.ProgramTypes.PackageFn.PackageFn>
      Stdlib.Http.response (Stdlib.String.toBytes json) 200L
    | None -> Stdlib.Http.response (Stdlib.String.toBytes "not found") 404L


[<HttpHandler("GET", "/function/get/with-location/:id")>]
let _handler _req =
  match parseUuidParam id with
  | Error response -> response
  | Ok parsedId ->
    match LanguageTools.PackageManager.Function.getWithLocation parsedId with
    | Some locatedItem ->
      let json =
        locatedItem
        |> Builtin.jsonSerialize<LanguageTools.ProgramTypes.LocatedItem<LanguageTools.ProgramTypes.PackageFn.PackageFn>>
      Stdlib.Http.response (Stdlib.String.toBytes json) 200L
    | None -> Stdlib.Http.response (Stdlib.String.toBytes "not found") 404L


[<HttpHandler("GET", "/search")>]
let _handler _req =
  match getQueryParam request "modules" with
  | None ->
    let errorMsg = "Missing required query parameter: 'modules'"
    Stdlib.Http.response (Stdlib.String.toBytes errorMsg) 400L

  | Some modulesStr ->
    let currentModule = Stdlib.String.split modulesStr "."

    let text =
      match getQueryParam request "text" with
      | Some t -> t
      | None -> ""

    match getQueryParam request "searchDepth" with
    | None ->
      let errorMsg = "Missing required query parameter: 'searchDepth'"
      Stdlib.Http.response (Stdlib.String.toBytes errorMsg) 400L

    | Some depthStr ->
      let searchDepth =
        match depthStr with
        | "direct" -> LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants
        | "all" -> LanguageTools.ProgramTypes.Search.SearchDepth.AllDescendants
        | _ -> LanguageTools.ProgramTypes.Search.SearchDepth.OnlyDirectDescendants

      match getQueryParam request "entityTypes" with
      | None ->
        let errorMsg = "Missing required query parameter: 'entityTypes'"
        Stdlib.Http.response (Stdlib.String.toBytes errorMsg) 400L

      | Some entityTypesStr ->
        let entityTypes =
          (Stdlib.String.split entityTypesStr ",")
          |> Stdlib.List.map (fun entityType ->
            match entityType with
            | "type" -> LanguageTools.ProgramTypes.Search.EntityType.Type
            | "value" -> LanguageTools.ProgramTypes.Search.EntityType.Value
            | "function" -> LanguageTools.ProgramTypes.Search.EntityType.Fn
            | "module" -> LanguageTools.ProgramTypes.Search.EntityType.Module)
          |> Stdlib.List.unique

        let exactMatch =
          match getQueryParam request "exactMatch" with
          | None -> false
          | Some em ->
            match em with
            | "true" -> true
            | "false" -> false
            | _ -> false

        let query =
          LanguageTools.ProgramTypes.Search.SearchQuery
            { currentModule = currentModule
              text = text
              searchDepth = searchDepth
              entityTypes = entityTypes
              exactMatch = exactMatch }

        let results = Builtin.pmSearch query
        let json = results |> Builtin.jsonSerialize<LanguageTools.ProgramTypes.Search.SearchResults>
        Stdlib.Http.response (Stdlib.String.toBytes json) 200L
