[<HttpHandler("GET", "/static/:path")>]
let _handler _req =
  let body =
    (Experiments.readFromStaticDir path)
    |> Result.withDefault Bytes.empty

  let contentType =
    match (String.split_v1 path ".") |> List.last_v2 |> Option.withDefault "" with
    | "wasm" -> "application/wasm"
    | "js" -> "text/javascript"
    | "dll" -> "application/octet-stream"
    | "dat" -> "application/octet-stream"
    | "blat" -> "application/octet-stream"
    | "json" -> "application/json"
    | _ -> "text/plain"

  let incomingHost =
    request.headers
    |> List.findFirst_v2 (fun t -> Tuple2.first t == "origin")
    |> Option.map_v1 (fun t -> Tuple2.second t)
    |> Option.withDefault "Couldn't find 'origin' request header to determine Access-Control-Allow-Origin"

  let headers =
    Dict.fromListOverwritingDuplicates
      [
        ("Access-Control-Allow-Origin", incomingHost)
        ("Access-Control-Allow-Credentials", "true")
        ("Content-type", contentType)
        ("Accept-Ranges", "bytes")
      ]

  Http.responseWithHeaders body headers 200

[<HttpHandler("GET", "/")>]
let _indexHandler _req =
  // TODO: HTML of a basic webpage, that references WASM stuff
  let body =
    """
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dark Tree-Sitter WASM demo</title>
    <style>
      * {font-size: 24px;}
      body, html { height: 100%; margin: 0; font-family: Arial, sans-serif }
      .container { display: flex; height: 100%; }
      .left-side, .middle, .right-side { flex: 1; padding: 10px; }
      .textarea { width: 100%; height: 100%; resize: none; }
    </style>
  </head>

  <body>
    <div class="container">
      <div class="left-side">
        <label>Source code:</label>
        <textarea id="input-textarea" class="textarea">let add (a: int) (b: int): int =
  let sum = a + b
  sum</textarea>
      </div>

      <div class="middle">
        <label>Syntax tree</label>
        <textarea id="syntax-textarea" class="textarea" disabled></textarea>
      </div>

      <div class="right-side">
        <label>Expr</label>
        <textarea id="right-textarea" class="textarea" disabled></textarea>
      </div>
    </div>
    <script src="/static/tree-sitter/tree-sitter.js" />
    <script>console.log('NOT SURE WHY I NEED THIS')</script>
    <script>
      function toSimpleTree(getFieldName, node) {
        // I seem to be having some trouble extracting the field names,
        // but suspect I can get by without them for now.
        // TODO: either remove this code, or pursue extracting field names further.

        // const fieldId = node.walk().currentFieldId();
        // const fieldName = node.walk().currentFieldName();
        // console.log('f', fieldId, fieldName);

        const response =
          { typ: node.type,
            text: node.text,
            children: node.children.map(n => toSimpleTree(getFieldName, n)) }

        return response;
      }

      const Parser = window.TreeSitter;

      Parser.init().then(async () => {
        const parser = new Parser;

        const inputTextarea = document.getElementById("input-textarea");

        const Darklang = await Parser.Language.load("/static/tree-sitter/tree-sitter-darklang.wasm");
        parser.setLanguage(Darklang);

        console.log(Darklang.fieldCount);

        function parseAndUpdateOutput () {
          const darkSourceCode = document.getElementById("input-textarea").value;
          const darkTree = parser.parse(darkSourceCode);

          let getFieldName = (id) => Darklang.fieldNameForId(id);
          let simpleTree = toSimpleTree(getFieldName, darkTree.rootNode);
          // TODO: send _this_ to (in-WASM) Dark, to be mapped into an Expr

          document.getElementById("syntax-textarea").value = JSON.stringify(simpleTree, null, 2);
        }

        inputTextarea.addEventListener("input", () => {
          parseAndUpdateOutput();
        });

        parseAndUpdateOutput();
      });
    </script>
  </body>
</html>
  """

  Http.responseWithHeaders (String.toBytes body) (Dict.fromListOverwritingDuplicates [("Content-Type", "text/html")]) 200


// TODO: eventually:
// - PT stuff should be exposed elsewhere
// - so should SyntaxTree stuff
// - ...and the mapping function, connecting the two
// but for now, demoing the ideas here is good enough

(*
just enough to support this function

let add (a: Int) (b: Int): Int =
  let sum = a + b
  sum

(in syntax, expr fuzzer, parser, etc)
*)


type PT_TypeReference =
  | TInt


type PT_Expr =
  | EInt of Int
  | ELet of identifier: String * expr: PT_Expr * body: PT_Expr
  | EVariable of String
  | EFnCall of fnName: String * args : List<PT_Expr>

// // TODO: deal with nesting
// let prettyPrintExpr (expr: PT_Expr): string =
//   match expr with
//   | EInt i -> string i
//   | ELet (identifier, expr, body) ->
//     "let " ++ identifier ++ " = " ++ (prettyPrintExpr expr) ++ "\n" ++ (prettyPrintExpr body)
//   | EVariable name -> name
//   | EFnCall (fnName, args) ->
//     // TODO: wrap results of prettyPrintExpr in () if there would be ambiguity
//     fnName ++ " " ++ (args |> List.map prettyPrintExpr |> String.concat " ")


// type PT_UserFunctionParameter =
//   { name: string
//     typ: PT_TypeReference }

// type PT_UserFunction =
//   { name: string
//     firstParameter: PT_UserFunctionParameter
//     additionalParameters: List<PT_UserFunctionParameter>
//     returnType: PT_TypeReference
//     body: PT_Expr }


// type SyntaxTreeNode =
//   { typ: String
//     text: String
//     children: List<SyntaxTree> }

// type SyntaxTree = { root: SyntaxTreeNode }

// let parseSynTree (source: String): SyntaxTree =
//   Json.parse<SyntaxTree> source


// let findChild (children: List<SyntaxTreeNode>) (typ: String) =
//   children |> List.find (fun c -> c.typ = typ)

// let getText (node: SyntaxTreeNode) =
//   node.text

// let parseAsExpr (synTree: SyntaxTree)
//   let root = parsed.root

//   let children = root.children

//   match root.typ with
//   | "let_expression" ->
//     let identifier = findChild children "identifier" |> getText
//     let expr = findChild children "expr" |> parseAsExpr
//     let body = findChild children "body" |> parseAsExpr
//     ELet (identifier, expr, body)
//   | "identifier" ->
//     EVariable (getText root)
//   | "integer" ->
//     EInt (getText root |> Int.parse)
//   | "function_call" ->
//     let fnName = findChild children "fn" |> getText

//     let args =
//       findChild children "args"
//       |> fun args -> args.children |> List.map parseAsExpr

//     EFnCall (fnName, args)



// let something (serializedSynTree: String): string
//   // TODO: theoretically, we could even pass in the source code
//   // instead of the serialized syntax tree, and then parse it
//   // somehow in Dark?

//   serializedSynTree
//   |> parseSynTree
//   |> parseAsExpr
//   |> prettyPrintExpr
//   // TODO: check to see if it's the same..?
//   // or, I guess that can be handled 'above' somewhere, or even just visually in UI


// [<HttpHandler("POST", "/something")>]
// let _handler _req =
//   let reqBodyStr = request.body |> String.fromBytes
//   let respBody = something reqBodyStr |> String.toBytes
//   Http.responseWithHeaders respBody (Dict.fromListOverwritingDuplicates [("Content-Type", "text/plain")]) 200




// 1. Define all of the stuff you want to be able to parse
// 2. Define all of the tokens relevant when stringifying the stuff
//   // something like this https://github.com/darklang/classic-dark/blob/main/client/src/fluid/FluidTypes.res#L48-L162
// 3. Define a map from stuff to tokens

// it sort of seems possible to derive the parser automatically
// from this information?
// Here's how:
