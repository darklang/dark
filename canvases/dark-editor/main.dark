[<HttpHandler("GET", "/")>]
let _handler _req =
  let filePath =  "dark-editor-vue/dist/index.html"
  let file = Experiments.readFromCanvases filePath
  let body =
    match file with
    | Ok f ->  f
    | Error _ -> Bytes.empty

  Http.responseWithHeaders
    (body)
    (Dict.fromListOverwritingDuplicates [ ("Content-Type", "text/html") ])
    200


[<HttpHandler("POST", "/get-program-json")>]
let _handler _req =
  let sourceInBytes = request.body
  let program =
    Experiments.parseAndSerializeProgram (String.fromBytes sourceInBytes)

  match program with
  | Ok program ->
    let types = Option.withDefault (Dict.get_v2 program "types") "[]"
    let fns = Option.withDefault (Dict.get_v2 program "fns") "[]"
    let exprs = Option.withDefault (Dict.get_v2 program "exprs") "[]"

    let json = "{ \"types\": " ++ types ++ ", \"fns\": " ++ fns ++ ", \"exprs\": " ++ exprs ++ "}"

    Http.responseWithHeaders
      (String.toBytes json)
      (Dict.fromListOverwritingDuplicates [ ("content-type","application-json")])
      200

  | Error err -> Http.response (String.toBytes ("Couldn't parse the program \n" ++ err)) 400


[<HttpHandler("GET", "/assets/index.css")>]
let _handler _req =
    let path =  "dark-editor-vue/dist/assets/index.css"
    let file = Experiments.readFromCanvases path
    let headers =
        Dict.fromListOverwritingDuplicates
            [
                ("Content-Type", "text/css")
            ]

    match file with
    | Ok f ->  Http.responseWithHeaders f headers 200
    | Error _ -> Http.response e 400

[<HttpHandler("GET", "/assets/index.js")>]
let _handler _req =
    let path =  "dark-editor-vue/dist/assets/index.js"
    let file = Experiments.readFromCanvases path
    let headers =
        Dict.fromListOverwritingDuplicates
            [
                ("Content-Type", "application/javascript")
            ]

    match file with
    | Ok f ->  Http.responseWithHeaders f headers 200
    | Error _ -> Http.response e 400


[<HttpHandler("GET", "/get-prompt")>]
let _handler _req =
  let filePath = "dark-editor/prompt.txt"
  let prompt = Experiments.readFromCanvases filePath

  let respBody =
    match prompt with
    | Ok p ->  p
    | Error _ -> Bytes.empty

  Http.response respBody 200



[<HttpHandler("POST", "/save-prompt")>]
let _handler _req =
  let filePath = "/home/dark/app/canvases/dark-editor/prompt.txt"
  let contents =  request.body
  let result = File.write contents filePath

  match result with
  | Ok r ->   Http.response r 200
  | Error e ->  Http.response e 400



type OpenAICompletionRequest = {
  model: String
  max_tokens: Int
  temperature: Float
  prompt : String
}

[<HttpHandler("POST", "/api/gpt4")>]
let _handler _req =
  let apiKey = OPENAI_API_KEY

  let reqBody =
    let prompt = request.body |> String.fromBytes
    let serialized =
      (OpenAICompletionRequest
        { model = "text-davinci-003"
          max_tokens = 700
          temperature = 0.7
          prompt = prompt }
      )
      |> Json.serialize<OpenAICompletionRequest>
    match serialized with
    | Ok r -> r |> String.toBytes
    | Error e -> Bytes.empty

  let headers =
    [
      ("Authorization", "Bearer " ++ apiKey)
      ("Content-Type", "application/json")
    ]

  let response = HttpClient.request "POST" "https://api.openai.com/v1/completions" headers reqBody

  match response with
  | Ok r -> Http.response r.body 200
  | Error e -> Http.response e 400


